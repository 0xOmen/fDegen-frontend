{
  "version": 3,
  "sources": ["../../@openzeppelin/ui-react/src/hooks/AdapterContext.tsx", "../../@openzeppelin/ui-react/src/hooks/AdapterProvider.tsx", "../../@openzeppelin/ui-react/src/hooks/WalletStateContext.ts", "../../@openzeppelin/ui-react/src/hooks/useAdapterContext.ts", "../../@openzeppelin/ui-react/src/hooks/WalletStateProvider.tsx", "../../@openzeppelin/ui-react/src/hooks/AnalyticsContext.tsx", "../../@openzeppelin/ui-react/src/hooks/AnalyticsProvider.tsx", "../../@openzeppelin/ui-react/src/hooks/useAnalytics.ts", "../../@openzeppelin/ui-react/src/hooks/useWalletComponents.ts", "../../@openzeppelin/ui-react/src/hooks/useDerivedAccountStatus.ts", "../../@openzeppelin/ui-react/src/hooks/useDerivedSwitchChainStatus.ts", "../../@openzeppelin/ui-react/src/hooks/useDerivedChainInfo.ts", "../../@openzeppelin/ui-react/src/hooks/useDerivedConnectStatus.ts", "../../@openzeppelin/ui-react/src/hooks/useDerivedDisconnect.ts", "../../@openzeppelin/ui-react/src/hooks/useWalletReconnectionHandler.ts", "../../@openzeppelin/ui-react/src/components/WalletConnectionUI.tsx", "../../@openzeppelin/ui-react/src/components/WalletConnectionHeader.tsx", "../../@openzeppelin/ui-react/src/components/NetworkSwitchManager.tsx"],
  "sourcesContent": ["/**\n * AdapterContext.tsx\n *\n * This file defines the React Context used for the adapter singleton pattern.\n * It provides types and the context definition, but the actual implementation\n * is in the AdapterProvider component.\n *\n * The adapter singleton pattern ensures that only one adapter instance exists\n * per network configuration, which is critical for consistent wallet connection\n * state across the application.\n */\nimport { createContext } from 'react';\n\nimport type { ContractAdapter, NetworkConfig } from '@openzeppelin/ui-types';\n\n/**\n * Registry type that maps network IDs to their corresponding adapter instances\n * This is the core data structure for the singleton pattern\n */\nexport interface AdapterRegistry {\n  [networkId: string]: ContractAdapter;\n}\n\n/**\n * Context value interface defining what's provided through the context\n * The main functionality is getAdapterForNetwork which either returns\n * an existing adapter or initiates loading of a new one\n */\nexport interface AdapterContextValue {\n  getAdapterForNetwork: (networkConfig: NetworkConfig | null) => {\n    adapter: ContractAdapter | null;\n    isLoading: boolean;\n  };\n}\n\n/**\n * The React Context that provides adapter registry access throughout the app\n * Components can access this through the useAdapterContext hook\n */\nexport const AdapterContext = createContext<AdapterContextValue | null>(null);\n", "/**\n * AdapterProvider.tsx\n *\n * This file implements the Adapter Provider component which manages a registry of\n * adapter instances. It's a key part of the adapter singleton pattern which ensures\n * that only one adapter instance exists per network configuration.\n *\n * The adapter registry is shared across the application via React Context, allowing\n * components to access the same adapter instances and maintain consistent wallet\n * connection state.\n *\n * IMPORTANT: This implementation needs special care to avoid React state update errors\n * during component rendering. Direct state updates during render are not allowed, which\n * is why adapter loading is controlled carefully.\n */\nimport { ReactNode, useCallback, useEffect, useMemo, useState } from 'react';\n\nimport type { ContractAdapter, NetworkConfig } from '@openzeppelin/ui-types';\nimport { logger } from '@openzeppelin/ui-utils';\n\nimport { AdapterContext, AdapterContextValue, AdapterRegistry } from './AdapterContext';\n\nexport interface AdapterProviderProps {\n  children: ReactNode;\n  /** Function to resolve/create an adapter instance for a given NetworkConfig. */\n  resolveAdapter: (networkConfig: NetworkConfig) => Promise<ContractAdapter>;\n}\n\n/**\n * Provider component that manages adapter instances centrally\n * to avoid creating multiple instances of the same adapter.\n *\n * This component:\n * 1. Maintains a registry of adapter instances by network ID\n * 2. Tracks loading states for adapters being initialized\n * 3. Provides a function to get or load adapters for specific networks\n * 4. Ensures adapter instances are reused when possible\n */\nexport function AdapterProvider({ children, resolveAdapter }: AdapterProviderProps) {\n  // Registry to store adapter instances by network ID\n  const [adapterRegistry, setAdapterRegistry] = useState<AdapterRegistry>({});\n\n  // Track loading states by network ID\n  const [loadingNetworks, setLoadingNetworks] = useState<Set<string>>(new Set());\n\n  // Log registry status on changes\n  useEffect(() => {\n    const adapterCount = Object.keys(adapterRegistry).length;\n    if (adapterCount > 0) {\n      logger.info('AdapterProvider', `Registry contains ${adapterCount} adapters:`, {\n        networkIds: Object.keys(adapterRegistry),\n        loadingCount: loadingNetworks.size,\n        loadingNetworkIds: Array.from(loadingNetworks),\n      });\n    }\n  }, [adapterRegistry, loadingNetworks]);\n\n  /**\n   * Function to get or create an adapter for a network\n   *\n   * IMPORTANT: The actual adapter loading is handled in the useConfiguredAdapterSingleton hook\n   * to avoid React state updates during render, which would cause errors.\n   *\n   * This function:\n   * 1. Returns existing adapters immediately if available\n   * 2. Reports loading state for adapters being initialized\n   * 3. Initiates adapter loading when needed\n   */\n  const getAdapterForNetwork = useCallback(\n    (networkConfig: NetworkConfig | null) => {\n      if (!networkConfig) {\n        return { adapter: null, isLoading: false };\n      }\n\n      const networkId = networkConfig.id;\n\n      // Debug log to track adapter requests\n      logger.debug('AdapterProvider', `Adapter requested for network ${networkId}`);\n\n      // If we already have this adapter, return it\n      if (adapterRegistry[networkId]) {\n        logger.debug('AdapterProvider', `Using existing adapter for network ${networkId}`);\n        return {\n          adapter: adapterRegistry[networkId],\n          isLoading: false,\n        };\n      }\n\n      // If we're already loading this adapter, indicate loading\n      if (loadingNetworks.has(networkId)) {\n        logger.debug('AdapterProvider', `Adapter for network ${networkId} is currently loading`);\n        return {\n          adapter: null,\n          isLoading: true,\n        };\n      }\n\n      // Start loading the adapter\n      // NOTE: This state update during render is handled safely in the useConfiguredAdapterSingleton hook\n      setLoadingNetworks((prev) => {\n        const newSet = new Set(prev);\n        newSet.add(networkId);\n        return newSet;\n      });\n\n      logger.info(\n        'AdapterProvider',\n        `Starting adapter initialization for network ${networkId} (${networkConfig.name})`\n      );\n\n      // Use the passed-in resolveAdapter function\n      void resolveAdapter(networkConfig)\n        .then((adapter) => {\n          logger.info('AdapterProvider', `Adapter for network ${networkId} loaded successfully`, {\n            type: adapter.constructor.name,\n            objectId: Object.prototype.toString.call(adapter),\n          });\n\n          // Update registry with new adapter\n          setAdapterRegistry((prev) => ({\n            ...prev,\n            [networkId]: adapter,\n          }));\n\n          // Remove from loading networks\n          setLoadingNetworks((prev) => {\n            const newSet = new Set(prev);\n            newSet.delete(networkId);\n            return newSet;\n          });\n        })\n        .catch((error) => {\n          logger.error('AdapterProvider', `Error loading adapter for network ${networkId}:`, error);\n\n          // Remove from loading networks on error\n          setLoadingNetworks((prev) => {\n            const newSet = new Set(prev);\n            newSet.delete(networkId);\n            return newSet;\n          });\n        });\n\n      return {\n        adapter: null,\n        isLoading: true,\n      };\n    },\n    [adapterRegistry, loadingNetworks, resolveAdapter]\n  );\n\n  // Memoize context value to prevent unnecessary re-renders\n  const contextValue = useMemo<AdapterContextValue>(\n    () => ({\n      getAdapterForNetwork,\n    }),\n    [getAdapterForNetwork]\n  );\n\n  return <AdapterContext.Provider value={contextValue}>{children}</AdapterContext.Provider>;\n}\n", "import React, { createContext } from 'react';\n\nimport type {\n  ContractAdapter,\n  EcosystemSpecificReactHooks,\n  NetworkConfig,\n  UiKitConfiguration,\n} from '@openzeppelin/ui-types';\n\nexport interface WalletStateContextValue {\n  // Globally selected network state\n  activeNetworkId: string | null;\n  setActiveNetworkId: (networkId: string | null) => void;\n  activeNetworkConfig: NetworkConfig | null;\n\n  // Active adapter state\n  activeAdapter: ContractAdapter | null;\n  isAdapterLoading: boolean;\n\n  // Facade hooks object from the active adapter\n  // Consumers will call these hooks (e.g., walletFacadeHooks.useAccount())\n  walletFacadeHooks: EcosystemSpecificReactHooks | null;\n  reconfigureActiveAdapterUiKit: (uiKitConfig?: Partial<UiKitConfiguration>) => void;\n}\n\n/**\n * Shared Global Context Pattern\n * =============================\n *\n * WHY THIS EXISTS:\n * When bundlers (like Vite's optimizeDeps with esbuild) pre-bundle dependencies,\n * they may inline transitive dependencies like @openzeppelin/ui-react into the\n * consuming package's bundle. This creates MULTIPLE instances of this module:\n *\n * 1. The app's direct import → packages/react/dist/index.js\n * 2. The adapter's inlined copy → .vite/deps/@openzeppelin_ui-builder-adapter-evm.js\n *\n * Since React contexts use referential identity, these two module instances have\n * DIFFERENT context objects. When the adapter's components call useWalletState(),\n * they look for a context that was never provided (because WalletStateProvider\n * uses the app's context, not the adapter's inlined copy).\n *\n * SOLUTION:\n * Store the context object on globalThis so ALL module instances share the same\n * React context, regardless of how they were loaded or bundled.\n *\n * WHEN IS THIS NEEDED:\n * - Development with Vite's dependency pre-bundling (optimizeDeps)\n * - When adapters are installed from npm (not workspace-linked with same bundler)\n * - Any scenario where @openzeppelin/ui-react might be duplicated\n *\n * PRODUCTION APPS:\n * In production builds where the app and adapters are bundled together with proper\n * deduplication (e.g., via bundler configuration or peer dependencies), this\n * workaround may not be strictly necessary. However, it provides a safety net\n * and has minimal overhead.\n */\n\n/**\n * Use Symbol.for() to create a globally unique key that is consistent across\n * all module instances. Unlike Symbol(), Symbol.for() returns the same symbol\n * for the same key string, which is essential for cross-module sharing.\n */\nconst WALLET_STATE_CONTEXT_KEY = Symbol.for('@openzeppelin/ui-react/WalletStateContext');\n\n/**\n * Type-safe interface for the global object extension.\n * This provides better type safety than using Record<string, unknown>.\n */\ninterface GlobalWithWalletContext {\n  [WALLET_STATE_CONTEXT_KEY]?: React.Context<WalletStateContextValue | undefined>;\n}\n\n/**\n * Retrieves or creates the shared WalletStateContext.\n *\n * NOTE ON ATOMICITY:\n * The check-then-set pattern here is not atomic, but this is acceptable because:\n * 1. JavaScript is single-threaded; module initialization is synchronous\n * 2. Even if multiple modules initialize \"simultaneously\" during parallel loading,\n *    they execute sequentially on the main thread\n * 3. The worst case (two contexts created) would only happen if the check and set\n *    were somehow interleaved, which cannot occur in JS's execution model\n * 4. For React contexts specifically, having the same context object is what matters,\n *    and this pattern guarantees that after initialization\n */\nfunction getOrCreateSharedContext(): React.Context<WalletStateContextValue | undefined> {\n  const global = globalThis as GlobalWithWalletContext;\n\n  if (!global[WALLET_STATE_CONTEXT_KEY]) {\n    global[WALLET_STATE_CONTEXT_KEY] = createContext<WalletStateContextValue | undefined>(\n      undefined\n    );\n  }\n\n  return global[WALLET_STATE_CONTEXT_KEY];\n}\n\nexport const WalletStateContext = getOrCreateSharedContext();\n\n/**\n * Hook to access wallet state from WalletStateProvider.\n * @throws Error if used outside of WalletStateProvider\n */\nexport function useWalletState(): WalletStateContextValue {\n  const context = React.useContext(WalletStateContext);\n  if (context === undefined) {\n    throw new Error('useWalletState must be used within a WalletStateProvider');\n  }\n  return context;\n}\n", "/**\n * useAdapterContext.ts\n *\n * This file provides a hook to access the AdapterContext throughout the application.\n * It's a critical part of the adapter singleton pattern, allowing components to\n * access the centralized adapter registry.\n *\n * The adapter singleton pattern ensures:\n * - Only one adapter instance exists per network\n * - Wallet connection state is consistent across the app\n * - Better performance by eliminating redundant adapter initialization\n */\nimport { useContext } from 'react';\n\nimport { AdapterContext, AdapterContextValue } from './AdapterContext';\n\n/**\n * Hook to access the adapter context\n *\n * This hook provides access to the getAdapterForNetwork function which\n * retrieves or creates adapter instances from the singleton registry.\n *\n * Components should typically use useConfiguredAdapterSingleton instead\n * of this hook directly, as it handles React state update timing properly.\n *\n * @throws Error if used outside of an AdapterProvider context\n * @returns The adapter context value\n */\nexport function useAdapterContext(): AdapterContextValue {\n  const context = useContext(AdapterContext);\n\n  if (!context) {\n    throw new Error('useAdapterContext must be used within an AdapterProvider');\n  }\n\n  return context;\n}\n", "import React, { ReactNode, useCallback, useEffect, useMemo, useState } from 'react';\n\nimport type {\n  ContractAdapter,\n  EcosystemReactUiProviderProps,\n  EcosystemSpecificReactHooks,\n  NativeConfigLoader,\n  NetworkConfig,\n  UiKitConfiguration,\n} from '@openzeppelin/ui-types';\nimport { logger } from '@openzeppelin/ui-utils';\n\nimport { useAdapterContext } from './useAdapterContext';\nimport { WalletStateContext, type WalletStateContextValue } from './WalletStateContext';\n\n// Extended adapter interface that includes the callback-based configureUiKit method\ninterface ExtendedContractAdapter extends ContractAdapter {\n  configureUiKit?(\n    config: Partial<UiKitConfiguration>,\n    options?: {\n      loadUiKitNativeConfig?: (kitName: string) => Promise<Record<string, unknown> | null>;\n    }\n  ): void | Promise<void>;\n  getEcosystemReactUiContextProvider?():\n    | React.ComponentType<EcosystemReactUiProviderProps>\n    | undefined;\n}\n\nexport interface WalletStateProviderProps {\n  children: ReactNode;\n  /** Optional initial network ID to set as active when the provider mounts. */\n  initialNetworkId?: string | null;\n  /** Function to retrieve a NetworkConfig object by its ID. */\n  getNetworkConfigById: (\n    networkId: string\n  ) => Promise<NetworkConfig | null | undefined> | NetworkConfig | null | undefined;\n  /**\n   * Optional generic function to load configuration modules by relative path.\n   * The adapter is responsible for constructing the conventional path (e.g., './config/wallet/[kitName].config').\n   * @param relativePath The conventional relative path to the configuration module.\n   * @returns A Promise resolving to the configuration object (expected to have a default export) or null.\n   */\n  loadConfigModule?: NativeConfigLoader;\n}\n\n/**\n * Configures the adapter's UI kit and returns the UI provider component and hooks.\n */\nasync function configureAdapterUiKit(\n  adapter: ExtendedContractAdapter,\n  loadConfigModule?: (relativePath: string) => Promise<Record<string, unknown> | null>,\n  programmaticOverrides: Partial<UiKitConfiguration> = {}\n): Promise<{\n  providerComponent: React.ComponentType<EcosystemReactUiProviderProps> | null;\n  hooks: EcosystemSpecificReactHooks | null;\n}> {\n  try {\n    // Ensure the adapter (and thus the EvmUiKitManager) is configured.\n    if (typeof adapter.configureUiKit === 'function') {\n      logger.info(\n        '[WSP configureAdapterUiKit] Calling configureUiKit for adapter:',\n        adapter?.networkConfig?.id\n      );\n      await adapter.configureUiKit(programmaticOverrides, {\n        loadUiKitNativeConfig: loadConfigModule,\n      });\n      logger.info(\n        '[WSP configureAdapterUiKit] configureUiKit completed for adapter:',\n        adapter?.networkConfig?.id\n      );\n    }\n\n    const providerComponent = adapter.getEcosystemReactUiContextProvider?.() || null;\n    const hooks = adapter.getEcosystemReactHooks?.() || null;\n\n    logger.info('[WSP configureAdapterUiKit]', 'UI provider and hooks retrieved successfully.');\n\n    return { providerComponent, hooks };\n  } catch (error) {\n    logger.error('[WSP configureAdapterUiKit]', 'Error during adapter UI setup:', error);\n    throw error; // Re-throw to be handled by caller\n  }\n}\n\n/**\n * @name WalletStateProvider\n * @description This provider is a central piece of the application's state management for wallet and network interactions.\n * It is responsible for:\n * 1. Managing the globally selected active network ID (`activeNetworkId`).\n * 2. Deriving the full `NetworkConfig` object (`activeNetworkConfig`) for the active network.\n * 3. Fetching and providing the corresponding `ContractAdapter` instance (`activeAdapter`) for the active network,\n *    leveraging the `AdapterProvider` to ensure adapter singletons.\n * 4. Storing and providing the `EcosystemSpecificReactHooks` (`walletFacadeHooks`) from the active adapter.\n * 5. Rendering the adapter-specific UI context provider (e.g., WagmiProvider for EVM) around its children,\n *    which is essential for the facade hooks to function correctly.\n * 6. Providing a function (`setActiveNetworkId`) to change the globally active network.\n *\n * Consumers use the `useWalletState()` hook to access this global state.\n * It should be placed high in the component tree, inside an `<AdapterProvider>`.\n */\nexport function WalletStateProvider({\n  children,\n  initialNetworkId = null,\n  getNetworkConfigById,\n  loadConfigModule,\n}: WalletStateProviderProps) {\n  // State for the ID of the globally selected network.\n  const [currentGlobalNetworkId, setCurrentGlobalNetworkIdState] = useState<string | null>(\n    initialNetworkId\n  );\n  // State for the full NetworkConfig object of the globally selected network.\n  const [currentGlobalNetworkConfig, setCurrentGlobalNetworkConfig] =\n    useState<NetworkConfig | null>(null);\n\n  // State for the active ContractAdapter instance corresponding to the currentGlobalNetworkConfig.\n  const [globalActiveAdapter, setGlobalActiveAdapter] = useState<ContractAdapter | null>(null);\n  // Loading state for the globalActiveAdapter.\n  const [isGlobalAdapterLoading, setIsGlobalAdapterLoading] = useState<boolean>(false);\n  // State for the facade hooks provided by the globalActiveAdapter.\n  const [walletFacadeHooks, setWalletFacadeHooks] = useState<EcosystemSpecificReactHooks | null>(\n    null\n  );\n  // State to hold the Component Type\n  const [AdapterUiContextProviderToRender, setAdapterUiContextProviderToRender] =\n    useState<React.ComponentType<EcosystemReactUiProviderProps> | null>(null);\n\n  // New state to act as a manual trigger for re-configuring the UI kit.\n  const [uiKitConfigVersion, setUiKitConfigVersion] = useState(0);\n  // State to hold programmatic overrides for the next reconfiguration.\n  const [programmaticUiKitConfig, setProgrammaticUiKitConfig] = useState<\n    Partial<UiKitConfiguration> | undefined\n  >(undefined);\n\n  // Consume AdapterContext to get the function for fetching adapter instances.\n  const { getAdapterForNetwork } = useAdapterContext();\n\n  // Effect to derive the full NetworkConfig object when currentGlobalNetworkId changes.\n  useEffect(() => {\n    const abortController = new AbortController();\n\n    async function fetchNetworkConfig() {\n      if (!currentGlobalNetworkId) {\n        // If currentGlobalNetworkId is null, clear the config.\n        if (!abortController.signal.aborted) {\n          setCurrentGlobalNetworkConfig(null);\n        }\n        return;\n      }\n\n      try {\n        const config = await Promise.resolve(getNetworkConfigById(currentGlobalNetworkId));\n        if (!abortController.signal.aborted) {\n          setCurrentGlobalNetworkConfig(config || null);\n        }\n      } catch (error) {\n        if (!abortController.signal.aborted) {\n          logger.error('[WSP fetchNetworkConfig]', 'Failed to fetch network config:', error);\n          setCurrentGlobalNetworkConfig(null);\n        }\n      }\n    }\n\n    void fetchNetworkConfig();\n    return () => abortController.abort();\n  }, [currentGlobalNetworkId, getNetworkConfigById]);\n\n  // Effect to load the active adapter and its UI capabilities when currentGlobalNetworkConfig changes.\n  useEffect(() => {\n    const abortController = new AbortController();\n\n    async function loadAdapterAndConfigureUi() {\n      if (!currentGlobalNetworkConfig) {\n        // No network config - clear everything\n        if (!abortController.signal.aborted) {\n          setGlobalActiveAdapter(null);\n          setIsGlobalAdapterLoading(false);\n          setAdapterUiContextProviderToRender(null);\n          setWalletFacadeHooks(null);\n        }\n        return;\n      }\n\n      const { adapter: newAdapter, isLoading: newIsLoading } = getAdapterForNetwork(\n        currentGlobalNetworkConfig\n      ) as { adapter: ExtendedContractAdapter | null; isLoading: boolean };\n\n      if (abortController.signal.aborted) return;\n\n      // Update loading state immediately, but defer exposing the new adapter\n      // until its UI provider and hooks are configured to avoid mismatch renders.\n      setIsGlobalAdapterLoading(newIsLoading);\n\n      if (newAdapter && !newIsLoading) {\n        try {\n          const { providerComponent, hooks } = await configureAdapterUiKit(\n            newAdapter,\n            loadConfigModule,\n            programmaticUiKitConfig\n          );\n\n          if (!abortController.signal.aborted) {\n            // Ensure provider component and hooks are ready before exposing the new adapter\n            // to consumers. This prevents rendering ecosystem-specific components under the\n            // previous ecosystem provider (e.g., Stellar components under EVM provider).\n            setAdapterUiContextProviderToRender(() => providerComponent);\n            setWalletFacadeHooks(hooks);\n            setGlobalActiveAdapter(newAdapter);\n          }\n        } catch (error) {\n          if (!abortController.signal.aborted) {\n            logger.error(\n              '[WSP loadAdapterAndConfigureUi]',\n              'Error during adapter UI setup:',\n              error\n            );\n            setAdapterUiContextProviderToRender(null);\n            setWalletFacadeHooks(null);\n          }\n        }\n      } else if (!newAdapter && !newIsLoading) {\n        // Adapter is null and not loading, clear UI specific state\n        if (!abortController.signal.aborted) {\n          setAdapterUiContextProviderToRender(null);\n          setWalletFacadeHooks(null);\n          setGlobalActiveAdapter(null);\n        }\n      }\n      // If newIsLoading is true, retain previous AdapterUiContextProviderToRender and hooks\n      // to prevent UI flicker, EvmWalletUiRoot will handle its loading state internally.\n    }\n\n    void loadAdapterAndConfigureUi();\n    return () => abortController.abort();\n  }, [\n    currentGlobalNetworkConfig,\n    getAdapterForNetwork,\n    loadConfigModule,\n    uiKitConfigVersion,\n    programmaticUiKitConfig,\n  ]);\n\n  /**\n   * Callback to set the globally active network ID.\n   * Also clears dependent states (config, adapter, hooks) if the network ID is cleared.\n   */\n  const setActiveNetworkIdCallback = useCallback((networkId: string | null) => {\n    logger.info('WalletStateProvider', `Setting global network ID to: ${networkId}`);\n    setCurrentGlobalNetworkIdState(networkId); // This will trigger the fetchNetworkConfig effect.\n    if (!networkId) {\n      // If clearing the network, proactively clear downstream states.\n      // The effects above will also clear them, but this is more immediate.\n      setCurrentGlobalNetworkConfig(null);\n      setGlobalActiveAdapter(null);\n      setIsGlobalAdapterLoading(false);\n      setWalletFacadeHooks(null);\n      // Do not clear AdapterUiContextProviderToRender here, let the effect handle it\n      // based on whether it's a loading transition or an actual clearing.\n      // setAdapterUiContextProviderToRender(() => null);\n    }\n  }, []); // Empty dependency array as it only uses setters from useState.\n\n  /**\n   * Callback to explicitly trigger a re-configuration of the active adapter's UI kit.\n   * This is useful when a UI kit setting changes (e.g., via a wizard) without a network change.\n   */\n  const reconfigureActiveAdapterUiKit = useCallback(\n    (uiKitConfig?: Partial<UiKitConfiguration>) => {\n      logger.info(\n        'WalletStateProvider',\n        'Explicitly triggering UI kit re-configuration by bumping version.',\n        uiKitConfig\n      );\n      setProgrammaticUiKitConfig(uiKitConfig);\n      setUiKitConfigVersion((v) => v + 1);\n    },\n    [setProgrammaticUiKitConfig, setUiKitConfigVersion]\n  );\n\n  // The context value now only provides the raw walletFacadeHooks object.\n  // Consumers are responsible for calling specific hooks from it and handling their results.\n  const contextValue = useMemo<WalletStateContextValue>(\n    () => ({\n      activeNetworkId: currentGlobalNetworkId,\n      setActiveNetworkId: setActiveNetworkIdCallback,\n      activeNetworkConfig: currentGlobalNetworkConfig,\n      activeAdapter: globalActiveAdapter,\n      isAdapterLoading: isGlobalAdapterLoading,\n      walletFacadeHooks,\n      reconfigureActiveAdapterUiKit,\n    }),\n    [\n      currentGlobalNetworkId,\n      setActiveNetworkIdCallback,\n      currentGlobalNetworkConfig,\n      globalActiveAdapter,\n      isGlobalAdapterLoading,\n      walletFacadeHooks,\n      reconfigureActiveAdapterUiKit,\n    ]\n  );\n\n  const ActualProviderToRender = AdapterUiContextProviderToRender;\n  let childrenToRender: ReactNode;\n\n  if (ActualProviderToRender) {\n    // Generate a unique key based on adapter's network ecosystem and ID\n    // This ensures proper unmounting/mounting when switching between EVM/Stellar/etc.\n    const key = `${globalActiveAdapter?.networkConfig?.ecosystem || 'unknown'}-${globalActiveAdapter?.networkConfig?.id || 'unknown'}`;\n\n    // EvmWalletUiRoot (and similar for other adapters) no longer needs uiKitConfiguration prop\n    // as it manages its own configuration internally via the EvmUiKitManager or equivalent.\n    logger.info(\n      '[WSP RENDER]',\n      'Rendering adapter-provided UI context provider:',\n      ActualProviderToRender.displayName || ActualProviderToRender.name || 'UnknownComponent',\n      'with key:',\n      key\n    );\n    childrenToRender = <ActualProviderToRender key={key}>{children}</ActualProviderToRender>;\n  } else {\n    logger.info(\n      '[WSP RENDER]',\n      'No adapter UI context provider to render. Rendering direct children.'\n    );\n    childrenToRender = children;\n  }\n\n  return (\n    <WalletStateContext.Provider value={contextValue}>\n      {childrenToRender}\n    </WalletStateContext.Provider>\n  );\n}\n", "import { createContext, useContext } from 'react';\n\n/**\n * Analytics context value interface.\n * Provides access to analytics functionality throughout the React component tree.\n */\nexport interface AnalyticsContextValue {\n  /** Google Analytics tag ID */\n  tagId?: string;\n  /**\n   * Check if analytics is enabled via feature flag.\n   * Returns fresh state on each call to handle dynamic feature flag changes.\n   */\n  isEnabled: () => boolean;\n  /** Initialize analytics with optional tag ID override */\n  initialize: (tagIdOverride?: string) => void;\n  /**\n   * Track a generic event with custom parameters.\n   * Use this for app-specific events.\n   *\n   * @example\n   * ```typescript\n   * trackEvent('button_clicked', { button_name: 'submit' });\n   * ```\n   */\n  trackEvent: (eventName: string, parameters: Record<string, string | number>) => void;\n  /**\n   * Track page view event.\n   *\n   * @example\n   * ```typescript\n   * trackPageView('Dashboard', '/dashboard');\n   * ```\n   */\n  trackPageView: (pageName: string, pagePath: string) => void;\n  /**\n   * Track network selection event.\n   *\n   * @example\n   * ```typescript\n   * trackNetworkSelection('ethereum-mainnet', 'evm');\n   * ```\n   */\n  trackNetworkSelection: (networkId: string, ecosystem: string) => void;\n}\n\n/**\n * Analytics context for providing analytics functionality to React components.\n * Must be used within an AnalyticsProvider.\n */\nexport const AnalyticsContext = createContext<AnalyticsContextValue | null>(null);\n\n/**\n * Internal hook to access analytics context.\n * Throws an error if used outside of an AnalyticsProvider.\n *\n * @internal\n * @throws Error if used outside of AnalyticsProvider\n */\nexport const useAnalyticsContext = (): AnalyticsContextValue => {\n  const context = useContext(AnalyticsContext);\n  if (!context) {\n    throw new Error('useAnalyticsContext must be used within an AnalyticsProvider');\n  }\n  return context;\n};\n", "import React, { ReactNode, useEffect, useMemo } from 'react';\n\nimport { AnalyticsService, logger } from '@openzeppelin/ui-utils';\n\nimport { AnalyticsContext, AnalyticsContextValue } from './AnalyticsContext';\n\n/**\n * Props for the AnalyticsProvider component\n */\nexport interface AnalyticsProviderProps {\n  /** Google Analytics tag ID (e.g., 'G-XXXXXXXXXX') */\n  tagId?: string;\n  /** Whether to automatically initialize analytics on mount (default: true) */\n  autoInit?: boolean;\n  /** Child components */\n  children: ReactNode;\n}\n\n/**\n * Analytics Provider component.\n * Provides analytics functionality throughout the React component tree.\n *\n * @example\n * ```tsx\n * function App() {\n *   return (\n *     <AnalyticsProvider tagId={import.meta.env.VITE_GA_TAG_ID} autoInit={true}>\n *       <YourApp />\n *     </AnalyticsProvider>\n *   );\n * }\n * ```\n */\nexport const AnalyticsProvider: React.FC<AnalyticsProviderProps> = ({\n  tagId,\n  autoInit = true,\n  children,\n}) => {\n  useEffect(() => {\n    if (autoInit && tagId) {\n      AnalyticsService.initialize(tagId);\n    }\n  }, [tagId, autoInit]);\n\n  const contextValue: AnalyticsContextValue = useMemo(\n    () => ({\n      tagId,\n      isEnabled: () => AnalyticsService.isEnabled(),\n      initialize: (tagIdOverride?: string) => {\n        const effectiveTagId = tagIdOverride || tagId;\n        if (effectiveTagId) {\n          AnalyticsService.initialize(effectiveTagId);\n        }\n      },\n      trackEvent: (eventName: string, parameters: Record<string, string | number>) => {\n        try {\n          AnalyticsService.trackEvent(eventName, parameters);\n        } catch (error) {\n          logger.error('AnalyticsProvider', 'Error tracking event:', error);\n        }\n      },\n      trackPageView: (pageName: string, pagePath: string) => {\n        try {\n          AnalyticsService.trackPageView(pageName, pagePath);\n        } catch (error) {\n          logger.error('AnalyticsProvider', 'Error tracking page view:', error);\n        }\n      },\n      trackNetworkSelection: (networkId: string, ecosystem: string) => {\n        try {\n          AnalyticsService.trackNetworkSelection(networkId, ecosystem);\n        } catch (error) {\n          logger.error('AnalyticsProvider', 'Error tracking network selection:', error);\n        }\n      },\n    }),\n    [tagId]\n  );\n\n  return <AnalyticsContext.Provider value={contextValue}>{children}</AnalyticsContext.Provider>;\n};\n", "import { useAnalyticsContext } from './AnalyticsContext';\n\n/**\n * Custom hook for accessing analytics functionality.\n *\n * This hook provides a convenient interface for tracking user interactions\n * throughout the application. It must be used within an AnalyticsProvider.\n *\n * For app-specific tracking methods, create a wrapper hook that uses this\n * hook and adds your custom tracking functions.\n *\n * @example\n * ```tsx\n * // Basic usage\n * function MyComponent() {\n *   const { trackEvent, trackPageView, isEnabled } = useAnalytics();\n *\n *   const handleClick = () => {\n *     trackEvent('button_clicked', { button_name: 'submit' });\n *   };\n *\n *   return (\n *     <div>\n *       Analytics enabled: {isEnabled().toString()}\n *       <button onClick={handleClick}>Submit</button>\n *     </div>\n *   );\n * }\n * ```\n *\n * @example\n * ```tsx\n * // Creating app-specific wrapper hook\n * function useMyAppAnalytics() {\n *   const analytics = useAnalytics();\n *\n *   return {\n *     ...analytics,\n *     trackFormSubmit: (formName: string) => {\n *       analytics.trackEvent('form_submitted', { form_name: formName });\n *     },\n *   };\n * }\n * ```\n *\n * @returns Analytics context with tracking methods and state\n * @throws Error if used outside of AnalyticsProvider\n */\nexport const useAnalytics = () => {\n  try {\n    return useAnalyticsContext();\n  } catch {\n    throw new Error('useAnalytics must be used within an AnalyticsProvider');\n  }\n};\n", "import type { EcosystemWalletComponents } from '@openzeppelin/ui-types';\n\nimport { useWalletState } from './WalletStateContext';\n\n/**\n * Hook that provides direct access to wallet UI components from the active adapter.\n *\n * Use this hook when you need full control over the layout and composition of\n * wallet components. For standard layouts, prefer using `WalletConnectionUI`\n * with its props forwarding capabilities.\n *\n * @returns The wallet components object, or null if no adapter is active or\n *          the adapter doesn't provide wallet components.\n *\n * @example\n * ```tsx\n * import { useWalletComponents } from '@openzeppelin/ui-react';\n *\n * function CustomWalletSection() {\n *   const walletComponents = useWalletComponents();\n *\n *   if (!walletComponents) {\n *     return <p>Loading wallet...</p>;\n *   }\n *\n *   const { ConnectButton, NetworkSwitcher, AccountDisplay } = walletComponents;\n *\n *   return (\n *     <div className=\"flex flex-col gap-4\">\n *       {ConnectButton && (\n *         <ConnectButton\n *           size=\"xl\"\n *           variant=\"outline\"\n *           fullWidth\n *           className=\"font-semibold\"\n *         />\n *       )}\n *       <div className=\"flex gap-2\">\n *         {NetworkSwitcher && <NetworkSwitcher size=\"sm\" />}\n *         {AccountDisplay && <AccountDisplay size=\"sm\" />}\n *       </div>\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useWalletComponents(): EcosystemWalletComponents | null {\n  const { activeAdapter } = useWalletState();\n\n  if (!activeAdapter || typeof activeAdapter.getEcosystemWalletComponents !== 'function') {\n    return null;\n  }\n\n  try {\n    return activeAdapter.getEcosystemWalletComponents() ?? null;\n  } catch {\n    return null;\n  }\n}\n", "// Assumes WalletStateContext exports useWalletState\nimport { isRecordWithProperties } from '@openzeppelin/ui-utils';\n\nimport { useWalletState } from './WalletStateContext';\n\nexport interface DerivedAccountStatus {\n  isConnected: boolean;\n  address?: string;\n  chainId?: number;\n  // Potentially add other commonly used and safely extracted properties from useAccount's result\n}\n\nconst defaultAccountStatus: DerivedAccountStatus = {\n  isConnected: false,\n  address: undefined,\n  chainId: undefined,\n};\n\n/**\n * A custom hook that consumes useWalletState to get the walletFacadeHooks,\n * then calls the useAccount facade hook (if available) and returns a structured,\n * safely-accessed account status (isConnected, address, chainId).\n * Provides default values if the hook or its properties are unavailable.\n */\nexport function useDerivedAccountStatus(): DerivedAccountStatus {\n  const { walletFacadeHooks } = useWalletState();\n\n  // Call the useAccount hook from the facade\n  const accountHookOutput = walletFacadeHooks?.useAccount\n    ? walletFacadeHooks.useAccount()\n    : undefined;\n\n  if (isRecordWithProperties(accountHookOutput)) {\n    const isConnected =\n      'isConnected' in accountHookOutput && typeof accountHookOutput.isConnected === 'boolean'\n        ? accountHookOutput.isConnected\n        : defaultAccountStatus.isConnected;\n    const address =\n      'address' in accountHookOutput && typeof accountHookOutput.address === 'string'\n        ? accountHookOutput.address\n        : defaultAccountStatus.address;\n    const chainId =\n      'chainId' in accountHookOutput && typeof accountHookOutput.chainId === 'number'\n        ? accountHookOutput.chainId\n        : defaultAccountStatus.chainId;\n    return { isConnected, address, chainId };\n  }\n  return defaultAccountStatus;\n}\n", "import { isRecordWithProperties } from '@openzeppelin/ui-utils';\n\nimport { useWalletState } from './WalletStateContext';\n\n// Define the expected return shape for the derived hook\nexport interface DerivedSwitchChainStatus {\n  /** Function to initiate a network switch. Undefined if not available. */\n  switchChain?: (args: { chainId: number }) => void;\n  /** True if a network switch is currently in progress. */\n  isSwitching: boolean;\n  /** Error object if the last switch attempt failed, otherwise null. */\n  error: Error | null;\n}\n\nconst defaultSwitchChainStatus: DerivedSwitchChainStatus = {\n  switchChain: undefined,\n  isSwitching: false,\n  error: null,\n};\n\n/**\n * A custom hook that consumes `useWalletState` to get `walletFacadeHooks`,\n * then calls the `useSwitchChain` facade hook (if available) and returns a structured,\n * safely-accessed status and control function for network switching.\n * Provides default values if the hook or its properties are unavailable.\n */\nexport function useDerivedSwitchChainStatus(): DerivedSwitchChainStatus {\n  const { walletFacadeHooks } = useWalletState();\n\n  const switchChainHookOutput = walletFacadeHooks?.useSwitchChain\n    ? walletFacadeHooks.useSwitchChain()\n    : undefined;\n\n  if (isRecordWithProperties(switchChainHookOutput)) {\n    const execSwitchFn =\n      'switchChain' in switchChainHookOutput &&\n      typeof switchChainHookOutput.switchChain === 'function'\n        ? (switchChainHookOutput.switchChain as (args: { chainId: number }) => void)\n        : defaultSwitchChainStatus.switchChain;\n\n    const isPending =\n      'isPending' in switchChainHookOutput && typeof switchChainHookOutput.isPending === 'boolean'\n        ? switchChainHookOutput.isPending\n        : defaultSwitchChainStatus.isSwitching;\n\n    const err =\n      'error' in switchChainHookOutput && switchChainHookOutput.error instanceof Error\n        ? switchChainHookOutput.error\n        : defaultSwitchChainStatus.error;\n\n    return { switchChain: execSwitchFn, isSwitching: isPending, error: err };\n  }\n\n  return defaultSwitchChainStatus;\n}\n", "import { logger } from '@openzeppelin/ui-utils';\n\nimport { useWalletState } from './WalletStateContext';\n\nexport interface DerivedChainInfo {\n  /** The current chain ID reported by the wallet's active connection, if available. */\n  currentChainId?: number;\n  /** Array of chains configured in the underlying wallet library (e.g., wagmi). Type is any[] for generic compatibility. */\n  availableChains: unknown[];\n}\n\nconst defaultChainInfo: DerivedChainInfo = {\n  currentChainId: undefined,\n  availableChains: [],\n};\n\n/**\n * A custom hook that consumes `useWalletState` to get `walletFacadeHooks`,\n * then calls the `useChainId` and `useChains` facade hooks (if available)\n * and returns a structured object with this information.\n * Provides default values if the hooks or their properties are unavailable.\n */\nexport function useDerivedChainInfo(): DerivedChainInfo {\n  const { walletFacadeHooks } = useWalletState();\n\n  let chainIdToReturn: number | undefined = defaultChainInfo.currentChainId;\n  const chainIdHookOutput = walletFacadeHooks?.useChainId\n    ? walletFacadeHooks.useChainId()\n    : undefined;\n  // The useChainId hook from wagmi directly returns the number or undefined\n  if (typeof chainIdHookOutput === 'number') {\n    chainIdToReturn = chainIdHookOutput;\n  } else if (chainIdHookOutput !== undefined) {\n    // If it's not a number but not undefined, log a warning but use default. Could be an adapter returning unexpected type.\n    logger.warn(\n      'useDerivedChainInfo',\n      'useChainId facade hook returned non-numeric value:',\n      chainIdHookOutput\n    );\n  }\n\n  let chainsToReturn: unknown[] = defaultChainInfo.availableChains;\n  const chainsHookOutput = walletFacadeHooks?.useChains ? walletFacadeHooks.useChains() : undefined;\n  // The useChains hook from wagmi directly returns an array of Chain objects\n  if (Array.isArray(chainsHookOutput)) {\n    chainsToReturn = chainsHookOutput;\n  } else if (chainsHookOutput !== undefined) {\n    logger.warn(\n      'useDerivedChainInfo',\n      'useChains facade hook returned non-array value:',\n      chainsHookOutput\n    );\n  }\n\n  return { currentChainId: chainIdToReturn, availableChains: chainsToReturn };\n}\n", "import type { Connector } from '@openzeppelin/ui-types';\nimport { isRecordWithProperties } from '@openzeppelin/ui-utils';\n\nimport { useWalletState } from './WalletStateContext';\n\n// Assuming Connector type is available\n\nexport interface DerivedConnectStatus {\n  /** Function to initiate a connection, usually takes a connector. Undefined if not available. */\n  connect?: (args?: { connector?: Connector /* or string for id */ }) => void;\n  /** Array of available connectors. Type is any[] for broad compatibility until Connector type is fully generic here. */\n  connectors: Connector[]; // Or any[] if Connector type from types pkg is too specific for generic hook here\n  /** True if a connection attempt is in progress. */\n  isConnecting: boolean;\n  /** Error object if the last connection attempt failed, otherwise null. */\n  error: Error | null;\n  /** The connector a connection is pending for, if any. */\n  pendingConnector?: Connector; // Or any\n}\n\nconst defaultConnectStatus: DerivedConnectStatus = {\n  connect: undefined,\n  connectors: [],\n  isConnecting: false,\n  error: null,\n  pendingConnector: undefined,\n};\n\n/**\n * A custom hook that consumes `useWalletState` to get `walletFacadeHooks`,\n * then calls the `useConnect` facade hook (if available) and returns a structured,\n * safely-accessed status and control functions for wallet connection.\n */\nexport function useDerivedConnectStatus(): DerivedConnectStatus {\n  const { walletFacadeHooks } = useWalletState();\n\n  const connectHookOutput = walletFacadeHooks?.useConnect\n    ? walletFacadeHooks.useConnect()\n    : undefined;\n\n  if (isRecordWithProperties(connectHookOutput)) {\n    const connectFn =\n      'connect' in connectHookOutput && typeof connectHookOutput.connect === 'function'\n        ? (connectHookOutput.connect as (args?: { connector?: Connector }) => void)\n        : defaultConnectStatus.connect;\n\n    const conns =\n      'connectors' in connectHookOutput && Array.isArray(connectHookOutput.connectors)\n        ? (connectHookOutput.connectors as Connector[])\n        : defaultConnectStatus.connectors;\n\n    const isPending =\n      'isPending' in connectHookOutput && typeof connectHookOutput.isPending === 'boolean'\n        ? connectHookOutput.isPending\n        : 'isLoading' in connectHookOutput && typeof connectHookOutput.isLoading === 'boolean'\n          ? connectHookOutput.isLoading\n          : defaultConnectStatus.isConnecting;\n\n    const err =\n      'error' in connectHookOutput && connectHookOutput.error instanceof Error\n        ? connectHookOutput.error\n        : defaultConnectStatus.error;\n\n    const pendingConn =\n      'pendingConnector' in connectHookOutput &&\n      typeof connectHookOutput.pendingConnector === 'object' // Assuming Connector is an object\n        ? (connectHookOutput.pendingConnector as Connector)\n        : defaultConnectStatus.pendingConnector;\n\n    return {\n      connect: connectFn,\n      connectors: conns,\n      isConnecting: isPending,\n      error: err,\n      pendingConnector: pendingConn,\n    };\n  }\n\n  return defaultConnectStatus;\n}\n", "import { isRecordWithProperties } from '@openzeppelin/ui-utils';\n\nimport { useWalletState } from './WalletStateContext';\n\nexport interface DerivedDisconnectStatus {\n  /** Function to initiate disconnection. Undefined if not available. */\n  disconnect?: () => void | Promise<void>; // Can be sync or async\n  /** True if a disconnection attempt is in progress (if hook provides this). */\n  isDisconnecting: boolean;\n  /** Error object if the last disconnection attempt failed (if hook provides this). */\n  error: Error | null;\n}\n\nconst defaultDisconnectStatus: DerivedDisconnectStatus = {\n  disconnect: undefined,\n  isDisconnecting: false,\n  error: null,\n};\n\n/**\n * A custom hook that consumes `useWalletState` to get `walletFacadeHooks`,\n * then calls the `useDisconnect` facade hook (if available) and returns a structured,\n * safely-accessed status and control function for wallet disconnection.\n */\nexport function useDerivedDisconnect(): DerivedDisconnectStatus {\n  const { walletFacadeHooks } = useWalletState();\n\n  const disconnectHookOutput = walletFacadeHooks?.useDisconnect\n    ? walletFacadeHooks.useDisconnect()\n    : undefined;\n\n  if (isRecordWithProperties(disconnectHookOutput)) {\n    const disconnectFn =\n      'disconnect' in disconnectHookOutput && typeof disconnectHookOutput.disconnect === 'function'\n        ? (disconnectHookOutput.disconnect as () => void | Promise<void>)\n        : defaultDisconnectStatus.disconnect;\n\n    // wagmi's useDisconnect doesn't have isPending/isLoading directly, but has error and variables (which is the connector it disconnected)\n    // We will assume a simple isDisconnecting is not provided by current wagmi facade, but include for future flexibility\n    const isPending =\n      'isPending' in disconnectHookOutput && typeof disconnectHookOutput.isPending === 'boolean'\n        ? disconnectHookOutput.isPending\n        : 'isLoading' in disconnectHookOutput && typeof disconnectHookOutput.isLoading === 'boolean'\n          ? disconnectHookOutput.isLoading\n          : defaultDisconnectStatus.isDisconnecting;\n\n    const err =\n      'error' in disconnectHookOutput && disconnectHookOutput.error instanceof Error\n        ? disconnectHookOutput.error\n        : defaultDisconnectStatus.error;\n\n    return { disconnect: disconnectFn, isDisconnecting: isPending, error: err };\n  }\n\n  return defaultDisconnectStatus;\n}\n", "import { useEffect, useRef } from 'react';\n\nimport type { ContractAdapter } from '@openzeppelin/ui-types';\nimport { logger } from '@openzeppelin/ui-utils';\n\nimport { useDerivedAccountStatus } from './useDerivedAccountStatus';\n\n/**\n * Hook that detects wallet reconnection and re-queues network switch if needed.\n *\n * When a user disconnects their wallet and then reconnects in the same session,\n * the wallet may connect to a different chain than what's selected in the app.\n * This hook detects that scenario and invokes a callback to re-queue the network switch.\n *\n * @param selectedNetworkConfigId - Currently selected network in the app\n * @param selectedAdapter - Currently active adapter instance\n * @param networkToSwitchTo - Current network switch queue state (null if no switch pending)\n * @param onRequeueSwitch - Callback invoked when a network switch should be re-queued\n */\nexport function useWalletReconnectionHandler(\n  selectedNetworkConfigId: string | null,\n  selectedAdapter: ContractAdapter | null,\n  networkToSwitchTo: string | null,\n  onRequeueSwitch: (networkId: string) => void\n): void {\n  const { isConnected, chainId: walletChainId } = useDerivedAccountStatus();\n  const prevConnectedRef = useRef(isConnected);\n\n  useEffect(() => {\n    const wasDisconnected = !prevConnectedRef.current;\n    const isNowConnected = isConnected;\n    const isReconnection = wasDisconnected && isNowConnected;\n\n    // Update ref for next render\n    prevConnectedRef.current = isConnected;\n\n    if (!isReconnection || !selectedNetworkConfigId || !selectedAdapter) {\n      return;\n    }\n\n    // Skip if already queued\n    if (networkToSwitchTo === selectedNetworkConfigId) {\n      return;\n    }\n\n    // Check if adapter config has chainId (only EVM chains support network switching)\n    const adapterConfig = selectedAdapter.networkConfig;\n    if (!('chainId' in adapterConfig) || !walletChainId) {\n      return;\n    }\n\n    const targetChainId = Number(adapterConfig.chainId);\n    if (walletChainId !== targetChainId) {\n      logger.info(\n        'useWalletReconnectionHandler',\n        `Wallet reconnected with chain ${walletChainId}, but selected network requires ${targetChainId}. Re-queueing switch.`\n      );\n      onRequeueSwitch(selectedNetworkConfigId);\n    }\n  }, [\n    isConnected,\n    walletChainId,\n    selectedNetworkConfigId,\n    selectedAdapter,\n    networkToSwitchTo,\n    onRequeueSwitch,\n  ]);\n}\n", "import React, { useEffect, useState } from 'react';\n\nimport { Button } from '@openzeppelin/ui-components';\nimport type { BaseComponentProps } from '@openzeppelin/ui-types';\nimport { cn, logger } from '@openzeppelin/ui-utils';\n\nimport { useWalletState } from '../hooks/WalletStateContext';\n\n/**\n * Props for the WalletConnectionUI component.\n */\nexport interface WalletConnectionUIProps {\n  /** Additional CSS classes to apply to the wrapper container */\n  className?: string;\n  /** Props forwarded to the ConnectButton component */\n  connectButtonProps?: BaseComponentProps;\n  /** Props forwarded to the AccountDisplay component */\n  accountDisplayProps?: BaseComponentProps;\n  /** Props forwarded to the NetworkSwitcher component */\n  networkSwitcherProps?: BaseComponentProps;\n}\n\n/**\n * Component that displays wallet connection UI components\n * provided by the active adapter.\n *\n * @example\n * ```tsx\n * // Basic usage\n * <WalletConnectionUI />\n *\n * // With custom styling for the connect button\n * <WalletConnectionUI\n *   connectButtonProps={{ size: \"lg\", variant: \"outline\", fullWidth: true }}\n * />\n *\n * // Customizing all components\n * <WalletConnectionUI\n *   connectButtonProps={{ size: \"lg\" }}\n *   accountDisplayProps={{ size: \"lg\" }}\n *   networkSwitcherProps={{ size: \"lg\" }}\n * />\n * ```\n */\nexport const WalletConnectionUI: React.FC<WalletConnectionUIProps> = ({\n  className,\n  connectButtonProps,\n  accountDisplayProps,\n  networkSwitcherProps,\n}) => {\n  const [isError, setIsError] = useState(false);\n  const { activeAdapter, walletFacadeHooks } = useWalletState();\n\n  useEffect(() => {\n    logger.debug('WalletConnectionUI', '[Debug] State from useWalletState:', {\n      adapterId: activeAdapter?.networkConfig.id,\n      hasFacadeHooks: !!walletFacadeHooks,\n    });\n  }, [activeAdapter, walletFacadeHooks]);\n\n  // Compute wallet components on each render to ensure UI kit changes are reflected immediately\n  const walletComponents = (() => {\n    if (!activeAdapter || typeof activeAdapter.getEcosystemWalletComponents !== 'function') {\n      logger.debug(\n        'WalletConnectionUI',\n        '[Debug] No activeAdapter or getEcosystemWalletComponents method, returning null.'\n      );\n      return null;\n    }\n\n    try {\n      const components = activeAdapter.getEcosystemWalletComponents();\n      logger.debug('WalletConnectionUI', '[Debug] walletComponents from adapter:', components);\n      return components;\n    } catch (error) {\n      logger.error('WalletConnectionUI', '[Debug] Error getting wallet components:', error);\n      setIsError(true);\n      return null;\n    }\n  })();\n\n  if (!walletComponents) {\n    logger.debug(\n      'WalletConnectionUI',\n      '[Debug] getEcosystemWalletComponents returned null/undefined, rendering null.'\n    );\n    return null;\n  }\n\n  // Log available components for debugging\n  logger.debug('WalletConnectionUI', 'Rendering wallet components:', {\n    hasConnectButton: !!walletComponents.ConnectButton,\n    hasAccountDisplay: !!walletComponents.AccountDisplay,\n    hasNetworkSwitcher: !!walletComponents.NetworkSwitcher,\n  });\n\n  const { ConnectButton, AccountDisplay, NetworkSwitcher } = walletComponents;\n\n  // If there was an error, show an error button\n  if (isError) {\n    return (\n      <div className={cn('flex items-center gap-4', className)}>\n        <Button variant=\"destructive\" size=\"sm\" onClick={() => window.location.reload()}>\n          Wallet Error - Retry\n        </Button>\n      </div>\n    );\n  }\n\n  return (\n    <div className={cn('flex items-center gap-4', className)}>\n      {/* Display network switcher if available - moved before account to match typical wallet UI flow */}\n      {NetworkSwitcher && <NetworkSwitcher {...networkSwitcherProps} />}\n\n      {/* Display account info if available */}\n      {AccountDisplay && <AccountDisplay {...accountDisplayProps} />}\n\n      {/* Display connect button if available */}\n      {ConnectButton && <ConnectButton {...connectButtonProps} />}\n    </div>\n  );\n};\n", "import React, { useEffect } from 'react';\n\nimport { logger } from '@openzeppelin/ui-utils';\n\nimport { useWalletState } from '../hooks/WalletStateContext';\nimport { WalletConnectionUI } from './WalletConnectionUI';\n\n/**\n * Component that renders the wallet connection UI.\n * Uses useWalletState to get its data.\n */\nexport const WalletConnectionHeader: React.FC = () => {\n  const { isAdapterLoading, activeAdapter } = useWalletState();\n\n  useEffect(() => {\n    logger.debug('WalletConnectionHeader', '[Debug] State from useWalletState:', {\n      adapterPresent: !!activeAdapter,\n      adapterNetwork: activeAdapter?.networkConfig.id,\n      isLoading: isAdapterLoading,\n    });\n  }, [activeAdapter, isAdapterLoading]);\n\n  if (isAdapterLoading) {\n    logger.debug('WalletConnectionHeader', '[Debug] Adapter loading, showing skeleton.');\n    return <div className=\"h-9 w-28 animate-pulse rounded bg-muted\"></div>;\n  }\n\n  return <WalletConnectionUI />;\n};\n", "import React, { useEffect, useRef, useState } from 'react';\n\nimport { ContractAdapter } from '@openzeppelin/ui-types';\nimport { logger } from '@openzeppelin/ui-utils';\n\nimport { useDerivedAccountStatus } from '../hooks/useDerivedAccountStatus';\nimport { useDerivedSwitchChainStatus } from '../hooks/useDerivedSwitchChainStatus';\n\n/**\n * Props for the NetworkSwitchManager component.\n */\nexport interface NetworkSwitchManagerProps {\n  /** The adapter instance for the target network */\n  adapter: ContractAdapter;\n  /** The network ID we want to switch to */\n  targetNetworkId: string;\n  /** Callback when network switch completes (success or error) */\n  onNetworkSwitchComplete?: () => void;\n}\n\n/**\n * Component that handles wallet network switching based on the selected network.\n *\n * This component manages the lifecycle of network switching operations,\n * coordinating between the wallet's current chain state and the target network.\n * It's designed to be used in any application that needs seamless wallet network switching.\n *\n * Features:\n * - Automatically initiates network switch when mounted with a target network\n * - Handles EVM chain switching gracefully\n * - No-ops for non-EVM networks that don't support chain switching\n * - Tracks switch attempts to prevent duplicate operations\n * - Provides completion callback for parent components to handle state cleanup\n */\nexport const NetworkSwitchManager: React.FC<NetworkSwitchManagerProps> = ({\n  adapter,\n  targetNetworkId,\n  onNetworkSwitchComplete,\n}) => {\n  const isMountedRef = useRef(true);\n  const [hasAttemptedSwitch, setHasAttemptedSwitch] = useState(false);\n\n  const { isConnected, chainId: currentChainIdFromHook } = useDerivedAccountStatus();\n  const {\n    switchChain: execSwitchNetwork,\n    isSwitching: isSwitchingNetworkViaHook,\n    error: switchNetworkError,\n  } = useDerivedSwitchChainStatus();\n\n  useEffect(() => {\n    isMountedRef.current = true;\n    logger.info(\n      'NetworkSwitchManager',\n      `Mounted with target: ${targetNetworkId}, current attempt status: ${hasAttemptedSwitch}`\n    );\n    setHasAttemptedSwitch(false);\n    return () => {\n      logger.info('NetworkSwitchManager', `Unmounting, was for target: ${targetNetworkId}`);\n      isMountedRef.current = false;\n    };\n    // hasAttemptedSwitch is intentionally omitted from deps: we only want to reset when targetNetworkId changes,\n    // not when hasAttemptedSwitch itself changes (which would cause unnecessary re-renders)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [targetNetworkId]);\n\n  useEffect(() => {\n    logger.info('NetworkSwitchManager', 'State Update:', {\n      target: targetNetworkId,\n      adapterNetwork: adapter.networkConfig.id,\n      isSwitching: isSwitchingNetworkViaHook,\n      hookError: !!switchNetworkError,\n      canExec: !!execSwitchNetwork,\n      connected: isConnected,\n      walletChain: currentChainIdFromHook,\n      attempted: hasAttemptedSwitch,\n    });\n  }, [\n    adapter,\n    targetNetworkId,\n    isSwitchingNetworkViaHook,\n    switchNetworkError,\n    execSwitchNetwork,\n    isConnected,\n    currentChainIdFromHook,\n    hasAttemptedSwitch,\n  ]);\n\n  // Main Orchestration & Pre-flight Effect\n  useEffect(() => {\n    const completeOperation = (\n      logMessage?: string,\n      options: { notifyComplete?: boolean } = { notifyComplete: true }\n    ) => {\n      if (logMessage) logger.info('NetworkSwitchManager', logMessage);\n      if (options.notifyComplete && isMountedRef.current && onNetworkSwitchComplete)\n        onNetworkSwitchComplete();\n      if (isMountedRef.current) setHasAttemptedSwitch(false);\n    };\n\n    if (!execSwitchNetwork) {\n      completeOperation('No switchChain function available from hook. Operation halted.', {\n        notifyComplete: false,\n      });\n      return;\n    }\n\n    if (isSwitchingNetworkViaHook && hasAttemptedSwitch) {\n      // If hook is pending AND we initiated this attempt, let completion effect handle it.\n      logger.info(\n        'NetworkSwitchManager',\n        'Hook reports switch in progress for current attempt. Waiting...'\n      );\n      return;\n    }\n\n    // If hasAttemptedSwitch is true here, but hook is NOT pending, means it completed/errored very fast.\n    // The completion effect should pick this up.\n    if (hasAttemptedSwitch && !isSwitchingNetworkViaHook) {\n      logger.info(\n        'NetworkSwitchManager',\n        'Previous switch attempt concluded. Deferring to completion effect.'\n      );\n      return;\n    }\n\n    // If we are here, no attempt has been made for the current targetNetworkId yet, or a previous attempt on a *different* target completed.\n    // OR, the hook is not pending from a previous unrelated call.\n    // Reset attempt flag for a fresh try if it was from a different context/target.\n    // Note: setHasAttemptedSwitch(false) is in mount effect for targetNetworkId change.\n\n    // === Pre-flight checks for the current targetNetworkId ===\n    if (adapter.networkConfig.id !== targetNetworkId) {\n      completeOperation(\n        `CRITICAL: Adapter (${adapter.networkConfig.id}) vs Target (${targetNetworkId}) mismatch. Operation halted.`,\n        {\n          notifyComplete: false,\n        }\n      );\n      return;\n    }\n    if (!isConnected) {\n      completeOperation('Wallet not connected (derived status). Awaiting connection.', {\n        notifyComplete: false,\n      });\n      return;\n    }\n    if (!('chainId' in adapter.networkConfig)) {\n      completeOperation(\n        'Network does not support chain switching (non-EVM). Operation complete (no-op).'\n      );\n      return;\n    }\n    const targetChainToBeSwitchedTo = Number(adapter.networkConfig.chainId);\n    if (currentChainIdFromHook === targetChainToBeSwitchedTo) {\n      completeOperation('Already on correct chain (derived status). Operation complete.');\n      return;\n    }\n\n    const performSwitchActual = () => {\n      if (!isMountedRef.current || isSwitchingNetworkViaHook || hasAttemptedSwitch) {\n        // If hook became pending, or an attempt was already made and concluded, don't re-issue.\n        logger.info(\n          'NetworkSwitchManager',\n          `Switch attempt aborted in timeout or already handled. Conditions: isSwitching: ${isSwitchingNetworkViaHook}, hasAttempted: ${hasAttemptedSwitch}`\n        );\n        return;\n      }\n      logger.info(\n        'NetworkSwitchManager',\n        `Attempting switch to ${targetChainToBeSwitchedTo} via derived hook.`\n      );\n      setHasAttemptedSwitch(true); // Mark that this specific attempt for this target is now starting\n      execSwitchNetwork({ chainId: targetChainToBeSwitchedTo });\n    };\n\n    const timeoutId = setTimeout(performSwitchActual, 100);\n    return () => clearTimeout(timeoutId);\n  }, [\n    adapter,\n    targetNetworkId,\n    execSwitchNetwork,\n    isSwitchingNetworkViaHook,\n    onNetworkSwitchComplete,\n    isConnected,\n    currentChainIdFromHook,\n    hasAttemptedSwitch,\n  ]);\n\n  // Completion/Error Effect (handles outcomes of an initiated execSwitchNetwork call)\n  useEffect(() => {\n    if (!isMountedRef.current || !execSwitchNetwork || !hasAttemptedSwitch) return;\n\n    // Only act if the hook is NOT pending AND an attempt was made\n    if (!isSwitchingNetworkViaHook) {\n      let completionMessage = 'Switch hook operation concluded.';\n      if (switchNetworkError) {\n        logger.error('NetworkSwitchManager', 'Error from derived switch hook:', switchNetworkError);\n        completionMessage = 'Switch hook completed with error.';\n      } else {\n        logger.info('NetworkSwitchManager', 'Derived switch hook completed successfully.');\n      }\n      if (onNetworkSwitchComplete) onNetworkSwitchComplete();\n      if (isMountedRef.current) setHasAttemptedSwitch(false);\n      logger.info('NetworkSwitchManager', completionMessage);\n    }\n  }, [\n    isSwitchingNetworkViaHook,\n    switchNetworkError,\n    execSwitchNetwork,\n    hasAttemptedSwitch,\n    onNetworkSwitchComplete,\n  ]);\n\n  return null;\n};\n"],
  "mappings": "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",
  "names": ["React"]
}
