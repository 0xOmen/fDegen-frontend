import {
  Button
} from "./chunk-OYC5GUDL.js";
import {
  AnalyticsService,
  cn,
  isRecordWithProperties,
  logger
} from "./chunk-FDGI5MFT.js";
import {
  require_jsx_runtime
} from "./chunk-ANF3DDBZ.js";
import {
  require_react
} from "./chunk-SLJNHQ7L.js";
import {
  __toESM
} from "./chunk-MMN2DTB3.js";

// node_modules/@openzeppelin/ui-react/dist/index.js
var import_react = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var AdapterContext = (0, import_react.createContext)(null);
function AdapterProvider({ children, resolveAdapter }) {
  const [adapterRegistry, setAdapterRegistry] = (0, import_react.useState)({});
  const [loadingNetworks, setLoadingNetworks] = (0, import_react.useState)(/* @__PURE__ */ new Set());
  (0, import_react.useEffect)(() => {
    const adapterCount = Object.keys(adapterRegistry).length;
    if (adapterCount > 0) logger.info("AdapterProvider", `Registry contains ${adapterCount} adapters:`, {
      networkIds: Object.keys(adapterRegistry),
      loadingCount: loadingNetworks.size,
      loadingNetworkIds: Array.from(loadingNetworks)
    });
  }, [adapterRegistry, loadingNetworks]);
  const getAdapterForNetwork = (0, import_react.useCallback)((networkConfig) => {
    if (!networkConfig) return {
      adapter: null,
      isLoading: false
    };
    const networkId = networkConfig.id;
    logger.debug("AdapterProvider", `Adapter requested for network ${networkId}`);
    if (adapterRegistry[networkId]) {
      logger.debug("AdapterProvider", `Using existing adapter for network ${networkId}`);
      return {
        adapter: adapterRegistry[networkId],
        isLoading: false
      };
    }
    if (loadingNetworks.has(networkId)) {
      logger.debug("AdapterProvider", `Adapter for network ${networkId} is currently loading`);
      return {
        adapter: null,
        isLoading: true
      };
    }
    setLoadingNetworks((prev) => {
      const newSet = new Set(prev);
      newSet.add(networkId);
      return newSet;
    });
    logger.info("AdapterProvider", `Starting adapter initialization for network ${networkId} (${networkConfig.name})`);
    resolveAdapter(networkConfig).then((adapter) => {
      logger.info("AdapterProvider", `Adapter for network ${networkId} loaded successfully`, {
        type: adapter.constructor.name,
        objectId: Object.prototype.toString.call(adapter)
      });
      setAdapterRegistry((prev) => ({
        ...prev,
        [networkId]: adapter
      }));
      setLoadingNetworks((prev) => {
        const newSet = new Set(prev);
        newSet.delete(networkId);
        return newSet;
      });
    }).catch((error) => {
      logger.error("AdapterProvider", `Error loading adapter for network ${networkId}:`, error);
      setLoadingNetworks((prev) => {
        const newSet = new Set(prev);
        newSet.delete(networkId);
        return newSet;
      });
    });
    return {
      adapter: null,
      isLoading: true
    };
  }, [
    adapterRegistry,
    loadingNetworks,
    resolveAdapter
  ]);
  const contextValue = (0, import_react.useMemo)(() => ({ getAdapterForNetwork }), [getAdapterForNetwork]);
  return (0, import_jsx_runtime.jsx)(AdapterContext.Provider, {
    value: contextValue,
    children
  });
}
var WALLET_STATE_CONTEXT_KEY = /* @__PURE__ */ Symbol.for("@openzeppelin/ui-react/WalletStateContext");
function getOrCreateSharedContext() {
  const global = globalThis;
  if (!global[WALLET_STATE_CONTEXT_KEY]) global[WALLET_STATE_CONTEXT_KEY] = (0, import_react.createContext)(void 0);
  return global[WALLET_STATE_CONTEXT_KEY];
}
var WalletStateContext = getOrCreateSharedContext();
function useWalletState() {
  const context = import_react.default.useContext(WalletStateContext);
  if (context === void 0) throw new Error("useWalletState must be used within a WalletStateProvider");
  return context;
}
function useAdapterContext() {
  const context = (0, import_react.useContext)(AdapterContext);
  if (!context) throw new Error("useAdapterContext must be used within an AdapterProvider");
  return context;
}
async function configureAdapterUiKit(adapter, loadConfigModule, programmaticOverrides = {}) {
  try {
    if (typeof adapter.configureUiKit === "function") {
      logger.info("[WSP configureAdapterUiKit] Calling configureUiKit for adapter:", adapter?.networkConfig?.id);
      await adapter.configureUiKit(programmaticOverrides, { loadUiKitNativeConfig: loadConfigModule });
      logger.info("[WSP configureAdapterUiKit] configureUiKit completed for adapter:", adapter?.networkConfig?.id);
    }
    const providerComponent = adapter.getEcosystemReactUiContextProvider?.() || null;
    const hooks = adapter.getEcosystemReactHooks?.() || null;
    logger.info("[WSP configureAdapterUiKit]", "UI provider and hooks retrieved successfully.");
    return {
      providerComponent,
      hooks
    };
  } catch (error) {
    logger.error("[WSP configureAdapterUiKit]", "Error during adapter UI setup:", error);
    throw error;
  }
}
function WalletStateProvider({ children, initialNetworkId = null, getNetworkConfigById, loadConfigModule }) {
  const [currentGlobalNetworkId, setCurrentGlobalNetworkIdState] = (0, import_react.useState)(initialNetworkId);
  const [currentGlobalNetworkConfig, setCurrentGlobalNetworkConfig] = (0, import_react.useState)(null);
  const [globalActiveAdapter, setGlobalActiveAdapter] = (0, import_react.useState)(null);
  const [isGlobalAdapterLoading, setIsGlobalAdapterLoading] = (0, import_react.useState)(false);
  const [walletFacadeHooks, setWalletFacadeHooks] = (0, import_react.useState)(null);
  const [AdapterUiContextProviderToRender, setAdapterUiContextProviderToRender] = (0, import_react.useState)(null);
  const [uiKitConfigVersion, setUiKitConfigVersion] = (0, import_react.useState)(0);
  const [programmaticUiKitConfig, setProgrammaticUiKitConfig] = (0, import_react.useState)(void 0);
  const { getAdapterForNetwork } = useAdapterContext();
  (0, import_react.useEffect)(() => {
    const abortController = new AbortController();
    async function fetchNetworkConfig() {
      if (!currentGlobalNetworkId) {
        if (!abortController.signal.aborted) setCurrentGlobalNetworkConfig(null);
        return;
      }
      try {
        const config = await Promise.resolve(getNetworkConfigById(currentGlobalNetworkId));
        if (!abortController.signal.aborted) setCurrentGlobalNetworkConfig(config || null);
      } catch (error) {
        if (!abortController.signal.aborted) {
          logger.error("[WSP fetchNetworkConfig]", "Failed to fetch network config:", error);
          setCurrentGlobalNetworkConfig(null);
        }
      }
    }
    fetchNetworkConfig();
    return () => abortController.abort();
  }, [currentGlobalNetworkId, getNetworkConfigById]);
  (0, import_react.useEffect)(() => {
    const abortController = new AbortController();
    async function loadAdapterAndConfigureUi() {
      if (!currentGlobalNetworkConfig) {
        if (!abortController.signal.aborted) {
          setGlobalActiveAdapter(null);
          setIsGlobalAdapterLoading(false);
          setAdapterUiContextProviderToRender(null);
          setWalletFacadeHooks(null);
        }
        return;
      }
      const { adapter: newAdapter, isLoading: newIsLoading } = getAdapterForNetwork(currentGlobalNetworkConfig);
      if (abortController.signal.aborted) return;
      setIsGlobalAdapterLoading(newIsLoading);
      if (newAdapter && !newIsLoading) try {
        const { providerComponent, hooks } = await configureAdapterUiKit(newAdapter, loadConfigModule, programmaticUiKitConfig);
        if (!abortController.signal.aborted) {
          setAdapterUiContextProviderToRender(() => providerComponent);
          setWalletFacadeHooks(hooks);
          setGlobalActiveAdapter(newAdapter);
        }
      } catch (error) {
        if (!abortController.signal.aborted) {
          logger.error("[WSP loadAdapterAndConfigureUi]", "Error during adapter UI setup:", error);
          setAdapterUiContextProviderToRender(null);
          setWalletFacadeHooks(null);
        }
      }
      else if (!newAdapter && !newIsLoading) {
        if (!abortController.signal.aborted) {
          setAdapterUiContextProviderToRender(null);
          setWalletFacadeHooks(null);
          setGlobalActiveAdapter(null);
        }
      }
    }
    loadAdapterAndConfigureUi();
    return () => abortController.abort();
  }, [
    currentGlobalNetworkConfig,
    getAdapterForNetwork,
    loadConfigModule,
    uiKitConfigVersion,
    programmaticUiKitConfig
  ]);
  const setActiveNetworkIdCallback = (0, import_react.useCallback)((networkId) => {
    logger.info("WalletStateProvider", `Setting global network ID to: ${networkId}`);
    setCurrentGlobalNetworkIdState(networkId);
    if (!networkId) {
      setCurrentGlobalNetworkConfig(null);
      setGlobalActiveAdapter(null);
      setIsGlobalAdapterLoading(false);
      setWalletFacadeHooks(null);
    }
  }, []);
  const reconfigureActiveAdapterUiKit = (0, import_react.useCallback)((uiKitConfig) => {
    logger.info("WalletStateProvider", "Explicitly triggering UI kit re-configuration by bumping version.", uiKitConfig);
    setProgrammaticUiKitConfig(uiKitConfig);
    setUiKitConfigVersion((v) => v + 1);
  }, [setProgrammaticUiKitConfig, setUiKitConfigVersion]);
  const contextValue = (0, import_react.useMemo)(() => ({
    activeNetworkId: currentGlobalNetworkId,
    setActiveNetworkId: setActiveNetworkIdCallback,
    activeNetworkConfig: currentGlobalNetworkConfig,
    activeAdapter: globalActiveAdapter,
    isAdapterLoading: isGlobalAdapterLoading,
    walletFacadeHooks,
    reconfigureActiveAdapterUiKit
  }), [
    currentGlobalNetworkId,
    setActiveNetworkIdCallback,
    currentGlobalNetworkConfig,
    globalActiveAdapter,
    isGlobalAdapterLoading,
    walletFacadeHooks,
    reconfigureActiveAdapterUiKit
  ]);
  const ActualProviderToRender = AdapterUiContextProviderToRender;
  let childrenToRender;
  if (ActualProviderToRender) {
    const key = `${globalActiveAdapter?.networkConfig?.ecosystem || "unknown"}-${globalActiveAdapter?.networkConfig?.id || "unknown"}`;
    logger.info("[WSP RENDER]", "Rendering adapter-provided UI context provider:", ActualProviderToRender.displayName || ActualProviderToRender.name || "UnknownComponent", "with key:", key);
    childrenToRender = (0, import_jsx_runtime.jsx)(ActualProviderToRender, { children }, key);
  } else {
    logger.info("[WSP RENDER]", "No adapter UI context provider to render. Rendering direct children.");
    childrenToRender = children;
  }
  return (0, import_jsx_runtime.jsx)(WalletStateContext.Provider, {
    value: contextValue,
    children: childrenToRender
  });
}
var AnalyticsContext = (0, import_react.createContext)(null);
var useAnalyticsContext = () => {
  const context = (0, import_react.useContext)(AnalyticsContext);
  if (!context) throw new Error("useAnalyticsContext must be used within an AnalyticsProvider");
  return context;
};
var AnalyticsProvider = ({ tagId, autoInit = true, children }) => {
  (0, import_react.useEffect)(() => {
    if (autoInit && tagId) AnalyticsService.initialize(tagId);
  }, [tagId, autoInit]);
  const contextValue = (0, import_react.useMemo)(() => ({
    tagId,
    isEnabled: () => AnalyticsService.isEnabled(),
    initialize: (tagIdOverride) => {
      const effectiveTagId = tagIdOverride || tagId;
      if (effectiveTagId) AnalyticsService.initialize(effectiveTagId);
    },
    trackEvent: (eventName, parameters) => {
      try {
        AnalyticsService.trackEvent(eventName, parameters);
      } catch (error) {
        logger.error("AnalyticsProvider", "Error tracking event:", error);
      }
    },
    trackPageView: (pageName, pagePath) => {
      try {
        AnalyticsService.trackPageView(pageName, pagePath);
      } catch (error) {
        logger.error("AnalyticsProvider", "Error tracking page view:", error);
      }
    },
    trackNetworkSelection: (networkId, ecosystem) => {
      try {
        AnalyticsService.trackNetworkSelection(networkId, ecosystem);
      } catch (error) {
        logger.error("AnalyticsProvider", "Error tracking network selection:", error);
      }
    }
  }), [tagId]);
  return (0, import_jsx_runtime.jsx)(AnalyticsContext.Provider, {
    value: contextValue,
    children
  });
};
var useAnalytics = () => {
  try {
    return useAnalyticsContext();
  } catch {
    throw new Error("useAnalytics must be used within an AnalyticsProvider");
  }
};
function useWalletComponents() {
  const { activeAdapter } = useWalletState();
  if (!activeAdapter || typeof activeAdapter.getEcosystemWalletComponents !== "function") return null;
  try {
    return activeAdapter.getEcosystemWalletComponents() ?? null;
  } catch {
    return null;
  }
}
var defaultAccountStatus = {
  isConnected: false,
  address: void 0,
  chainId: void 0
};
function useDerivedAccountStatus() {
  const { walletFacadeHooks } = useWalletState();
  const accountHookOutput = walletFacadeHooks?.useAccount ? walletFacadeHooks.useAccount() : void 0;
  if (isRecordWithProperties(accountHookOutput)) return {
    isConnected: "isConnected" in accountHookOutput && typeof accountHookOutput.isConnected === "boolean" ? accountHookOutput.isConnected : defaultAccountStatus.isConnected,
    address: "address" in accountHookOutput && typeof accountHookOutput.address === "string" ? accountHookOutput.address : defaultAccountStatus.address,
    chainId: "chainId" in accountHookOutput && typeof accountHookOutput.chainId === "number" ? accountHookOutput.chainId : defaultAccountStatus.chainId
  };
  return defaultAccountStatus;
}
var defaultSwitchChainStatus = {
  switchChain: void 0,
  isSwitching: false,
  error: null
};
function useDerivedSwitchChainStatus() {
  const { walletFacadeHooks } = useWalletState();
  const switchChainHookOutput = walletFacadeHooks?.useSwitchChain ? walletFacadeHooks.useSwitchChain() : void 0;
  if (isRecordWithProperties(switchChainHookOutput)) return {
    switchChain: "switchChain" in switchChainHookOutput && typeof switchChainHookOutput.switchChain === "function" ? switchChainHookOutput.switchChain : defaultSwitchChainStatus.switchChain,
    isSwitching: "isPending" in switchChainHookOutput && typeof switchChainHookOutput.isPending === "boolean" ? switchChainHookOutput.isPending : defaultSwitchChainStatus.isSwitching,
    error: "error" in switchChainHookOutput && switchChainHookOutput.error instanceof Error ? switchChainHookOutput.error : defaultSwitchChainStatus.error
  };
  return defaultSwitchChainStatus;
}
var defaultChainInfo = {
  currentChainId: void 0,
  availableChains: []
};
function useDerivedChainInfo() {
  const { walletFacadeHooks } = useWalletState();
  let chainIdToReturn = defaultChainInfo.currentChainId;
  const chainIdHookOutput = walletFacadeHooks?.useChainId ? walletFacadeHooks.useChainId() : void 0;
  if (typeof chainIdHookOutput === "number") chainIdToReturn = chainIdHookOutput;
  else if (chainIdHookOutput !== void 0) logger.warn("useDerivedChainInfo", "useChainId facade hook returned non-numeric value:", chainIdHookOutput);
  let chainsToReturn = defaultChainInfo.availableChains;
  const chainsHookOutput = walletFacadeHooks?.useChains ? walletFacadeHooks.useChains() : void 0;
  if (Array.isArray(chainsHookOutput)) chainsToReturn = chainsHookOutput;
  else if (chainsHookOutput !== void 0) logger.warn("useDerivedChainInfo", "useChains facade hook returned non-array value:", chainsHookOutput);
  return {
    currentChainId: chainIdToReturn,
    availableChains: chainsToReturn
  };
}
var defaultConnectStatus = {
  connect: void 0,
  connectors: [],
  isConnecting: false,
  error: null,
  pendingConnector: void 0
};
function useDerivedConnectStatus() {
  const { walletFacadeHooks } = useWalletState();
  const connectHookOutput = walletFacadeHooks?.useConnect ? walletFacadeHooks.useConnect() : void 0;
  if (isRecordWithProperties(connectHookOutput)) return {
    connect: "connect" in connectHookOutput && typeof connectHookOutput.connect === "function" ? connectHookOutput.connect : defaultConnectStatus.connect,
    connectors: "connectors" in connectHookOutput && Array.isArray(connectHookOutput.connectors) ? connectHookOutput.connectors : defaultConnectStatus.connectors,
    isConnecting: "isPending" in connectHookOutput && typeof connectHookOutput.isPending === "boolean" ? connectHookOutput.isPending : "isLoading" in connectHookOutput && typeof connectHookOutput.isLoading === "boolean" ? connectHookOutput.isLoading : defaultConnectStatus.isConnecting,
    error: "error" in connectHookOutput && connectHookOutput.error instanceof Error ? connectHookOutput.error : defaultConnectStatus.error,
    pendingConnector: "pendingConnector" in connectHookOutput && typeof connectHookOutput.pendingConnector === "object" ? connectHookOutput.pendingConnector : defaultConnectStatus.pendingConnector
  };
  return defaultConnectStatus;
}
var defaultDisconnectStatus = {
  disconnect: void 0,
  isDisconnecting: false,
  error: null
};
function useDerivedDisconnect() {
  const { walletFacadeHooks } = useWalletState();
  const disconnectHookOutput = walletFacadeHooks?.useDisconnect ? walletFacadeHooks.useDisconnect() : void 0;
  if (isRecordWithProperties(disconnectHookOutput)) return {
    disconnect: "disconnect" in disconnectHookOutput && typeof disconnectHookOutput.disconnect === "function" ? disconnectHookOutput.disconnect : defaultDisconnectStatus.disconnect,
    isDisconnecting: "isPending" in disconnectHookOutput && typeof disconnectHookOutput.isPending === "boolean" ? disconnectHookOutput.isPending : "isLoading" in disconnectHookOutput && typeof disconnectHookOutput.isLoading === "boolean" ? disconnectHookOutput.isLoading : defaultDisconnectStatus.isDisconnecting,
    error: "error" in disconnectHookOutput && disconnectHookOutput.error instanceof Error ? disconnectHookOutput.error : defaultDisconnectStatus.error
  };
  return defaultDisconnectStatus;
}
function useWalletReconnectionHandler(selectedNetworkConfigId, selectedAdapter, networkToSwitchTo, onRequeueSwitch) {
  const { isConnected, chainId: walletChainId } = useDerivedAccountStatus();
  const prevConnectedRef = (0, import_react.useRef)(isConnected);
  (0, import_react.useEffect)(() => {
    const isReconnection = !prevConnectedRef.current && isConnected;
    prevConnectedRef.current = isConnected;
    if (!isReconnection || !selectedNetworkConfigId || !selectedAdapter) return;
    if (networkToSwitchTo === selectedNetworkConfigId) return;
    const adapterConfig = selectedAdapter.networkConfig;
    if (!("chainId" in adapterConfig) || !walletChainId) return;
    const targetChainId = Number(adapterConfig.chainId);
    if (walletChainId !== targetChainId) {
      logger.info("useWalletReconnectionHandler", `Wallet reconnected with chain ${walletChainId}, but selected network requires ${targetChainId}. Re-queueing switch.`);
      onRequeueSwitch(selectedNetworkConfigId);
    }
  }, [
    isConnected,
    walletChainId,
    selectedNetworkConfigId,
    selectedAdapter,
    networkToSwitchTo,
    onRequeueSwitch
  ]);
}
var WalletConnectionUI = ({ className, connectButtonProps, accountDisplayProps, networkSwitcherProps }) => {
  const [isError, setIsError] = (0, import_react.useState)(false);
  const { activeAdapter, walletFacadeHooks } = useWalletState();
  (0, import_react.useEffect)(() => {
    logger.debug("WalletConnectionUI", "[Debug] State from useWalletState:", {
      adapterId: activeAdapter?.networkConfig.id,
      hasFacadeHooks: !!walletFacadeHooks
    });
  }, [activeAdapter, walletFacadeHooks]);
  const walletComponents = (() => {
    if (!activeAdapter || typeof activeAdapter.getEcosystemWalletComponents !== "function") {
      logger.debug("WalletConnectionUI", "[Debug] No activeAdapter or getEcosystemWalletComponents method, returning null.");
      return null;
    }
    try {
      const components = activeAdapter.getEcosystemWalletComponents();
      logger.debug("WalletConnectionUI", "[Debug] walletComponents from adapter:", components);
      return components;
    } catch (error) {
      logger.error("WalletConnectionUI", "[Debug] Error getting wallet components:", error);
      setIsError(true);
      return null;
    }
  })();
  if (!walletComponents) {
    logger.debug("WalletConnectionUI", "[Debug] getEcosystemWalletComponents returned null/undefined, rendering null.");
    return null;
  }
  logger.debug("WalletConnectionUI", "Rendering wallet components:", {
    hasConnectButton: !!walletComponents.ConnectButton,
    hasAccountDisplay: !!walletComponents.AccountDisplay,
    hasNetworkSwitcher: !!walletComponents.NetworkSwitcher
  });
  const { ConnectButton, AccountDisplay, NetworkSwitcher } = walletComponents;
  if (isError) return (0, import_jsx_runtime.jsx)("div", {
    className: cn("flex items-center gap-4", className),
    children: (0, import_jsx_runtime.jsx)(Button, {
      variant: "destructive",
      size: "sm",
      onClick: () => window.location.reload(),
      children: "Wallet Error - Retry"
    })
  });
  return (0, import_jsx_runtime.jsxs)("div", {
    className: cn("flex items-center gap-4", className),
    children: [
      NetworkSwitcher && (0, import_jsx_runtime.jsx)(NetworkSwitcher, { ...networkSwitcherProps }),
      AccountDisplay && (0, import_jsx_runtime.jsx)(AccountDisplay, { ...accountDisplayProps }),
      ConnectButton && (0, import_jsx_runtime.jsx)(ConnectButton, { ...connectButtonProps })
    ]
  });
};
var WalletConnectionHeader = () => {
  const { isAdapterLoading, activeAdapter } = useWalletState();
  (0, import_react.useEffect)(() => {
    logger.debug("WalletConnectionHeader", "[Debug] State from useWalletState:", {
      adapterPresent: !!activeAdapter,
      adapterNetwork: activeAdapter?.networkConfig.id,
      isLoading: isAdapterLoading
    });
  }, [activeAdapter, isAdapterLoading]);
  if (isAdapterLoading) {
    logger.debug("WalletConnectionHeader", "[Debug] Adapter loading, showing skeleton.");
    return (0, import_jsx_runtime.jsx)("div", { className: "h-9 w-28 animate-pulse rounded bg-muted" });
  }
  return (0, import_jsx_runtime.jsx)(WalletConnectionUI, {});
};
var NetworkSwitchManager = ({ adapter, targetNetworkId, onNetworkSwitchComplete }) => {
  const isMountedRef = (0, import_react.useRef)(true);
  const [hasAttemptedSwitch, setHasAttemptedSwitch] = (0, import_react.useState)(false);
  const { isConnected, chainId: currentChainIdFromHook } = useDerivedAccountStatus();
  const { switchChain: execSwitchNetwork, isSwitching: isSwitchingNetworkViaHook, error: switchNetworkError } = useDerivedSwitchChainStatus();
  (0, import_react.useEffect)(() => {
    isMountedRef.current = true;
    logger.info("NetworkSwitchManager", `Mounted with target: ${targetNetworkId}, current attempt status: ${hasAttemptedSwitch}`);
    setHasAttemptedSwitch(false);
    return () => {
      logger.info("NetworkSwitchManager", `Unmounting, was for target: ${targetNetworkId}`);
      isMountedRef.current = false;
    };
  }, [targetNetworkId]);
  (0, import_react.useEffect)(() => {
    logger.info("NetworkSwitchManager", "State Update:", {
      target: targetNetworkId,
      adapterNetwork: adapter.networkConfig.id,
      isSwitching: isSwitchingNetworkViaHook,
      hookError: !!switchNetworkError,
      canExec: !!execSwitchNetwork,
      connected: isConnected,
      walletChain: currentChainIdFromHook,
      attempted: hasAttemptedSwitch
    });
  }, [
    adapter,
    targetNetworkId,
    isSwitchingNetworkViaHook,
    switchNetworkError,
    execSwitchNetwork,
    isConnected,
    currentChainIdFromHook,
    hasAttemptedSwitch
  ]);
  (0, import_react.useEffect)(() => {
    const completeOperation = (logMessage, options = { notifyComplete: true }) => {
      if (logMessage) logger.info("NetworkSwitchManager", logMessage);
      if (options.notifyComplete && isMountedRef.current && onNetworkSwitchComplete) onNetworkSwitchComplete();
      if (isMountedRef.current) setHasAttemptedSwitch(false);
    };
    if (!execSwitchNetwork) {
      completeOperation("No switchChain function available from hook. Operation halted.", { notifyComplete: false });
      return;
    }
    if (isSwitchingNetworkViaHook && hasAttemptedSwitch) {
      logger.info("NetworkSwitchManager", "Hook reports switch in progress for current attempt. Waiting...");
      return;
    }
    if (hasAttemptedSwitch && !isSwitchingNetworkViaHook) {
      logger.info("NetworkSwitchManager", "Previous switch attempt concluded. Deferring to completion effect.");
      return;
    }
    if (adapter.networkConfig.id !== targetNetworkId) {
      completeOperation(`CRITICAL: Adapter (${adapter.networkConfig.id}) vs Target (${targetNetworkId}) mismatch. Operation halted.`, { notifyComplete: false });
      return;
    }
    if (!isConnected) {
      completeOperation("Wallet not connected (derived status). Awaiting connection.", { notifyComplete: false });
      return;
    }
    if (!("chainId" in adapter.networkConfig)) {
      completeOperation("Network does not support chain switching (non-EVM). Operation complete (no-op).");
      return;
    }
    const targetChainToBeSwitchedTo = Number(adapter.networkConfig.chainId);
    if (currentChainIdFromHook === targetChainToBeSwitchedTo) {
      completeOperation("Already on correct chain (derived status). Operation complete.");
      return;
    }
    const performSwitchActual = () => {
      if (!isMountedRef.current || isSwitchingNetworkViaHook || hasAttemptedSwitch) {
        logger.info("NetworkSwitchManager", `Switch attempt aborted in timeout or already handled. Conditions: isSwitching: ${isSwitchingNetworkViaHook}, hasAttempted: ${hasAttemptedSwitch}`);
        return;
      }
      logger.info("NetworkSwitchManager", `Attempting switch to ${targetChainToBeSwitchedTo} via derived hook.`);
      setHasAttemptedSwitch(true);
      execSwitchNetwork({ chainId: targetChainToBeSwitchedTo });
    };
    const timeoutId = setTimeout(performSwitchActual, 100);
    return () => clearTimeout(timeoutId);
  }, [
    adapter,
    targetNetworkId,
    execSwitchNetwork,
    isSwitchingNetworkViaHook,
    onNetworkSwitchComplete,
    isConnected,
    currentChainIdFromHook,
    hasAttemptedSwitch
  ]);
  (0, import_react.useEffect)(() => {
    if (!isMountedRef.current || !execSwitchNetwork || !hasAttemptedSwitch) return;
    if (!isSwitchingNetworkViaHook) {
      let completionMessage = "Switch hook operation concluded.";
      if (switchNetworkError) {
        logger.error("NetworkSwitchManager", "Error from derived switch hook:", switchNetworkError);
        completionMessage = "Switch hook completed with error.";
      } else logger.info("NetworkSwitchManager", "Derived switch hook completed successfully.");
      if (onNetworkSwitchComplete) onNetworkSwitchComplete();
      if (isMountedRef.current) setHasAttemptedSwitch(false);
      logger.info("NetworkSwitchManager", completionMessage);
    }
  }, [
    isSwitchingNetworkViaHook,
    switchNetworkError,
    execSwitchNetwork,
    hasAttemptedSwitch,
    onNetworkSwitchComplete
  ]);
  return null;
};

export {
  AdapterContext,
  AdapterProvider,
  WalletStateContext,
  useWalletState,
  useAdapterContext,
  WalletStateProvider,
  AnalyticsContext,
  AnalyticsProvider,
  useAnalytics,
  useWalletComponents,
  useDerivedAccountStatus,
  useDerivedSwitchChainStatus,
  useDerivedChainInfo,
  useDerivedConnectStatus,
  useDerivedDisconnect,
  useWalletReconnectionHandler,
  WalletConnectionUI,
  WalletConnectionHeader,
  NetworkSwitchManager
};
//# sourceMappingURL=chunk-WE54CRYE.js.map
