//#region src/adapters/ui-enhancements.ts
/**
* Valid component keys for EcosystemWalletComponents.
* Used for type-safe runtime validation of component exclusion lists.
*/
const ECOSYSTEM_WALLET_COMPONENT_KEYS = [
	"ConnectButton",
	"AccountDisplay",
	"NetworkSwitcher"
];

//#endregion
//#region src/adapters/access-control-errors.ts
/**
* Access Control Error Types
*
* Chain-agnostic error classes for access control operations.
* These errors can be used across any adapter (EVM, Stellar, Solana, Midnight, etc.)
* that implements access control functionality.
*
* Each error type provides specific context for debugging and user-friendly error messages.
*/
/**
* Base class for all Access Control errors
*
* This abstract class serves as the foundation for all access control-related errors.
* It provides a common structure with optional contract address context.
*/
var AccessControlError = class extends Error {
	/**
	* Creates a new AccessControlError.
	* @param message - Error message describing the issue
	* @param contractAddress - Optional contract address for context
	*/
	constructor(message, contractAddress) {
		super(message);
		this.contractAddress = contractAddress;
		this.name = this.constructor.name;
	}
};
/**
* Error thrown when a contract does not implement required interfaces
*
* This error indicates that a contract is missing necessary access control functionality
* or has a partial/incompatible implementation.
*
* @example
* ```typescript
* throw new UnsupportedContractFeatures(
*   'Contract missing required Ownable methods',
*   contractAddress,
*   ['transfer_ownership', 'renounce_ownership']
* );
* ```
*
* Common use cases:
* - Contract missing Ownable or AccessControl methods
* - Contract has partial implementation that doesn't conform to standards
* - Contract is a custom access control implementation not compatible with expected interfaces
*/
var UnsupportedContractFeatures = class extends AccessControlError {
	/**
	* Creates a new UnsupportedContractFeatures error.
	* @param message - Error message describing the issue
	* @param contractAddress - Optional contract address for context
	* @param missingFeatures - Optional list of missing feature names
	*/
	constructor(message, contractAddress, missingFeatures) {
		super(message, contractAddress);
		this.missingFeatures = missingFeatures;
	}
};
/**
* Error thrown when the caller lacks required permissions for an operation
*
* This error indicates an authorization failure where the calling account doesn't
* have the necessary permissions to execute the requested operation.
*
* @example
* ```typescript
* throw new PermissionDenied(
*   'Caller is not an admin',
*   contractAddress,
*   'ADMIN_ROLE',
*   callerAddress
* );
* ```
*
* Common use cases:
* - Attempting to grant/revoke roles without admin rights
* - Trying to transfer ownership without being the owner
* - Executing operations that require specific role membership
*/
var PermissionDenied = class extends AccessControlError {
	/**
	* Creates a new PermissionDenied error.
	* @param message - Error message describing the issue
	* @param contractAddress - Optional contract address for context
	* @param requiredRole - Optional role that was required
	* @param callerAddress - Optional address of the caller who lacked permission
	*/
	constructor(message, contractAddress, requiredRole, callerAddress) {
		super(message, contractAddress);
		this.requiredRole = requiredRole;
		this.callerAddress = callerAddress;
	}
};
/**
* Error thrown when an indexer is required but not available
*
* This error indicates that an operation requires indexer support (e.g., for historical data),
* but the indexer is not configured, unreachable, or not functioning properly.
*
* @example
* ```typescript
* throw new IndexerUnavailable(
*   'History queries require indexer support',
*   contractAddress,
*   networkId,
*   indexerEndpoint
* );
* ```
*
* Common use cases:
* - No indexer endpoint configured in network config
* - Indexer endpoint is unreachable or returning errors
* - Indexer health check fails
* - Network doesn't have indexer support
*/
var IndexerUnavailable = class extends AccessControlError {
	/**
	* Creates a new IndexerUnavailable error.
	* @param message - Error message describing the issue
	* @param contractAddress - Optional contract address for context
	* @param networkId - Optional network identifier
	* @param endpointUrl - Optional indexer endpoint URL that was unavailable
	*/
	constructor(message, contractAddress, networkId, endpointUrl) {
		super(message, contractAddress);
		this.networkId = networkId;
		this.endpointUrl = endpointUrl;
	}
};
/**
* Error thrown when configuration is invalid or incomplete
*
* This error indicates a problem with the configuration provided to access control operations,
* such as invalid addresses, missing required config, or malformed parameters.
*
* @example
* ```typescript
* throw new ConfigurationInvalid(
*   'Contract not registered',
*   contractAddress,
*   'contractAddress',
*   providedAddress
* );
* ```
*
* Common use cases:
* - Invalid contract address format
* - Missing required network configuration
* - Invalid role identifier
* - Malformed indexer endpoint
* - Contract not registered before use
*/
var ConfigurationInvalid = class extends AccessControlError {
	/**
	* Creates a new ConfigurationInvalid error.
	* @param message - Error message describing the issue
	* @param contractAddress - Optional contract address for context
	* @param configField - Optional name of the invalid configuration field
	* @param providedValue - Optional value that was invalid
	*/
	constructor(message, contractAddress, configField, providedValue) {
		super(message, contractAddress);
		this.configField = configField;
		this.providedValue = providedValue;
	}
};
/**
* Error thrown when an operation fails during execution
*
* This error indicates a runtime failure during an access control operation.
* It includes the operation name and can chain the underlying cause for debugging.
*
* @example
* ```typescript
* try {
*   // ... operation code
* } catch (err) {
*   throw new OperationFailed(
*     'Failed to read ownership',
*     contractAddress,
*     'readOwnership',
*     err as Error
*   );
* }
* ```
*
* Common use cases:
* - Transaction assembly fails
* - RPC call returns an error
* - Transaction simulation fails
* - On-chain read operation fails
* - GraphQL query to indexer fails
* - Snapshot validation fails
*/
var OperationFailed = class extends AccessControlError {
	/**
	* Creates a new OperationFailed error.
	* @param message - Error message describing the issue
	* @param contractAddress - Optional contract address for context
	* @param operation - Optional name of the operation that failed
	* @param cause - Optional underlying error that caused the failure
	*/
	constructor(message, contractAddress, operation, cause) {
		super(message, contractAddress);
		this.operation = operation;
		this.cause = cause;
	}
};

//#endregion
//#region src/common/ecosystem.ts
/**
* Type guards for ecosystem types
*/
const isEvmEcosystem = (ecosystem) => ecosystem === "evm";
const isSolanaEcosystem = (ecosystem) => ecosystem === "solana";
const isStellarEcosystem = (ecosystem) => ecosystem === "stellar";
const isMidnightEcosystem = (ecosystem) => ecosystem === "midnight";
const isPolkadotEcosystem = (ecosystem) => ecosystem === "polkadot";

//#endregion
//#region src/common/enum.ts
/**
* Type guard to check if a value is an EnumValue
*/
function isEnumValue(value) {
	return typeof value === "object" && value !== null && "tag" in value && typeof value.tag === "string" && (!("values" in value) || Array.isArray(value.values));
}

//#endregion
//#region src/common/map.ts
/**
* Type guard to check if a value is a MapEntry
*/
function isMapEntry(value) {
	return typeof value === "object" && value !== null && "key" in value && "value" in value && Object.keys(value).length >= 2;
}
/**
* Type guard to check if a value is an array of MapEntry objects
*/
function isMapEntryArray(value) {
	return Array.isArray(value) && value.every(isMapEntry);
}

//#endregion
//#region src/networks/config.ts
/**
* Type guard to check if a network config is for EVM
* @param config The network configuration to check
* @returns True if the config is for EVM
*/
const isEvmNetworkConfig = (config) => config.ecosystem === "evm";
/**
* Type guard to check if a network config is for Solana
* @param config The network configuration to check
* @returns True if the config is for Solana
*/
const isSolanaNetworkConfig = (config) => config.ecosystem === "solana";
/**
* Type guard to check if a network config is for Stellar
* @param config The network configuration to check
* @returns True if the config is for Stellar
*/
const isStellarNetworkConfig = (config) => config.ecosystem === "stellar";
/**
* Type guard to check if a network config is for Midnight
* @param config The network configuration to check
* @returns True if the config is for Midnight
*/
const isMidnightNetworkConfig = (config) => config.ecosystem === "midnight";
/**
* Type guard to check if a network config is for Polkadot
* @param config The network configuration to check
* @returns True if the config is for Polkadot
*/
const isPolkadotNetworkConfig = (config) => config.ecosystem === "polkadot";

//#endregion
//#region src/networks/validation.ts
/**
* Network Configuration Validation
*
* This file contains utilities for validating network configurations to ensure they have
* all required fields and properly typed values for each ecosystem.
*/
/**
* Validate a network configuration
* @param config The network configuration to validate
* @returns True if the configuration is valid
*/
function validateNetworkConfig(config) {
	if (!validateBaseNetworkConfig(config)) return false;
	if (isEvmNetworkConfig(config)) return validateEvmNetworkConfig(config);
	else if (isSolanaNetworkConfig(config)) return validateSolanaNetworkConfig(config);
	else if (isStellarNetworkConfig(config)) return validateStellarNetworkConfig(config);
	else if (isMidnightNetworkConfig(config)) return validateMidnightNetworkConfig(config);
	return false;
}
/**
* Validate the base fields common to all network configurations
* @param config The network configuration to validate
* @returns True if the base configuration is valid
*/
function validateBaseNetworkConfig(config) {
	return typeof config.id === "string" && config.id.trim().length > 0 && typeof config.name === "string" && config.name.trim().length > 0 && typeof config.network === "string" && config.network.trim().length > 0 && [
		"mainnet",
		"testnet",
		"devnet"
	].includes(config.type) && typeof config.isTestnet === "boolean" && (config.explorerUrl === void 0 || typeof config.explorerUrl === "string");
}
/**
* Validate an EVM network configuration
* @param config The EVM network configuration to validate
* @returns True if the configuration is valid
*/
function validateEvmNetworkConfig(config) {
	return typeof config.chainId === "number" && config.chainId > 0 && typeof config.rpcUrl === "string" && config.rpcUrl.trim().length > 0 && validateEvmNativeCurrency(config.nativeCurrency);
}
/**
* Validate the native currency object in an EVM network configuration
* @param currency The native currency object to validate
* @returns True if the native currency is valid
*/
function validateEvmNativeCurrency(currency) {
	return typeof currency === "object" && currency !== null && typeof currency.name === "string" && currency.name.trim().length > 0 && typeof currency.symbol === "string" && currency.symbol.trim().length > 0 && typeof currency.decimals === "number" && currency.decimals >= 0;
}
/**
* Validate a Solana network configuration
* @param config The Solana network configuration to validate
* @returns True if the configuration is valid
*/
function validateSolanaNetworkConfig(config) {
	return typeof config.rpcEndpoint === "string" && config.rpcEndpoint.trim().length > 0 && ["confirmed", "finalized"].includes(config.commitment);
}
/**
* Validate a Stellar network configuration
* @param config The Stellar network configuration to validate
* @returns True if the configuration is valid
*/
function validateStellarNetworkConfig(config) {
	return typeof config.horizonUrl === "string" && config.horizonUrl.trim().length > 0 && typeof config.networkPassphrase === "string" && config.networkPassphrase.trim().length > 0;
}
/**
* Validate a Midnight network configuration
* @param config The Midnight network configuration to validate
* @returns True if the configuration is valid
*/
function validateMidnightNetworkConfig(_config) {
	return true;
}

//#endregion
export { AccessControlError, ConfigurationInvalid, ECOSYSTEM_WALLET_COMPONENT_KEYS, IndexerUnavailable, OperationFailed, PermissionDenied, UnsupportedContractFeatures, isEnumValue, isEvmEcosystem, isEvmNetworkConfig, isMapEntry, isMapEntryArray, isMidnightEcosystem, isMidnightNetworkConfig, isPolkadotEcosystem, isPolkadotNetworkConfig, isSolanaEcosystem, isSolanaNetworkConfig, isStellarEcosystem, isStellarNetworkConfig, validateNetworkConfig };
//# sourceMappingURL=index.mjs.map