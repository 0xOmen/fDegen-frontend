import React$1 from "react";

//#region src/config/app-config.d.ts

/**
 * Configuration types for the runtime application.
 * These types define the structure for application-wide configurations,
 * including API keys, feature flags, and other settings.
 * @packageDocumentation
 */
/**
 * Configuration for specific explorer/network services.
 */
interface ExplorerApiConfig {
  /** The API key for this specific service. */
  apiKey?: string;
}
/**
 * A collection of configurations for various network services,
 * keyed by a unique service identifier.
 * Example identifiers: "etherscan-mainnet", "polygonscan-matic", "arbiscan-mainnet"
 */
interface NetworkServiceConfigs {
  [serviceIdentifier: string]: ExplorerApiConfig | undefined;
}
/**
 * Generic configuration for a service parameter.
 *
 * This can contain:
 * - Primitive values (string, number, boolean)
 * - Nested objects for more complex configuration
 * - Arrays of primitive values or objects
 */
interface ServiceParameterConfig {
  [paramName: string]: string | number | boolean | object | Array<unknown> | undefined;
}
/**
 * A collection of configurations for global services, keyed by service name.
 * Adapters or services will look up their specific configurations here.
 * Example: globalServiceConfigs['walletconnect']?.['projectId']
 */
interface GlobalServiceConfigs {
  [serviceName: string]: ServiceParameterConfig | undefined;
}
/**
 * Feature flags for enabling/disabling application features.
 * Keyed by the feature flag name.
 */
interface FeatureFlags {
  [flagName: string]: boolean;
}
/**
 * Configuration for an RPC endpoint, allowing for different transport types.
 */
interface RpcEndpointConfig {
  http?: string;
  webSocket?: string;
}
/**
 * Configuration for a user-provided RPC provider.
 * This allows users to configure their own RPC endpoints with API keys.
 */
interface UserRpcProviderConfig {
  /** The RPC endpoint URL */
  url: string;
  /** Optional API key for providers that require authentication */
  apiKey?: string;
  /** User-friendly name for this configuration (e.g., "My Alchemy Key") */
  name?: string;
  /** Whether this is a custom user-provided configuration */
  isCustom: boolean;
}
/**
 * Configuration for a user-provided block explorer.
 * This allows users to configure their own explorer endpoints and API keys.
 */
interface UserExplorerConfig {
  /** The explorer base URL (e.g., "https://etherscan.io") */
  explorerUrl?: string;
  /** The explorer API URL (e.g., "https://api.etherscan.io/api") - V1 only */
  apiUrl?: string;
  /** API key for the explorer service */
  apiKey?: string;
  /** User-friendly name for this configuration (e.g., "My Etherscan API") */
  name?: string;
  /** Whether this is a custom user-provided configuration */
  isCustom: boolean;
  /** Whether this configuration should be applied to all compatible networks */
  applyToAllNetworks?: boolean;
  /** List of network IDs this config applies to (if applyToAllNetworks is false) */
  appliedNetworkIds?: string[];
  /** Optional default contract definition provider key (adapter-defined options, chain-agnostic in UI) */
  defaultProvider?: string;
}
/**
 * Configuration for indexer endpoints.
 * Similar to RPC endpoint config but specifically for blockchain data indexers.
 */
interface IndexerEndpointConfig {
  http?: string;
  ws?: string;
}
/**
 * A collection of indexer endpoint overrides, keyed by network ID (e.g., networkConfig.id).
 * Values can be a simple string (assumed to be HTTP) or an IndexerEndpointConfig object.
 */
interface NetworkSpecificIndexerEndpoints {
  [networkId: string]: string | IndexerEndpointConfig | undefined;
}
/**
 * A collection of RPC endpoint overrides, keyed by network ID (e.g., networkConfig.id).
 * Values can be a simple string (assumed to be HTTP), an RpcEndpointConfig object,
 * or a UserRpcProviderConfig for user-configured endpoints.
 */
interface NetworkSpecificRpcEndpoints {
  [networkId: string]: string | RpcEndpointConfig | UserRpcProviderConfig | undefined;
}
/**
 * The main application runtime configuration structure.
 * This object holds all configurable parameters for the application.
 */
interface AppRuntimeConfig {
  /** Configurations for various network-related services like block explorers. */
  networkServiceConfigs?: NetworkServiceConfigs;
  /** Configurations for global services. */
  globalServiceConfigs?: GlobalServiceConfigs;
  /** Feature flags to toggle application behavior. */
  featureFlags?: FeatureFlags;
  /** Default language for the application (e.g., "en", "es"). */
  defaultLanguage?: string;
  /** RPC endpoint overrides for different networks. */
  rpcEndpoints?: NetworkSpecificRpcEndpoints;
  /** Indexer endpoint overrides for different networks (for historical data queries). */
  indexerEndpoints?: NetworkSpecificIndexerEndpoints;
}
//#endregion
//#region src/contracts/proxy.d.ts
/**
 * Proxy Contract Detection and Analysis Types
 *
 * These types support runtime proxy pattern detection and analysis.
 * Note: These are NOT persisted to storage - proxy information should be fresh on each load.
 */
/**
 * Chain-agnostic proxy contract detection information
 * Contains information about proxy pattern detection and implementation addresses
 */
interface ProxyInfo {
  /** Whether the contract is detected as a proxy */
  isProxy: boolean;
  /** Type of proxy pattern detected (e.g., 'uups', 'transparent', 'beacon', 'diamond', 'minimal') */
  proxyType: string;
  /** Implementation contract address that contains the business logic */
  implementationAddress?: string;
  /** Admin address for admin-managed proxies (when determinable via storage slots) */
  adminAddress?: string;
  /** Original proxy contract address provided by the user */
  proxyAddress: string;
  /** Method used to detect the proxy pattern (e.g., 'abi-analysis', 'eip1967-storage', 'direct-call') */
  detectionMethod?: string;
  /** Confidence level of the proxy detection */
  confidence?: 'high' | 'medium' | 'low';
  /** When the proxy information was detected */
  detectionTimestamp?: Date;
  /** Error message if proxy detection failed */
  detectionError?: string;
}
//#endregion
//#region src/common/ecosystem.d.ts
/**
 * Blockchain Ecosystem Types
 *
 * This file defines core types related to blockchain ecosystems supported
 * by the OpenZeppelin UI ecosystem. It consolidates previously scattered
 * ecosystem-related types into a single source of truth.
 */
/**
 * Supported blockchain ecosystems
 */
type Ecosystem = 'evm' | 'solana' | 'stellar' | 'midnight' | 'polkadot';
/**
 * Network environment types
 */
type NetworkType = 'mainnet' | 'testnet' | 'devnet';
/**
 * Configuration for ecosystem feature flags
 */
interface EcosystemFeatureConfig {
  /** Whether the ecosystem is enabled and functional */
  enabled: boolean;
  /** Whether to show the ecosystem in the UI (even if disabled) */
  showInUI: boolean;
  /** Label to display when the ecosystem is disabled */
  disabledLabel?: string;
  /** Description to show when the ecosystem is disabled */
  disabledDescription?: string;
}
/**
 * Interface for ecosystem-specific data in the registry
 */
interface EcosystemInfo {
  /** Display name (e.g., 'Ethereum (EVM)') */
  name: string;
  /** Detailed description of the blockchain */
  description: string;
  /** Explorer/verification platform guidance */
  explorerGuidance: string;
  /** Address format example (if applicable) */
  addressExample?: string;
  /** Icon path for the ecosystem (if available) */
  iconPath?: string;
  /** Network icon name for @web3icons/react NetworkIcon component */
  networkIconName?: string;
  /** Background color class for UI elements */
  bgColorClass?: string;
  /** Text color class for UI elements */
  textColorClass?: string;
  /** Default feature flag configuration */
  defaultFeatureConfig: EcosystemFeatureConfig;
}
/**
 * Blockchain ecosystem metadata for UI display and configuration
 */
interface EcosystemDefinition {
  /**
   * Unique identifier for the ecosystem
   */
  id: Ecosystem;
  /**
   * Human-readable name of the ecosystem
   */
  name: string;
  /**
   * Description of the ecosystem's purpose or characteristics
   */
  description: string;
  /**
   * Optional icon for UI display
   * Note: This uses a generic type as we don't want to introduce React dependencies
   */
  icon?: unknown;
}
/**
 * Type guards for ecosystem types
 */
declare const isEvmEcosystem: (ecosystem: Ecosystem) => ecosystem is "evm";
declare const isSolanaEcosystem: (ecosystem: Ecosystem) => ecosystem is "solana";
declare const isStellarEcosystem: (ecosystem: Ecosystem) => ecosystem is "stellar";
declare const isMidnightEcosystem: (ecosystem: Ecosystem) => ecosystem is "midnight";
declare const isPolkadotEcosystem: (ecosystem: Ecosystem) => ecosystem is "polkadot";
//#endregion
//#region src/contracts/schema.d.ts
/**
 * Represents a parameter within a contract function or event. This is a generalized, internal
 * representation used by the OpenZeppelin UI ecosystem. Blockchain-specific adapters are
 * responsible for mapping their native parameter types (e.g., from an EVM ABI or Solana IDL)
 * to this structure.
 */
interface FunctionParameter {
  /**
   * Parameter name as defined in the contract's native interface (e.g., ABI).
   */
  name: string;
  /**
   * The parameter's type as a string, specific to the blockchain ecosystem.
   * For EVM, this would be Solidity types like 'uint256', 'address', 'tuple'.
   * Adapters interpret this string to determine appropriate UI fields and data encoding.
   */
  type: string;
  /**
   * Optional user-friendly display name, often derived from the `name` or provided
   * by the adapter or user for better UI presentation.
   */
  displayName?: string;
  /**
   * Optional description for documentation, UI tooltips, or helper text in forms.
   * This may come from comments in the contract source or be added by the user.
   */
  description?: string;
  /**
   * For complex/nested types (e.g., structs in Solidity, tuples), this array holds
   * the definition of each component parameter, recursively using `FunctionParameter`.
   * Adapters populate this based on the structure of the complex type.
   */
  components?: FunctionParameter[];
  /**
   * Optional enum metadata for adapters to describe variant structure.
   */
  enumMetadata?: {
    name: string;
    variants: Array<{
      name: string;
      type: 'void' | 'tuple' | 'integer';
      payloadTypes?: string[];
      payloadComponents?: (FunctionParameter[] | undefined)[];
      value?: number;
      isSingleTuplePayload?: boolean;
    }>;
    isUnitOnly: boolean;
  };
}
/**
 * Represents a function in a smart contract. This is a generalized, internal representation.
 * Adapters map functions from the contract's native interface (e.g., ABI) to this structure.
 */
interface ContractFunction {
  /**
   * A unique identifier for the function, often generated by combining its name and input types
   * to handle function overloading. This ID is used internally by the builder app.
   */
  id: string;
  /**
   * Function name as defined in the contract's native interface.
   */
  name: string;
  /**
   * User-friendly display name for UI, typically derived from `name` or customized.
   */
  displayName: string;
  /**
   * Optional description for documentation or UI tooltips.
   */
  description?: string;
  /**
   * Input parameters for the function, each defined as a `FunctionParameter`.
   */
  inputs: FunctionParameter[];
  /**
   * Optional output parameters for the function, each defined as a `FunctionParameter`.
   * Relevant for view/pure functions or for displaying return values after a transaction.
   */
  outputs?: FunctionParameter[];
  /**
   * Represents the function's state mutability (e.g., 'view', 'pure', 'nonpayable', 'payable' for EVM).
   * While inspired by EVM, adapters for other chains should map their concepts of read-only
   * vs. state-modifying functions to this field or related fields like `modifiesState`.
   * The exact string values may be ecosystem-specific and interpreted by the adapter.
   */
  stateMutability?: string;
  /**
   * The type of the ABI item (e.g., 'function', 'constructor', 'fallback' for EVM).
   * Adapters should map the native function type to this string.
   */
  type: string;
  /**
   * Indicates if the function is expected to modify blockchain state.
   * This is often derived from `stateMutability` but provides a clear boolean flag
   * for UI logic (e.g., determining if a transaction needs to be signed).
   */
  modifiesState: boolean;
}
/**
 * Represents a contract event. This is a generalized, internal representation.
 * Adapters map events from the contract's native interface (e.g., ABI) to this structure.
 */
interface ContractEvent {
  /**
   * A unique identifier for the event, often generated by combining its name and input types.
   */
  id: string;
  /**
   * Event name as defined in the contract's native interface.
   */
  name: string;
  /**
   * Input parameters for the event (indexed and non-indexed), each defined as a `FunctionParameter`.
   */
  inputs: FunctionParameter[];
}
/**
 * Represents the overall schema of a smart contract, including its functions and events.
 * This is a generalized, internal model used by the OpenZeppelin UI ecosystem.
 * Blockchain-specific adapters are responsible for parsing a contract's native interface
 * (e.g., an EVM ABI JSON, Solana IDL) and transforming it into this `ContractSchema` structure.
 * The goal is to provide a consistent data model for applications to work with,
 * abstracting away the specifics of different blockchain ecosystems.
 */
interface ContractSchema {
  /**
   * Optional contract name, which might be derived from metadata or user input.
   */
  name?: string;
  /**
   * The blockchain ecosystem this contract belongs to (e.g., 'evm', 'solana').
   * This helps the builder application select the appropriate adapter and interpret types.
   */
  ecosystem: Ecosystem;
  /**
   * An array of `ContractFunction` objects representing the functions available in the contract.
   */
  functions: ContractFunction[];
  /**
   * Optional array of `ContractEvent` objects representing the events defined in the contract.
   */
  events?: ContractEvent[];
  /**
   * Optional address where the contract is deployed on its respective blockchain.
   */
  address?: string;
  /**
   * Optional chain-specific metadata that adapters can use for enhanced functionality.
   * This allows adapters to store additional context (e.g., Stellar spec entries, EVM ABI metadata)
   * without polluting the core schema interface.
   */
  metadata?: Record<string, unknown>;
}
//#endregion
//#region src/contracts/storage.d.ts
/**
 * Contract Definition Storage and Persistence Types
 *
 * These types support chain-agnostic contract definition storage and comparison functionality
 * while allowing chain-specific implementations in adapters.
 */
/**
 * Metadata associated with a contract definition
 */
interface ContractDefinitionMetadata {
  /** Block explorer URL where definition was fetched from */
  fetchedFrom?: string;
  /** Contract name from verification data */
  contractName?: string;
  /** Compiler version used for contract */
  compilerVersion?: string;
  /** Contract verification status */
  verificationStatus?: 'verified' | 'unverified' | 'unknown';
  /** When the definition was fetched */
  fetchTimestamp?: Date;
  /** Error message if fetch failed */
  fetchError?: string;
  /** Non-cryptographic hash of the raw contract definition for quick comparison */
  definitionHash?: string;
}
/**
 * Result of comparing two contract definitions (raw ABI, IDL, etc.)
 */
interface ContractDefinitionComparisonResult {
  /** Whether the definitions are functionally identical */
  identical: boolean;
  /** List of differences between the definitions */
  differences: ContractDefinitionDifference[];
  /** Overall severity of differences */
  severity: 'none' | 'minor' | 'major' | 'breaking';
  /** Human-readable summary of the comparison */
  summary: string;
}
/**
 * A specific difference between two contract definitions (raw ABI, IDL, etc.)
 */
interface ContractDefinitionDifference {
  /** Type of change */
  type: 'added' | 'removed' | 'modified';
  /** Section of definition that changed (chain-specific: function, event, etc.) */
  section: string;
  /** Name of the changed element */
  name: string;
  /** Detailed description of the change */
  details: string;
  /** Impact level of this change */
  impact: 'low' | 'medium' | 'high';
  /** Original signature (for removed/modified items) */
  oldSignature?: string;
  /** New signature (for added/modified items) */
  newSignature?: string;
}
/**
 * Result of contract definition validation (raw ABI, IDL, etc.)
 */
interface ContractDefinitionValidationResult {
  /** Whether the definition is structurally valid */
  valid: boolean;
  /** List of validation errors */
  errors: string[];
  /** List of validation warnings */
  warnings: string[];
  /** Normalized definition if validation passed */
  normalizedDefinition?: unknown;
}
//#endregion
//#region src/execution/eoa.d.ts
interface EoaExecutionConfig {
  method: 'eoa';
  allowAny: boolean;
  specificAddress?: string;
}
//#endregion
//#region src/execution/multisig.d.ts
interface MultisigExecutionConfig {
  method: 'multisig';
}
//#endregion
//#region src/execution/relayer.d.ts
interface RelayerDetails {
  relayerId: string;
  name: string;
  address: string;
  network: string;
  paused: boolean;
}
interface RelayerDetailsRich extends RelayerDetails {
  systemDisabled: boolean;
  balance?: string;
  nonce?: string;
  pendingTransactionsCount?: number;
  lastConfirmedTransactionTimestamp?: string;
}
interface RelayerExecutionConfig {
  method: 'relayer';
  serviceUrl: string;
  relayer: RelayerDetails;
  transactionOptions?: Record<string, unknown>;
}
//#endregion
//#region src/execution/index.d.ts
/**
 * Execution configuration type (union of all execution methods)
 */
type ExecutionConfig = EoaExecutionConfig | RelayerExecutionConfig | MultisigExecutionConfig;
//#endregion
//#region src/common/enum.d.ts
/**
 * Chain-Agnostic Enum Types
 *
 * This module defines standardized enum types that work across all blockchain adapters.
 * These types represent the UI layer's understanding of enums before they are converted
 * to blockchain-specific formats by individual adapters.
 */
/**
 * Chain-agnostic enum value representation.
 * This is the standardized format that enum fields produce, regardless of the target blockchain.
 * Each adapter transforms this generic format into its blockchain-specific representation.
 *
 * @example Basic Usage
 * ```typescript
 * Unit variant (no payload)
 * const unitEnum: EnumValue = { tag: "None" };
 *
 * Tuple variant (with payload)
 * const tupleEnum: EnumValue = {
 *   tag: "Some",
 *   values: ["hello", 42]
 * };
 * ```
 *
 * @example Cross-Chain Compatibility
 * ```typescript
 * Stellar/Soroban: Transforms to ScVec([Symbol("Active"), payload?])
 * const stellarEnum: EnumValue = { tag: "Active", values: [123] };
 * → ScVec([Symbol("Active"), ScU32(123)])
 *
 * EVM/Solidity: Transforms to integer or struct
 * const evmEnum: EnumValue = { tag: "Pending" };
 * → uint8(0) for simple enums
 * → { variant: 0, data: [...] } for complex enums
 *
 * Solana/Rust: Transforms to Borsh-encoded enum
 * const solanaEnum: EnumValue = { tag: "Ok", values: ["success"] };
 * → Result::Ok("success") via Borsh serialization
 *
 * Complex nested example
 * const complexEnum: EnumValue = {
 *   tag: "TransferResult",
 *   values: [
 *     { tag: "Success", values: ["0x123...", 1000] },
 *     { tag: "Error", values: ["Insufficient funds"] }
 *   ]
 * };
 * ```
 */
interface EnumValue {
  /** The variant name (e.g., 'None', 'Some', 'Success', 'Error') */
  tag: string;
  /** Optional payload values for tuple variants */
  values?: unknown[];
}
/**
 * Type guard to check if a value is an EnumValue
 */
declare function isEnumValue(value: unknown): value is EnumValue;
//#endregion
//#region src/common/map.d.ts
/**
 * Chain-Agnostic Map Types
 *
 * This module defines standardized map types that work across all blockchain adapters.
 * These types represent the UI layer's understanding of maps before they are converted
 * to blockchain-specific formats by individual adapters.
 */
/**
 * Chain-agnostic map entry representation.
 * This is the standardized format that map fields produce, regardless of the target blockchain.
 * Each adapter transforms this generic format into its blockchain-specific representation.
 *
 * @example Basic Usage
 * ```typescript
 * Simple key-value pairs
 * const stringMap: MapEntry[] = [
 *   { key: "name", value: "Alice" },
 *   { key: "age", value: 30 }
 * ];
 *
 * Mixed type pairs
 * const mixedMap: MapEntry[] = [
 *   { key: "config", value: { enabled: true, timeout: 5000 } },
 *   { key: "tags", value: ["production", "api"] }
 * ];
 * ```
 *
 * @example Cross-Chain Compatibility
 * ```typescript
 * Stellar/Soroban: Transforms to SorobanMapEntry[]
 * const stellarMap: MapEntry[] = [
 *   { key: "symbol", value: "USDC" },
 *   { key: "decimals", value: 6 }
 * ];
 * → [
 *   { key: ScSymbol("symbol"), value: ScSymbol("USDC") },
 *   { key: ScSymbol("decimals"), value: ScU32(6) }
 * ]
 *
 * EVM/Solidity: Transforms to struct array (mappings not supported in function params)
 * const evmMap: MapEntry[] = [
 *   { key: "0x123...", value: 1000 },
 *   { key: "0x456...", value: 2000 }
 * ];
 * → AddressAmount[] struct array for function parameters
 *
 * Complex nested maps
 * const nestedMap: MapEntry[] = [
 *   {
 *     key: "user_data",
 *     value: [
 *       { key: "balance", value: "1000" },
 *       { key: "permissions", value: ["read", "write"] }
 *     ]
 *   }
 * ];
 * ```
 */
interface MapEntry {
  /** The map key (can be any serializable type) */
  key: unknown;
  /** The map value (can be any serializable type) */
  value: unknown;
}
/**
 * Type guard to check if a value is a MapEntry
 */
declare function isMapEntry(value: unknown): value is MapEntry;
/**
 * Type guard to check if a value is an array of MapEntry objects
 */
declare function isMapEntryArray(value: unknown): value is MapEntry[];
//#endregion
//#region src/forms/validation.d.ts
/**
 * Validation rules for form fields
 */
interface FieldValidation {
  /**
   * Whether the field is required
   */
  required?: boolean;
  /**
   * Minimum value for number fields
   */
  min?: number;
  /**
   * Maximum value for number fields
   */
  max?: number;
  /**
   * Minimum length for text fields
   */
  minLength?: number;
  /**
   * Maximum length for text fields
   */
  maxLength?: number;
  /**
   * Regular expression pattern for text validation
   */
  pattern?: string | RegExp;
  /**
   * Validation rules that depend on other fields
   */
  conditions?: FieldCondition[];
}
//#endregion
//#region src/forms/form-field.d.ts
/**
 * Form field definition with validation, display, and transformation options
 */
interface FormFieldType<T extends FieldType = FieldType> {
  /**
   * Unique identifier for the field
   */
  id: string;
  /**
   * Parameter name used when submitting to the blockchain
   */
  name: string;
  /**
   * Human-readable label shown in the form
   */
  label: string;
  /**
   * Type of form field to render
   */
  type: T;
  /**
   * Placeholder text shown when empty
   */
  placeholder?: string;
  /**
   * Help text displayed below the field
   */
  helperText?: string;
  /**
   * Additional information required to render or validate the field.
   * Used for field-type-specific configuration (e.g., bytes length constraints).
   */
  metadata?: Record<string, unknown>;
  /**
   * Default value for the field
   */
  defaultValue?: FieldValue<T>;
  /**
   * Validation rules for the field
   */
  validation: FieldValidation;
  /**
   * Options for select, radio, checkbox fields
   */
  options?: {
    label: string;
    value: string;
  }[];
  /**
   * Field width for layout
   */
  width?: 'full' | 'half' | 'third';
  /**
   * Transform functions for data conversion between UI and blockchain
   */
  transforms?: FieldTransforms<FieldValue<T>>;
  /**
   * Conditions that determine when this field should be visible
   */
  visibleWhen?: FieldCondition | FieldCondition[];
  /**
   * Original blockchain parameter type
   * Used to determine compatible field types and for data transformation
   */
  originalParameterType?: string;
  /**
   * Whether this field should be hidden from the rendered form UI
   * @default false
   */
  isHidden?: boolean;
  /**
   * Whether this field's value is fixed and not user-editable
   * If true and isHidden is false, the field might be rendered as read-only
   * @default false
   */
  isHardcoded?: boolean;
  /**
   * The fixed value to use if isHardcoded is true
   * The type should ideally correspond to FieldValue<T>, but using any for initial flexibility
   */
  hardcodedValue?: FieldValue<T>;
  /**
   * Whether the field should be displayed as read-only in the UI.
   * Typically used when isHardcoded is true but isHidden is false.
   * @default false
   */
  readOnly?: boolean;
  /**
   * Components/properties for object and array-object field types.
   * Defines the structure of nested objects.
   */
  components?: FunctionParameter[];
  /**
   * Element type for array fields (e.g., 'text', 'number', 'blockchain-address')
   */
  elementType?: FieldType;
  /**
   * Base configuration for array element fields
   */
  elementFieldConfig?: Partial<FormFieldType>;
  /**
   * Configuration specific to code editor fields
   */
  codeEditorProps?: {
    language?: string;
    placeholder?: string;
    theme?: string;
    height?: string;
    maxHeight?: string;
    performanceThreshold?: number;
  };
  /**
   * Enum metadata for enum field types.
   * Contains information about enum variants and their payload types.
   */
  enumMetadata?: {
    name: string;
    variants: Array<{
      name: string;
      type: 'void' | 'tuple' | 'integer';
      payloadTypes?: string[];
      payloadComponents?: (FunctionParameter[] | undefined)[];
      value?: number;
    }>;
    isUnitOnly: boolean;
  };
  /**
   * Map metadata for map field types.
   * Contains information about key and value types and their field configurations.
   */
  mapMetadata?: {
    keyType?: string;
    valueType?: string;
    keyFieldConfig?: Partial<FormFieldType>;
    valueFieldConfig?: Partial<FormFieldType>;
  };
  /**
   * File upload field properties
   */
  accept?: string;
  maxSize?: number;
  convertToBase64?: boolean;
  /**
   * (Optional) Adapter binding metadata for runtimeSecret fields.
   * Specifies how this field's value should be bound to the adapter for execution.
   * Only applicable when type is 'runtimeSecret'.
   */
  adapterBinding?: {
    /**
     * The key used to reference this field value during execution
     * (e.g., 'organizerSecret' for Midnight)
     */
    key: string;
    /**
     * Optional adapter-specific metadata for runtime secret fields.
     * Adapters can opt-in to additional Customize step controls by supplying metadata.
     */
    metadata?: Record<string, unknown>;
  };
}
//#endregion
//#region src/forms/layout.d.ts
/**
 * Layout configuration for app rendering (fixed values)
 */
interface FormLayout {
  /**
   * Number of columns in the layout grid (fixed to 1)
   */
  columns: 1;
  /**
   * Spacing between form elements (fixed to 'normal')
   */
  spacing: 'normal';
  /**
   * Position of field labels (fixed to 'top')
   */
  labelPosition: 'top';
}
/**
 * Submit button configuration
 */
interface SubmitButtonConfig {
  /**
   * Text displayed on the button
   */
  text: string;
  /**
   * Text displayed while submitting
   */
  loadingText: string;
  /**
   * Custom button style
   */
  variant?: 'primary' | 'secondary' | 'outline';
}
//#endregion
//#region src/forms/schema.d.ts
/**
 * Common properties shared between different form schema types
 */
interface CommonFormProperties {
  /**
   * Form fields
   */
  fields: FormFieldType[];
  /**
   * Layout configuration
   */
  layout: FormLayout;
  /**
   * Validation behavior (fixed values)
   */
  validation: {
    mode: 'onChange';
    showErrors: 'inline';
  };
  /**
   * Theme configuration
   */
  theme?: {
    primaryColor?: string;
    borderRadius?: string;
  };
}
/**
 * Complete form schema used for rendering
 */
interface RenderFormSchema extends CommonFormProperties {
  /**
   * Unique identifier for the form, typically derived from the function ID
   */
  id: string;
  /**
   * Human-readable title for the form
   */
  title: string;
  /**
   * Description explaining the form's purpose
   */
  description?: string;
  /**
   * Submit button configuration
   */
  submitButton: SubmitButtonConfig;
  /**
   * Optional metadata for the form
   */
  metadata?: Record<string, unknown>;
  /**
   * Default values for form fields
   */
  defaultValues?: FormValues;
  /**
   * Function ID for the contract function this form represents.
   * Note: Also stored at top-level in ContractUIRecord for database indexing/queries.
   */
  functionId?: string;
  /**
   * The deployed contract address for this form.
   * Required for widgets like ContractStateWidget and for transaction execution.
   * Note: Also stored at top-level in ContractUIRecord for database indexing/queries.
   */
  contractAddress: string;
  /**
   * Runtime-only secret values keyed by adapter binding key.
   * These are populated from runtimeSecret fields at execution time.
   * Not persisted; for fields like organizer keys that should only exist at runtime.
   * Example: { organizerSecret: '0xabcd...' }
   */
  runtimeSecrets?: Record<string, string>;
}
//#endregion
//#region src/forms/fields.d.ts
/**
 * Type representing form values in a submission or form state
 */
type FormValues = Record<string, unknown>;
/**
 * Field types supported by the renderer
 */
type FieldType = 'text' | 'number' | 'bigint' | 'checkbox' | 'radio' | 'select' | 'textarea' | 'bytes' | 'code-editor' | 'date' | 'email' | 'password' | 'blockchain-address' | 'amount' | 'array' | 'object' | 'array-object' | 'map' | 'url' | 'select-grouped' | 'enum' | 'hidden' | 'file-upload' | 'runtimeSecret';
/**
 * Maps field types to their expected value types
 */
type FieldValue<T extends FieldType> = T extends 'text' | 'email' | 'password' | 'textarea' | 'bytes' | 'code-editor' | 'blockchain-address' | 'bigint' ? string : T extends 'number' | 'amount' ? number : T extends 'checkbox' ? boolean : T extends 'date' ? Date : T extends 'select' | 'radio' ? string : T extends 'enum' ? EnumValue : T extends 'array' ? unknown[] : T extends 'object' ? Record<string, unknown> : T extends 'array-object' ? Record<string, unknown>[] : T extends 'map' ? MapEntry[] : T extends 'runtimeSecret' ? string : unknown;
/**
 * Shared condition interface for both validation and visibility rules
 */
interface FieldCondition {
  /**
   * The field ID this condition depends on
   */
  field: string;
  /**
   * The value to compare against
   */
  value?: unknown;
  /**
   * The comparison operator to use
   */
  operator: 'equals' | 'notEquals' | 'contains' | 'greaterThan' | 'lessThan' | 'matches';
  /**
   * Error message to display when validation fails
   */
  message?: string;
}
/**
 * Transform function interface for converting between UI and blockchain data formats
 */
interface FieldTransforms<T = unknown> {
  /**
   * Function to transform data from blockchain format to UI format
   * Used when displaying values in the form
   */
  input?: (value: T) => unknown;
  /**
   * Function to transform data from UI format to blockchain format
   * Used when submitting the form
   */
  output?: (value: unknown) => T;
}
/**
 * Type for React Hook Form error objects
 */
type FormError = string | {
  message?: string;
  type?: string;
  [key: string]: unknown;
};
/**
 * Props for the top-level TransactionForm component
 */
interface TransactionFormProps {
  /**
   * The form schema to render
   */
  schema: RenderFormSchema;
  /**
   * The full contract schema containing function definitions and details
   * for the target contract on the specific blockchain.
   * Required by the adapter to format transaction data correctly.
   */
  contractSchema: ContractSchema;
  /**
   * The chain-specific adapter instance, pre-configured for a specific network.
   * It should contain the networkConfig internally.
   */
  adapter: ContractAdapter;
  /**
   * Optional flag indicating if a wallet is currently connected.
   * Used to control UI elements like the submit button.
   * If not provided, components might assume not connected or use other means if available.
   */
  isWalletConnected?: boolean;
  /**
   * Execution configuration for the transaction
   */
  executionConfig?: ExecutionConfig;
}
//#endregion
//#region src/networks/config.d.ts
/**
 * Base interface with common properties shared across all network configurations
 */
interface BaseNetworkConfig {
  /**
   * Unique identifier for the network, e.g., 'ethereum-mainnet', 'polygon-amoy'
   */
  id: string;
  /**
   * User-friendly network name, e.g., 'Ethereum Mainnet'
   */
  name: string;
  /**
   * The blockchain ecosystem this network belongs to (discriminant for the union type)
   */
  ecosystem: Ecosystem;
  /**
   * Parent network name, e.g., 'ethereum', 'polygon'
   */
  network: string;
  /**
   * Network type/environment: 'mainnet', 'testnet', or 'devnet'
   */
  type: NetworkType;
  /**
   * Explicit flag for easy filtering of test networks
   */
  isTestnet: boolean;
  /**
   * The constant name under which this specific network configuration object
   * is exported from its adapter package's network index file.
   * Used by the export system to dynamically import the correct config.
   * Example: 'ethereumMainnet', 'ethereumSepolia'
   */
  exportConstName: string;
  /**
   * Base URL for the block explorer (common across ecosystems)
   */
  explorerUrl?: string;
  /**
   * Optional React component for the network icon.
   * This allows embedding the icon component directly in the network config,
   * avoiding dynamic imports and improving build performance.
   * If provided, this takes precedence over the icon string.
   */
  iconComponent?: React$1.ComponentType<{
    size?: number;
    className?: string;
    variant?: 'mono' | 'branded';
  }>;
  /**
   * A unique identifier for the specific explorer API service used by this network.
   * This is used by the AppConfigService to fetch the correct API key.
   * Examples: "etherscan-mainnet", "polygonscan-mainnet", "bscscan-mainnet"
   * Should align with keys in AppRuntimeConfig.networkServiceConfigs
   */
  primaryExplorerApiIdentifier?: string;
  /**
   * Optional indexer GraphQL HTTP endpoint
   * Used for querying historical blockchain data (e.g., access control events)
   */
  indexerUri?: string;
  /**
   * Optional indexer GraphQL WebSocket endpoint
   * Used for real-time blockchain data subscriptions
   */
  indexerWsUri?: string;
  /**
   * Optional GraphQL endpoint for the access control indexer.
   * Used by the access control module for historical queries and role discovery.
   * Feature-specific field — distinct from the general-purpose `indexerUri` which
   * may serve different purposes per ecosystem (e.g., Midnight chain indexer).
   */
  accessControlIndexerUrl?: string;
}
/**
 * EVM-specific network configuration
 */
interface EvmNetworkConfig extends BaseNetworkConfig {
  ecosystem: 'evm';
  /**
   * EVM chain ID, e.g., 1 for Ethereum Mainnet, 11155111 for Sepolia
   */
  chainId: number;
  /**
   * JSON-RPC endpoint for the network (can be a base URL if API key is resolved from env)
   */
  rpcUrl: string;
  /**
   * Native currency information
   */
  nativeCurrency: {
    name: string;
    symbol: string;
    decimals: number;
  };
  /**
   * Optional icon name for the network (for use with @web3icons/react or similar)
   * If not provided, the network property will be used as a fallback
   */
  apiUrl?: string;
  /**
   * Whether this network supports Etherscan V2 API (default: true for all Etherscan-compatible explorers)
   */
  supportsEtherscanV2?: boolean;
  /**
   * Whether this network's explorer requires an API key for basic operations (default: true)
   * Some explorers like routescan.io provide free access without API keys
   */
  requiresExplorerApiKey?: boolean;
  /**
   * Optional chain-specific configuration object for this network.
   * For EVM networks, this should be a Viem Chain object.
   * If provided, this will be used directly by the chain's clients.
   * If not provided, a fallback or minimal custom chain object might be used.
   */
  viemChain?: unknown;
}
/**
 * Solana-specific network configuration
 */
interface SolanaNetworkConfig extends BaseNetworkConfig {
  ecosystem: 'solana';
  /**
   * RPC endpoint for Solana network
   */
  rpcEndpoint: string;
  /**
   * Solana transaction confirmation commitment level
   */
  commitment: 'confirmed' | 'finalized';
}
/**
 * Stellar-specific network configuration
 */
interface StellarNetworkConfig extends BaseNetworkConfig {
  ecosystem: 'stellar';
  /**
   * Horizon server URL (for Stellar Classic operations)
   */
  horizonUrl: string;
  /**
   * Soroban RPC server URL (for smart contract operations)
   */
  sorobanRpcUrl: string;
  /**
   * Stellar network passphrase
   */
  networkPassphrase: string;
}
/**
 * Midnight-specific network configuration
 */
interface MidnightNetworkConfig extends BaseNetworkConfig {
  ecosystem: 'midnight';
  /**
   * Midnight Network ID enum value
   * Maps to @midnight-ntwrk/midnight-js-network-id NetworkId enum
   * Single source of truth for network identity when mapping is not provided.
   */
  /**
   * Mapping of numeric network ID to its enum name.
   * Example: { 2: 'TestNet' }
   */
  networkId: Partial<Record<2 | 3 | 1 | 0, 'TestNet' | 'MainNet' | 'DevNet' | 'Undeployed'>>;
  /**
   * RPC endpoints for the Midnight network
   */
  rpcEndpoints?: {
    default?: string;
    [key: string]: string | undefined;
  };
}
/**
 * Polkadot execution type - currently supports EVM, with future Substrate support planned
 */
type PolkadotExecutionType = 'evm' | 'substrate';
/**
 * Polkadot network category for UI grouping
 */
type PolkadotNetworkCategory = 'hub' | 'parachain';
/**
 * Polkadot relay chain identifier
 */
type PolkadotRelayChain = 'polkadot' | 'kusama';
/**
 * Polkadot-specific network configuration
 * Extends EVM config since all current Polkadot networks are EVM-compatible.
 * Adds Polkadot-specific fields for execution type routing and UI grouping.
 */
interface PolkadotNetworkConfig extends Omit<EvmNetworkConfig, 'ecosystem'> {
  ecosystem: 'polkadot';
  /**
   * Execution type for this network
   * - 'evm': EVM-compatible (current support)
   * - 'substrate': Native Substrate/Wasm (future support)
   */
  executionType: PolkadotExecutionType;
  /**
   * Network category for UI grouping
   * - 'hub': Polkadot/Kusama Hub (Asset Hub) - prioritized in UI
   * - 'parachain': Parachains like Moonbeam, Moonriver
   */
  networkCategory: PolkadotNetworkCategory;
  /**
   * Optional relay chain identifier
   * - 'polkadot': Connected to Polkadot relay chain
   * - 'kusama': Connected to Kusama relay chain
   * - undefined: Testnet or standalone
   */
  relayChain?: PolkadotRelayChain;
}
/**
 * Union type for all network configurations
 * This allows us to handle network configurations in a type-safe manner
 */
type NetworkConfig = EvmNetworkConfig | SolanaNetworkConfig | StellarNetworkConfig | MidnightNetworkConfig | PolkadotNetworkConfig;
/**
 * Type guard to check if a network config is for EVM
 * @param config The network configuration to check
 * @returns True if the config is for EVM
 */
declare const isEvmNetworkConfig: (config: NetworkConfig) => config is EvmNetworkConfig;
/**
 * Type guard to check if a network config is for Solana
 * @param config The network configuration to check
 * @returns True if the config is for Solana
 */
declare const isSolanaNetworkConfig: (config: NetworkConfig) => config is SolanaNetworkConfig;
/**
 * Type guard to check if a network config is for Stellar
 * @param config The network configuration to check
 * @returns True if the config is for Stellar
 */
declare const isStellarNetworkConfig: (config: NetworkConfig) => config is StellarNetworkConfig;
/**
 * Type guard to check if a network config is for Midnight
 * @param config The network configuration to check
 * @returns True if the config is for Midnight
 */
declare const isMidnightNetworkConfig: (config: NetworkConfig) => config is MidnightNetworkConfig;
/**
 * Type guard to check if a network config is for Polkadot
 * @param config The network configuration to check
 * @returns True if the config is for Polkadot
 */
declare const isPolkadotNetworkConfig: (config: NetworkConfig) => config is PolkadotNetworkConfig;
//#endregion
//#region src/networks/validation.d.ts
/**
 * Validate a network configuration
 * @param config The network configuration to validate
 * @returns True if the configuration is valid
 */
declare function validateNetworkConfig(config: NetworkConfig): boolean;
//#endregion
//#region src/transactions/status.d.ts
/**
 * Defines the possible states for a transaction lifecycle.
 */
type TxStatus = 'idle' | 'pendingSignature' | 'pendingConfirmation' | 'pendingRelayer' | 'success' | 'error';
/**
 * Represents the details passed along with a status update.
 * It can contain the following optional fields:
 * - `transactionId`: Provided by a relayer.
 * - `txHash`: Provided by a direct broadcast.
 * - `title`: Optional UI copy for a better chain-specific UX.
 * - `message`: Optional UI copy for a better chain-specific UX.
 */
type TransactionStatusUpdate = {
  transactionId?: string;
  txHash?: string;
  title?: string;
  message?: string;
};
//#endregion
//#region src/adapters/access-control.d.ts
/**
 * Capabilities of an access control contract
 */
interface AccessControlCapabilities {
  /** Whether the contract implements Ownable */
  hasOwnable: boolean;
  /** Whether the contract supports two-step transfer with expiration (e.g. Stellar Ownable) */
  hasTwoStepOwnable: boolean;
  /** Whether the contract implements AccessControl */
  hasAccessControl: boolean;
  /** Whether the contract supports two-step admin transfer with expiration (e.g. Stellar AccessControl) */
  hasTwoStepAdmin: boolean;
  /** Whether roles can be enumerated directly (vs requiring event reconstruction) */
  hasEnumerableRoles: boolean;
  /** Whether historical data is available (via indexer or similar) */
  supportsHistory: boolean;
  /** Whether the contract has been verified against OpenZeppelin interfaces */
  verifiedAgainstOZInterfaces: boolean;
  /** Optional notes about capabilities or limitations */
  notes?: string[];
  /** Contract supports renouncing ownership (e.g., EVM Ownable.renounceOwnership) */
  hasRenounceOwnership?: boolean;
  /** Contract supports self-revocation of roles (e.g., EVM AccessControl.renounceRole) */
  hasRenounceRole?: boolean;
  /** Contract supports canceling pending admin transfers (e.g., EVM AccessControlDefaultAdminRules) */
  hasCancelAdminTransfer?: boolean;
  /** Contract supports changing/rolling back admin transfer delay (e.g., EVM AccessControlDefaultAdminRules) */
  hasAdminDelayManagement?: boolean;
}
/**
 * Ownership state enumeration for two-step Ownable contracts
 *
 * - 'owned': Contract has an active owner with no pending transfer
 * - 'pending': Ownership transfer initiated, awaiting acceptance
 * - 'expired': Previous transfer attempt expired without completion
 * - 'renounced': Contract has no owner (ownership was renounced)
 */
type OwnershipState = 'owned' | 'pending' | 'expired' | 'renounced';
/**
 * Pending ownership transfer details for two-step Ownable contracts
 *
 * Contains information about an initiated but not yet accepted ownership transfer.
 */
interface PendingOwnershipTransfer {
  /** Address designated to receive ownership */
  pendingOwner: string;
  /**
   * Block/ledger number by which transfer must be accepted.
   * Required for chains with expiration (e.g., Stellar).
   * Omitted for chains without expiration (e.g., EVM Ownable2Step).
   */
  expirationBlock?: number;
  /** ISO8601 timestamp of transfer initiation (from indexer) */
  initiatedAt?: string;
  /** Transaction ID of the initiation (from indexer) */
  initiatedTxId?: string;
  /** Block/ledger number at which transfer was initiated (from indexer) */
  initiatedBlock?: number;
}
/**
 * Ownership information
 *
 * Extended to support two-step Ownable contracts with pending transfer state.
 *
 * @example Owned state (basic)
 * ```typescript
 * { owner: '0xABC...123', state: 'owned' }
 * ```
 *
 * @example Pending state
 * ```typescript
 * {
 *   owner: '0xABC...123',
 *   state: 'pending',
 *   pendingTransfer: {
 *     pendingOwner: '0xDEF...456',
 *     expirationBlock: 12345678,
 *     initiatedAt: '2025-12-10T10:30:00Z',
 *   }
 * }
 * ```
 *
 * @example Renounced state
 * ```typescript
 * { owner: null, state: 'renounced' }
 * ```
 */
interface OwnershipInfo {
  /** The current owner address, or null if no owner */
  owner: string | null;
  /** Current ownership state (optional for backward compatibility) */
  state?: OwnershipState;
  /** Pending transfer details (present when state is 'pending') */
  pendingTransfer?: PendingOwnershipTransfer;
}
/**
 * Admin state enumeration for two-step AccessControl admin transfer
 *
 * - 'active': Contract has an active admin with no pending transfer
 * - 'pending': Admin transfer initiated, awaiting acceptance
 * - 'expired': Previous transfer attempt expired without completion
 * - 'renounced': Contract has no admin (admin role was renounced)
 */
type AdminState = 'active' | 'pending' | 'expired' | 'renounced';
/**
 * Pending admin transfer details for two-step AccessControl contracts
 *
 * Contains information about an initiated but not yet accepted admin transfer.
 */
interface PendingAdminTransfer {
  /** Address designated to receive admin role */
  pendingAdmin: string;
  /**
   * Block/ledger number by which transfer must be accepted.
   * Required for chains with expiration (e.g., Stellar).
   * Omitted for chains without expiration (e.g., EVM Ownable2Step).
   * For EVM AccessControlDefaultAdminRules, stores the accept schedule
   * (UNIX timestamp in seconds) from `pendingDefaultAdmin()`.
   */
  expirationBlock?: number;
  /** ISO8601 timestamp of transfer initiation (from indexer) */
  initiatedAt?: string;
  /** Transaction ID of the initiation (from indexer) */
  initiatedTxId?: string;
  /** Block/ledger number at which transfer was initiated (from indexer) */
  initiatedBlock?: number;
}
/**
 * Admin information for AccessControl contracts
 *
 * Extended to support two-step admin transfer with pending transfer state.
 *
 * @example Active state (basic)
 * ```typescript
 * { admin: 'GABC...123', state: 'active' }
 * ```
 *
 * @example Pending state
 * ```typescript
 * {
 *   admin: 'GABC...123',
 *   state: 'pending',
 *   pendingTransfer: {
 *     pendingAdmin: 'GDEF...456',
 *     expirationBlock: 12345678,
 *     initiatedAt: '2025-12-10T10:30:00Z',
 *   }
 * }
 * ```
 *
 * @example Renounced state
 * ```typescript
 * { admin: null, state: 'renounced' }
 * ```
 */
interface AdminInfo {
  /** The current admin address, or null if no admin */
  admin: string | null;
  /** Current admin state (optional for backward compatibility) */
  state?: AdminState;
  /** Pending transfer details (present when state is 'pending') */
  pendingTransfer?: PendingAdminTransfer;
  /**
   * Admin transfer delay information (populated by EVM adapter from on-chain defaultAdminDelay).
   * Omitted by adapters that don't support delay management (e.g., Stellar).
   */
  delayInfo?: AdminDelayInfo;
}
/**
 * Admin transfer delay information for AccessControlDefaultAdminRules contracts.
 *
 * Provides current delay value and any pending delay change.
 * Populated by the EVM adapter from on-chain `defaultAdminDelay()` and
 * `pendingDefaultAdminDelay()` reads.
 */
interface AdminDelayInfo {
  /** Current admin transfer delay in seconds */
  currentDelay: number;
  /** Pending delay change, if any */
  pendingDelay?: {
    /** New delay value in seconds */
    newDelay: number;
    /** When the new delay takes effect (UNIX timestamp in seconds) */
    effectAt: number;
  };
}
/**
 * Chain-agnostic expiration metadata provided by the adapter.
 * Tells the UI whether expiration is needed, its format, and display labels.
 *
 * Used by transfer dialogs to conditionally show/hide expiration input
 * and by pending transfer displays to show adapter-driven labels.
 */
interface ExpirationMetadata {
  /**
   * Whether the UI needs to show expiration for this transfer type.
   * - 'required': User must provide expiration (e.g., Stellar ledger number)
   * - 'none': No expiration concept (e.g., EVM Ownable2Step)
   * - 'contract-managed': Expiration is managed by the contract, displayed for info only
   *   (e.g., EVM AccessControlDefaultAdminRules accept schedule)
   */
  mode: 'required' | 'none' | 'contract-managed';
  /** Display label for the expiration field (e.g., "Expiration Ledger", "Accept Schedule") */
  label?: string;
  /** Unit description (e.g., "ledger number", "UNIX timestamp") */
  unit?: string;
  /** Current value for 'contract-managed' mode (e.g., the accept schedule timestamp) */
  currentValue?: number;
}
/**
 * Role identifier
 */
interface RoleIdentifier {
  /** Stable identifier for the role (e.g., name, bytes, symbol rendered to string) */
  id: string;
  /** Optional human-friendly label for the role */
  label?: string;
}
/**
 * Role assignment with members
 */
interface RoleAssignment {
  /** The role identifier */
  role: RoleIdentifier;
  /** Array of addresses/accounts that have this role */
  members: string[];
}
/**
 * Enriched role member with grant metadata
 * Used when historical data is available via indexer
 */
interface EnrichedRoleMember {
  /** The member's address */
  address: string;
  /** ISO8601 timestamp of when the role was granted (undefined if indexer unavailable) */
  grantedAt?: string;
  /** Transaction ID of the grant operation */
  grantedTxId?: string;
  /** Block/ledger number of the grant operation */
  grantedLedger?: number;
}
/**
 * Enriched role assignment with detailed member information
 * Includes grant timestamps when indexer data is available
 */
interface EnrichedRoleAssignment {
  /** The role identifier */
  role: RoleIdentifier;
  /** Array of enriched member information */
  members: EnrichedRoleMember[];
}
/**
 * Snapshot of access control state at a point in time
 */
interface AccessSnapshot {
  /** Array of role assignments */
  roles: RoleAssignment[];
  /** Optional ownership information */
  ownership?: OwnershipInfo;
}
/**
 * Change type for history events
 *
 * - GRANTED: Role was granted to an account
 * - REVOKED: Role was revoked from an account
 * - ROLE_ADMIN_CHANGED: Role's admin role was changed
 * - OWNERSHIP_TRANSFER_STARTED: Two-step ownership transfer initiated
 * - OWNERSHIP_TRANSFER_COMPLETED: Two-step ownership transfer accepted
 * - OWNERSHIP_RENOUNCED: Ownership was renounced (owner set to null/zero)
 * - ADMIN_TRANSFER_INITIATED: Two-step admin transfer initiated
 * - ADMIN_TRANSFER_COMPLETED: Two-step admin transfer accepted
 * - ADMIN_RENOUNCED: Admin role was renounced
 * - ADMIN_TRANSFER_CANCELED: Pending admin transfer was canceled (EVM AccessControlDefaultAdminRules)
 * - ADMIN_DELAY_CHANGE_SCHEDULED: Admin transfer delay change was scheduled (EVM AccessControlDefaultAdminRules)
 * - ADMIN_DELAY_CHANGE_CANCELED: Pending admin delay change was canceled (EVM AccessControlDefaultAdminRules)
 * - UNKNOWN: Unrecognized event type from indexer (indicates schema mismatch)
 */
type HistoryChangeType = 'GRANTED' | 'REVOKED' | 'ROLE_ADMIN_CHANGED' | 'OWNERSHIP_TRANSFER_STARTED' | 'OWNERSHIP_TRANSFER_COMPLETED' | 'OWNERSHIP_RENOUNCED' | 'ADMIN_TRANSFER_INITIATED' | 'ADMIN_TRANSFER_COMPLETED' | 'ADMIN_TRANSFER_CANCELED' | 'ADMIN_RENOUNCED' | 'ADMIN_DELAY_CHANGE_SCHEDULED' | 'ADMIN_DELAY_CHANGE_CANCELED' | 'UNKNOWN';
/**
 * History entry for role changes (adapter-specific, when history is supported)
 */
interface HistoryEntry {
  /** The role that was changed */
  role: RoleIdentifier;
  /** The account that was granted or revoked */
  account: string;
  /** Type of change */
  changeType: HistoryChangeType;
  /** Transaction identifier */
  txId: string;
  /** Optional timestamp (ISO8601 format) */
  timestamp?: string;
  /** Optional ledger/sequence number */
  ledger?: number;
}
/**
 * Pagination info for cursor-based pagination
 */
interface PageInfo {
  /** Whether there are more items after the current page */
  hasNextPage: boolean;
  /** Cursor to use for fetching the next page */
  endCursor?: string;
}
/**
 * Paginated result for history queries
 */
interface PaginatedHistoryResult {
  /** Array of history entries */
  items: HistoryEntry[];
  /** Pagination information */
  pageInfo: PageInfo;
}
/**
 * Options for querying history with pagination
 */
interface HistoryQueryOptions {
  /** Filter by role identifier */
  roleId?: string;
  /** Filter by account address */
  account?: string;
  /** Filter by change type (grant, revoke, or ownership transfer) */
  changeType?: HistoryChangeType;
  /** Filter by transaction ID (exact match) */
  txId?: string;
  /** Filter by timestamp - return events on or after this time (format: 'YYYY-MM-DDTHH:mm:ss', no timezone) */
  timestampFrom?: string;
  /** Filter by timestamp - return events on or before this time (format: 'YYYY-MM-DDTHH:mm:ss', no timezone) */
  timestampTo?: string;
  /** Filter by ledger/block number (exact match) */
  ledger?: number;
  /** Maximum number of items to return (page size) */
  limit?: number;
  /** Cursor for fetching the next page */
  cursor?: string;
}
/**
 * Result of an operation (grant, revoke, transfer)
 */
interface OperationResult {
  /** Transaction/operation identifier */
  id: string;
}
/**
 * Service interface for access control operations
 */
interface AccessControlService {
  /**
   * Get the capabilities of the contract
   * @param contractAddress The contract address to check
   * @returns Promise resolving to capabilities
   */
  getCapabilities(contractAddress: string): Promise<AccessControlCapabilities>;
  /**
   * Get the current owner of the contract
   * @param contractAddress The contract address
   * @returns Promise resolving to ownership information
   */
  getOwnership(contractAddress: string): Promise<OwnershipInfo>;
  /**
   * Get current role assignments
   * @param contractAddress The contract address
   * @returns Promise resolving to array of role assignments
   */
  getCurrentRoles(contractAddress: string): Promise<RoleAssignment[]>;
  /**
   * Get current role assignments with enriched member information
   *
   * Returns role assignments with metadata about when each member was granted
   * the role. If the indexer is unavailable, gracefully degrades to returning
   * members without timestamp information.
   *
   * @param contractAddress The contract address
   * @returns Promise resolving to array of enriched role assignments
   */
  getCurrentRolesEnriched(contractAddress: string): Promise<EnrichedRoleAssignment[]>;
  /**
   * Grant a role to an account
   * @param contractAddress The contract address
   * @param roleId The role identifier
   * @param account The account to grant the role to
   * @param executionConfig Execution configuration specifying method (eoa, relayer, etc.)
   * @param onStatusChange Optional callback for status updates
   * @param runtimeApiKey Optional session-only API key for methods like Relayer
   * @returns Promise resolving to operation result
   */
  grantRole(contractAddress: string, roleId: string, account: string, executionConfig: ExecutionConfig, onStatusChange?: (status: TxStatus, details: TransactionStatusUpdate) => void, runtimeApiKey?: string): Promise<OperationResult>;
  /**
   * Revoke a role from an account
   * @param contractAddress The contract address
   * @param roleId The role identifier
   * @param account The account to revoke the role from
   * @param executionConfig Execution configuration specifying method (eoa, relayer, etc.)
   * @param onStatusChange Optional callback for status updates
   * @param runtimeApiKey Optional session-only API key for methods like Relayer
   * @returns Promise resolving to operation result
   */
  revokeRole(contractAddress: string, roleId: string, account: string, executionConfig: ExecutionConfig, onStatusChange?: (status: TxStatus, details: TransactionStatusUpdate) => void, runtimeApiKey?: string): Promise<OperationResult>;
  /**
   * Transfer ownership of the contract
   *
   * For two-step Ownable contracts (e.g., Stellar), the expirationBlock parameter
   * specifies when the pending transfer expires. The pending owner must call
   * acceptOwnership() before this block/ledger to complete the transfer.
   *
   * @param contractAddress The contract address
   * @param newOwner The new owner address
   * @param expirationBlock For two-step transfers: the block/ledger number by which the transfer
   *   must be accepted. Required for chains with two-step Ownable (e.g., Stellar).
   *   Optional for EVM (no expiration mechanism).
   * @param executionConfig Execution configuration specifying method (eoa, relayer, etc.)
   * @param onStatusChange Optional callback for status updates
   * @param runtimeApiKey Optional session-only API key for methods like Relayer
   * @returns Promise resolving to operation result
   */
  transferOwnership(contractAddress: string, newOwner: string, expirationBlock: number | undefined, executionConfig: ExecutionConfig, onStatusChange?: (status: TxStatus, details: TransactionStatusUpdate) => void, runtimeApiKey?: string): Promise<OperationResult>;
  /**
   * Accept a pending ownership transfer (two-step transfer)
   *
   * Must be called by the pending owner (the address specified in transferOwnership)
   * before the expiration block/ledger. Only applicable for contracts that support
   * two-step ownership transfer (check `hasTwoStepOwnable` capability).
   *
   * The on-chain contract validates:
   * 1. Caller is the pending owner
   * 2. Transfer has not expired
   *
   * @param contractAddress The contract address
   * @param executionConfig Execution configuration specifying method (eoa, relayer, etc.)
   * @param onStatusChange Optional callback for status updates
   * @param runtimeApiKey Optional session-only API key for methods like Relayer
   * @returns Promise resolving to operation result with transaction ID
   */
  acceptOwnership?(contractAddress: string, executionConfig: ExecutionConfig, onStatusChange?: (status: TxStatus, details: TransactionStatusUpdate) => void, runtimeApiKey?: string): Promise<OperationResult>;
  /**
   * Get the current admin and admin transfer state of an AccessControl contract
   *
   * Retrieves the current admin and checks for pending two-step admin transfers.
   * Only applicable for contracts that support two-step admin transfer
   * (check `hasTwoStepAdmin` capability).
   *
   * @param contractAddress The contract address
   * @returns Promise resolving to admin information with state
   */
  getAdminInfo?(contractAddress: string): Promise<AdminInfo>;
  /**
   * Initiate an admin role transfer (two-step transfer)
   *
   * For two-step AccessControl contracts, this initiates a transfer that must be
   * accepted by the pending admin before the expiration ledger. Only applicable
   * for contracts that support two-step admin transfer (check `hasTwoStepAdmin` capability).
   *
   * @param contractAddress The contract address
   * @param newAdmin The new admin address
   * @param expirationBlock The block/ledger number by which the transfer must be accepted.
   *   Required for chains with expiration (e.g., Stellar). Optional for EVM
   *   (the contract's built-in delay determines the accept schedule).
   * @param executionConfig Execution configuration specifying method (eoa, relayer, etc.)
   * @param onStatusChange Optional callback for status updates
   * @param runtimeApiKey Optional session-only API key for methods like Relayer
   * @returns Promise resolving to operation result with transaction ID
   */
  transferAdminRole?(contractAddress: string, newAdmin: string, expirationBlock: number | undefined, executionConfig: ExecutionConfig, onStatusChange?: (status: TxStatus, details: TransactionStatusUpdate) => void, runtimeApiKey?: string): Promise<OperationResult>;
  /**
   * Accept a pending admin transfer (two-step transfer)
   *
   * Must be called by the pending admin (the address specified in transferAdminRole)
   * before the expiration block/ledger. Only applicable for contracts that support
   * two-step admin transfer (check `hasTwoStepAdmin` capability).
   *
   * The on-chain contract validates:
   * 1. Caller is the pending admin
   * 2. Transfer has not expired
   *
   * @param contractAddress The contract address
   * @param executionConfig Execution configuration specifying method (eoa, relayer, etc.)
   * @param onStatusChange Optional callback for status updates
   * @param runtimeApiKey Optional session-only API key for methods like Relayer
   * @returns Promise resolving to operation result with transaction ID
   */
  acceptAdminTransfer?(contractAddress: string, executionConfig: ExecutionConfig, onStatusChange?: (status: TxStatus, details: TransactionStatusUpdate) => void, runtimeApiKey?: string): Promise<OperationResult>;
  /**
   * Renounce ownership of the contract. Irreversible.
   *
   * Only available when `hasRenounceOwnership` capability is true.
   * After execution, `owner()` returns the zero address and ownership state becomes 'renounced'.
   *
   * @param contractAddress The contract address
   * @param executionConfig Execution configuration specifying method (eoa, relayer, etc.)
   * @param onStatusChange Optional callback for status updates
   * @param runtimeApiKey Optional session-only API key for methods like Relayer
   * @returns Promise resolving to operation result
   */
  renounceOwnership?(contractAddress: string, executionConfig: ExecutionConfig, onStatusChange?: (status: TxStatus, details: TransactionStatusUpdate) => void, runtimeApiKey?: string): Promise<OperationResult>;
  /**
   * Renounce a role held by the connected account. Self-revocation only.
   *
   * Only available when `hasRenounceRole` capability is true.
   * The `account` parameter must match the connected wallet address (the contract
   * verifies caller === account on-chain to prevent accidental renouncement).
   *
   * @param contractAddress The contract address
   * @param roleId The role identifier to renounce
   * @param account The caller's address for confirmation (must match msg.sender on-chain)
   * @param executionConfig Execution configuration specifying method (eoa, relayer, etc.)
   * @param onStatusChange Optional callback for status updates
   * @param runtimeApiKey Optional session-only API key for methods like Relayer
   * @returns Promise resolving to operation result
   */
  renounceRole?(contractAddress: string, roleId: string, account: string, executionConfig: ExecutionConfig, onStatusChange?: (status: TxStatus, details: TransactionStatusUpdate) => void, runtimeApiKey?: string): Promise<OperationResult>;
  /**
   * Cancel a pending admin transfer.
   *
   * Only available when `hasCancelAdminTransfer` capability is true.
   * Must be called by the current default admin.
   *
   * @param contractAddress The contract address
   * @param executionConfig Execution configuration specifying method (eoa, relayer, etc.)
   * @param onStatusChange Optional callback for status updates
   * @param runtimeApiKey Optional session-only API key for methods like Relayer
   * @returns Promise resolving to operation result
   */
  cancelAdminTransfer?(contractAddress: string, executionConfig: ExecutionConfig, onStatusChange?: (status: TxStatus, details: TransactionStatusUpdate) => void, runtimeApiKey?: string): Promise<OperationResult>;
  /**
   * Change the admin transfer delay. The change is itself delayed.
   *
   * Only available when `hasAdminDelayManagement` capability is true.
   * Schedules a new delay value; the change takes effect after the current delay period.
   *
   * @param contractAddress The contract address
   * @param newDelay The new delay in seconds
   * @param executionConfig Execution configuration specifying method (eoa, relayer, etc.)
   * @param onStatusChange Optional callback for status updates
   * @param runtimeApiKey Optional session-only API key for methods like Relayer
   * @returns Promise resolving to operation result
   */
  changeAdminDelay?(contractAddress: string, newDelay: number, executionConfig: ExecutionConfig, onStatusChange?: (status: TxStatus, details: TransactionStatusUpdate) => void, runtimeApiKey?: string): Promise<OperationResult>;
  /**
   * Rollback a pending admin delay change.
   *
   * Only available when `hasAdminDelayManagement` capability is true.
   * Cancels a scheduled delay change, keeping the original delay in effect.
   *
   * @param contractAddress The contract address
   * @param executionConfig Execution configuration specifying method (eoa, relayer, etc.)
   * @param onStatusChange Optional callback for status updates
   * @param runtimeApiKey Optional session-only API key for methods like Relayer
   * @returns Promise resolving to operation result
   */
  rollbackAdminDelay?(contractAddress: string, executionConfig: ExecutionConfig, onStatusChange?: (status: TxStatus, details: TransactionStatusUpdate) => void, runtimeApiKey?: string): Promise<OperationResult>;
  /**
   * Get expiration metadata for a transfer type.
   *
   * Returns adapter-driven expiration semantics telling the UI whether to show
   * an expiration input, what label to use, and whether expiration is managed
   * by the contract itself.
   *
   * @param contractAddress The contract address
   * @param transferType Whether this is an 'ownership' or 'admin' transfer
   * @returns Promise resolving to expiration metadata
   */
  getExpirationMetadata?(contractAddress: string, transferType: 'ownership' | 'admin'): Promise<ExpirationMetadata>;
  /**
   * Export a snapshot of current access control state
   * @param contractAddress The contract address
   * @returns Promise resolving to access snapshot
   */
  exportSnapshot(contractAddress: string): Promise<AccessSnapshot>;
  /**
   * Get history of role changes (if supported)
   *
   * Supports cursor-based pagination. Use `pageInfo.endCursor` from the response
   * as the `cursor` option in subsequent calls to fetch more pages.
   *
   * @param contractAddress The contract address
   * @param options Optional filtering and pagination options
   * @returns Promise resolving to paginated history result, or empty result if not supported
   */
  getHistory(contractAddress: string, options?: HistoryQueryOptions): Promise<PaginatedHistoryResult>;
}
//#endregion
//#region src/adapters/export.d.ts
/**
 * Minimal subset of BuilderFormConfig needed for adapter export context.
 * Avoids circular dependencies by not importing the full builder types.
 */
interface BuilderFormConfigLike {
  functionId: string;
  contractAddress: string;
  [key: string]: any;
}
/**
 * Context provided to adapters during export to enable artifact bundling.
 */
interface AdapterExportContext {
  /** The form configuration from the builder */
  formConfig: BuilderFormConfigLike;
  /** The full contract schema */
  contractSchema: ContractSchema;
  /** The network configuration for the selected network */
  networkConfig: NetworkConfig;
  /**
   * Optional adapter-specific artifacts stored during contract loading.
   * For Midnight: privateStateId, contractModule, witnessCode, verifierKeys, etc.
   */
  artifacts?: Record<string, unknown> | null;
  /**
   * Original contract definition (e.g., TypeScript .d.ts for Midnight).
   * Stored separately from the parsed schema for export purposes.
   */
  definitionOriginal?: string | null;
}
/**
 * Result returned by adapters to bundle files and initialization code.
 */
interface AdapterExportBootstrap {
  /**
   * Files to add to the exported project.
   * Key: relative path (e.g., 'src/midnight/artifacts.ts')
   * Value: file content as string
   */
  files?: Record<string, string>;
  /**
   * Binary files to add to the exported project (e.g., ZIP files).
   * Key: relative path (e.g., 'public/midnight/contract.zip')
   * Value: binary content as Uint8Array or Blob
   */
  binaryFiles?: Record<string, Uint8Array | Blob>;
  /**
   * Optional import statements to inject into main.tsx
   * Example: ["import { midnightArtifacts } from './midnight/artifacts';"]
   */
  imports?: string[];
  /**
   * Optional initialization code to run after adapter construction.
   * This code will be injected inside the resolveAdapter function,
   * right after the adapter instance is created.
   *
   * Example:
   * ```
   * if (typeof (adapter as any).loadContractWithMetadata === "function") {
   *   await (adapter as any).loadContractWithMetadata(midnightArtifacts);
   * }
   * ```
   */
  initAfterAdapterConstruct?: string;
}
//#endregion
//#region src/adapters/ui-enhancements.d.ts
/**
 * Configuration for excluding specific wallet components provided by an adapter for its 'custom' kit.
 */
interface ComponentExclusionConfig {
  /**
   * Array of component keys (e.g., 'ConnectButton', 'NetworkSwitcher') to exclude
   * when the adapter provides its 'custom' set of UI components.
   */
  exclude?: Array<keyof EcosystemWalletComponents>;
}
/**
 * Configuration for the desired UI kit to be used by an adapter.
 */
interface UiKitConfiguration {
  /** Name of the chosen UI kit (e.g., 'rainbowkit', 'connectkit'). Use 'custom' for adapter-provided default components or 'none' to disable adapter UI. */
  kitName: UiKitName;
  /**
   * Kit-specific configuration options.
   * This is an open-ended object to allow adapters to define their own configuration.
   * The adapter is responsible for validating and type-checking these values.
   */
  kitConfig: FormValues;
  customCode?: string;
}
/**
 * A generic hook function type that can be called with any parameters and returns any result.
 * This allows us to maintain flexibility for adapter implementations while avoiding the use of 'any'.
 */
type GenericHook<TParams extends unknown[] = [], TResult = unknown> = (...args: TParams) => TResult;
/**
 * Defines the shape of facade hooks provided by an adapter for its ecosystem.
 * These typically wrap underlying library hooks (e.g., from wagmi for EVM).
 *
 * We use generic hook signatures to allow direct use of library hooks
 * without tightly coupling to their specific parameter and return types.
 *
 * Adapters implementing these facade hooks are responsible for mapping their native
 * library's return values to a conventional set of properties expected by consumers.
 * This ensures that UI components using these facade hooks can remain chain-agnostic.
 *
 * @example For `useSwitchChain`:
 * Consumers will expect an object like:
 * ```typescript
 * {
 *   switchChain: (args: { chainId: number }) => void; // Function to initiate the switch
 *   isPending: boolean;                             // True if the switch is in progress
 *   error: Error | null;                            // Error object if the switch failed
 *   // chains?: Chain[]; // Optional: array of available chains, if provided by underlying hook
 * }
 * ```
 * If an adapter's underlying library uses `isLoading` instead of `isPending`,
 * the adapter's facade implementation for `useSwitchChain` should map `isLoading` to `isPending`.
 *
 * @example For `useAccount`:
 * Consumers will expect an object like:
 * ```typescript
 * {
 *   isConnected: boolean;
 *   address?: string;
 *   chainId?: number;
 *   // Other properties like `connector`, `status` might also be conventionally expected.
 * }
 * ```
 */
interface EcosystemSpecificReactHooks {
  useAccount?: GenericHook;
  useConnect?: GenericHook;
  useDisconnect?: GenericHook;
  useSwitchChain?: GenericHook;
  useChainId?: GenericHook;
  useChains?: GenericHook;
  useBalance?: GenericHook;
  useSendTransaction?: GenericHook;
  useWaitForTransactionReceipt?: GenericHook;
  useSignMessage?: GenericHook;
  useSignTypedData?: GenericHook;
}
/**
 * Props for the ecosystem-specific UI context provider component.
 */
interface EcosystemReactUiProviderProps {
  children: React$1.ReactNode;
}
/**
 * Size variants available for wallet UI components.
 * Maps to standard button sizing conventions.
 */
type WalletComponentSize = 'sm' | 'default' | 'lg' | 'xl';
/**
 * Visual style variants for wallet UI components.
 */
type WalletComponentVariant = 'default' | 'outline' | 'ghost' | 'secondary';
/**
 * Base props interface that all component props should be compatible with.
 * Components can extend this with additional props as needed.
 *
 * Adapters implementing wallet components should respect these props:
 * - `className`: Additional CSS classes to apply
 * - `size`: Controls the component's size (height, padding, font-size)
 * - `variant`: Controls the visual style (colors, borders)
 * - `fullWidth`: When true, component expands to fill container width
 */
interface BaseComponentProps {
  /** Additional CSS classes to apply to the component */
  className?: string;
  /** Size variant for the component */
  size?: WalletComponentSize;
  /** Visual style variant */
  variant?: WalletComponentVariant;
  /** If true, component expands to fill its container width */
  fullWidth?: boolean;
}
/**
 * Defines standardized names for commonly needed wallet UI components
 * that an adapter might provide.
 */
interface EcosystemWalletComponents {
  ConnectButton?: React$1.ComponentType<BaseComponentProps>;
  AccountDisplay?: React$1.ComponentType<BaseComponentProps>;
  NetworkSwitcher?: React$1.ComponentType<BaseComponentProps>;
}
/**
 * Valid component keys for EcosystemWalletComponents.
 * Used for type-safe runtime validation of component exclusion lists.
 */
declare const ECOSYSTEM_WALLET_COMPONENT_KEYS: ["ConnectButton", "AccountDisplay", "NetworkSwitcher"];
type EcosystemWalletComponentKey = (typeof ECOSYSTEM_WALLET_COMPONENT_KEYS)[number];
type NativeConfigLoader = (relativePath: string) => Promise<Record<string, unknown> | null>;
/**
 * Describes a UI kit available for a specific adapter, providing all necessary
 * metadata for the builder app to render its configuration options.
 */
interface AvailableUiKit {
  /** A unique identifier for the UI kit (e.g., 'rainbowkit'). */
  id: string;
  /** The display name of the UI kit (e.g., 'RainbowKit'). */
  name: string;
  /** An optional link to the UI kit's documentation. */
  linkToDocs?: string;
  /**
   * An optional description of the UI kit and its configuration.
   * This can contain HTML for formatting (e.g., code blocks, links).
   */
  description?: string;
  /** An array of form fields required to configure the UI kit. */
  configFields: FormFieldType[];
  /**
   * If true, indicates that this UI kit supports advanced configuration via a code editor.
   * @default false
   */
  hasCodeEditor?: boolean;
  /**
   * The default boilerplate code to display if `hasCodeEditor` is true.
   */
  defaultCode?: string;
}
type UiKitName = 'rainbowkit' | 'connectkit' | 'appkit' | 'stellar-wallets-kit' | 'custom' | 'none';
/**
 * Badge variant for function decorations
 */
type FunctionBadgeVariant = 'info' | 'warning' | 'neutral';
/**
 * Badge displayed next to a function in the UI
 */
interface FunctionBadge {
  /** Display text for the badge */
  text: string;
  /** Visual variant of the badge */
  variant?: FunctionBadgeVariant;
  /** Optional tooltip text shown on hover */
  tooltip?: string;
}
/**
 * Decoration for a contract function (badges, notes, etc.)
 */
interface FunctionDecoration {
  /** Array of badges to display next to the function */
  badges?: FunctionBadge[];
  /** Optional note to display when the function is selected */
  note?: {
    /** Optional title for the note */
    title?: string;
    /** Body text of the note */
    body: string;
  };
  /**
   * (Optional) If true, the form should auto-add a runtime secret field (if adapter provides getRuntimeFieldBinding).
   * Used to mark functions like organizer-only circuits that require credentials.
   * User can customize (hide, hardcode) or remove the field after auto-add.
   */
  requiresRuntimeSecret?: boolean;
}
/**
 * Map of function IDs to their decorations
 */
type FunctionDecorationsMap = Record<string, FunctionDecoration>;
//#endregion
//#region src/adapters/base.d.ts
/**
 * Information about a dynamic type pattern supported by an adapter.
 * Dynamic patterns are types that require pattern matching rather than exact lookup,
 * such as arrays, generics, and composite types.
 */
interface DynamicTypePattern {
  /**
   * Pattern identifier/name (e.g., 'array', 'option', 'tuple', 'map')
   */
  name: string;
  /**
   * Human-readable syntax example (e.g., 'T[]', 'Option<T>', 'Map<K,V>')
   */
  syntax: string;
  /**
   * The FieldType this pattern maps to.
   * - A specific FieldType string if the pattern always maps to that type
   * - 'unwrap' if the pattern resolves to its inner type (e.g., Option<T> → T's field type)
   * - null if the mapping depends on the inner type (e.g., Vec<Primitive> → array, Vec<Complex> → array-object)
   */
  mapsTo: FieldType | 'unwrap' | null;
  /**
   * Brief description of how this pattern is handled
   */
  description: string;
}
/**
 * Complete type mapping information for an adapter.
 * This provides full visibility into both primitive and dynamic type support.
 */
interface TypeMappingInfo {
  /**
   * Primitive types with direct mappings to field types.
   * Keys are blockchain type names (e.g., 'address', 'uint256', 'U128'),
   * values are the default FieldType for each.
   */
  primitives: Record<string, FieldType>;
  /**
   * Dynamic type patterns that the adapter recognizes.
   * These patterns are handled through pattern matching rather than exact lookup.
   */
  dynamicPatterns: DynamicTypePattern[];
}
type ExecutionMethodType = 'eoa' | 'relayer' | 'multisig';
interface ExecutionMethodDetail {
  type: ExecutionMethodType;
  name: string;
  description?: string;
  disabled?: boolean;
}
/**
 * Represents a wallet connector option available for connection.
 */
type Connector = {
  id: string;
  name: string;
};
/**
 * Base wallet connection status interface with universal properties.
 * Chain-specific adapters should extend this interface with their specific fields.
 */
interface WalletConnectionStatus {
  /** Core connection state - always present for backward compatibility */
  isConnected: boolean;
  /** Wallet address - always present when connected */
  address?: string;
  /** Chain/network ID - format may vary by chain (number for EVM, string for others) */
  chainId?: string | number;
  /** Enhanced connection states for better UX */
  isConnecting?: boolean;
  isDisconnected?: boolean;
  isReconnecting?: boolean;
  /** Detailed status string */
  status?: 'connected' | 'connecting' | 'disconnected' | 'reconnecting';
  /** Connector/wallet information - universal across all chains */
  connector?: {
    id: string;
    name?: string;
    type?: string;
  };
}
/**
 * Adapter-declared networking configuration form.
 * Rendered by the application using DynamicFormField components.
 */
interface NetworkServiceForm {
  /** Stable identifier for the service (e.g., 'rpc', 'explorer', 'indexer') */
  id: string;
  /** User-facing label for tabs/sections */
  label: string;
  /** Optional description shown above the form */
  description?: string;
  /** Whether this service supports connection testing via testNetworkServiceConnection */
  supportsConnectionTest?: boolean;
  /** Form schema fields using the standard FormFieldType */
  fields: FormFieldType[];
}
/**
 * Configuration for an adapter-driven dynamic property input in the Customize step.
 * When provided via getRuntimeFieldBinding().propertyNameInput, the builder renders
 * a TextField control and persists the value under field.adapterBinding.metadata[metadataKey].
 */
interface RuntimeSecretPropertyInput {
  /** Metadata key to persist the value under field.adapterBinding.metadata */
  metadataKey: string;
  /** Optional label override for the input */
  label?: string;
  /** Optional helper text to display below the input */
  helperText?: string;
  /** Optional placeholder text */
  placeholder?: string;
  /**
   * Optional default value to seed when the field is auto-added.
   * If metadata[metadataKey] already has a value, that value takes precedence.
   */
  defaultValue?: string;
  /** Whether to render the control (default: true when metadataKey provided) */
  visible?: boolean;
}
/**
 * Minimal adapter interface for the renderer and contract interaction
 *
 * This is the base interface that all chain-specific adapters must implement.
 * It defines the core functionality needed for app rendering and contract interaction.
 */
interface ContractAdapter {
  /**
   * The network configuration this adapter instance is configured for.
   */
  readonly networkConfig: NetworkConfig;
  /**
   * The initial kitName from AppConfigService at the time of adapter construction.
   * This provides a baseline kitName preference from the application's static/global configuration.
   * It defaults to 'custom' if no specific kitName is found in AppConfigService.
   * This value is stored on the instance to inform the first call to configureUiKit if no programmatic overrides are given.
   */
  readonly initialAppServiceKitName: UiKitConfiguration['kitName'];
  /**
   * Load a contract from a source (address or JSON ABI string).
   * The adapter instance should be pre-configured with the necessary network context.
   *
   * @param source - The contract address or JSON ABI string.
   * @returns A promise resolving to the ContractSchema.
   */
  loadContract(source: string | Record<string, unknown>): Promise<ContractSchema>;
  /**
   * (Optional) Load a contract with source metadata information.
   * Returns both the contract schema and information about how it was loaded.
   *
   * @param source - The contract artifacts/source data.
   * @returns A promise resolving to both ContractSchema and source metadata.
   */
  loadContractWithMetadata?(source: string | Record<string, unknown>): Promise<{
    schema: ContractSchema;
    source: 'fetched' | 'manual';
    metadata?: {
      fetchedFrom?: string;
      contractName?: string;
      verificationStatus?: 'verified' | 'unverified' | 'unknown';
      fetchTimestamp?: Date;
      definitionHash?: string;
    };
    /** Chain-agnostic proxy information */
    proxyInfo?: ProxyInfo;
  }>;
  /**
   * Get only the functions that modify state (writable functions)
   * @param contractSchema The contract schema to filter
   * @returns Array of writable functions
   */
  getWritableFunctions(contractSchema: ContractSchema): ContractSchema['functions'];
  /**
   * Map a blockchain-specific parameter type to a form field type
   * @param parameterType The blockchain parameter type
   * @returns The appropriate form field type
   */
  mapParameterTypeToFieldType(parameterType: string): FieldType;
  /**
   * Format transaction data for the specific chain,
   * considering submitted inputs and field configurations.
   *
   * @param contractSchema - The schema of the contract containing the function.
   * @param functionId - The ID of the function being called
   * @param submittedInputs - The data submitted from the rendered form fields
   * @param fields - The configuration for all fields
   * @returns The formatted data payload for the blockchain transaction, suitable for signAndBroadcast.
   */
  formatTransactionData(contractSchema: ContractSchema, functionId: string, submittedInputs: Record<string, unknown>, fields: FormFieldType[]): unknown;
  /**
   * Sign and broadcast a transaction
   *
   * @param transactionData - The formatted transaction data
   * @param executionConfig - Configuration for the execution method (e.g., relayer settings)
   * @param onStatusChange - Callback for transaction status updates
   * @param runtimeApiKey - Optional API key or token for execution method (e.g., relayer API key)
   * @param runtimeSecret - Optional runtime secret required by the adapter (e.g., organizer key for privacy circuits)
   * @returns Transaction hash upon successful broadcast, and optionally the execution result if the ecosystem supports it
   */
  signAndBroadcast: (transactionData: unknown, executionConfig: ExecutionConfig, onStatusChange: (status: string, details: TransactionStatusUpdate) => void, runtimeApiKey?: string, runtimeSecret?: string) => Promise<{
    txHash: string;
    result?: unknown;
  }>;
  /**
   * Validate a blockchain address for this chain
   *
   * @param address - The address to validate
   * @param addressType - Optional specific address type to validate (chain-specific)
   * @returns Whether the address is valid for this chain
   */
  isValidAddress(address: string, addressType?: string): boolean;
  /**
   * Returns details for execution methods supported by this chain adapter.
   */
  getSupportedExecutionMethods(): Promise<ExecutionMethodDetail[]>;
  /**
   * Validates the complete execution configuration object against the
   * requirements and capabilities of this chain adapter.
   *
   * @param config - The execution configuration object
   * @returns A promise resolving to true if valid, or an error message if invalid
   */
  validateExecutionConfig(config: ExecutionConfig): Promise<true | string>;
  /**
   * Determines if a function is a view/pure function (read-only)
   * @param functionDetails The function details
   * @returns True if the function is read-only
   */
  isViewFunction(functionDetails: ContractFunction): boolean;
  /**
   * Optionally filter which view functions are safe to auto-query without user input.
   * Adapters can exclude chain-specific management/admin functions that are likely
   * to revert or require special permissions.
   * If not implemented, the UI will assume all parameterless view functions are safe.
   */
  filterAutoQueryableFunctions?(functions: ContractFunction[]): ContractFunction[];
  /**
   * Queries a view function on a contract.
   * The adapter instance should be pre-configured with the necessary network context.
   *
   * @param contractAddress The contract address
   * @param functionId The function identifier
   * @param params Optional parameters for the function call
   * @param contractSchema Optional pre-loaded contract schema
   * @returns The query result
   */
  queryViewFunction(contractAddress: string, functionId: string, params?: unknown[], contractSchema?: ContractSchema): Promise<unknown>;
  /**
   * Formats a function result for display
   * @param result The raw result from the contract
   * @param functionDetails The function details
   * @returns Formatted result ready for display
   */
  formatFunctionResult(result: unknown, functionDetails: ContractFunction): string;
  /**
   * Get field types compatible with a specific parameter type
   *
   * @param parameterType - The blockchain parameter type
   * @returns Array of compatible field types
   */
  getCompatibleFieldTypes(parameterType: string): FieldType[];
  /**
   * Generate default field configuration for a function parameter
   *
   * @param parameter - The function parameter to convert to a form field
   * @param contractSchema - Optional contract schema for additional context (e.g., spec entries)
   * @returns A form field configuration with appropriate defaults
   */
  generateDefaultField(parameter: FunctionParameter, contractSchema?: ContractSchema): FormFieldType;
  /**
   * Indicates if this adapter supports wallet connection
   *
   * @returns Whether wallet connection is supported by this adapter
   */
  supportsWalletConnection(): boolean;
  /**
   * Gets the list of available wallet connectors supported by this adapter.
   *
   * The UI can use this list to present connection options to the user.
   * Each connector should have a unique ID and a user-friendly name.
   *
   * @returns A promise resolving to an array of available Connector objects.
   *          Returns an empty array if wallet connection is not supported or no connectors are found.
   */
  getAvailableConnectors(): Promise<Connector[]>;
  /**
   * Initiates the wallet connection process for a specific, chosen connector.
   *
   * @param connectorId The unique identifier (e.g., Wagmi's `uid`) of the connector
   *                    selected by the user from the list provided by `getAvailableConnectors`.
   * @returns A promise resolving to an object indicating the connection result:
   *          - `connected`: `true` if successful, `false` otherwise.
   *          - `address`: The connected wallet address if successful.
   *          - `error`: An error message if the connection failed.
   */
  connectWallet(connectorId: string): Promise<{
    connected: boolean;
    address?: string;
    error?: string;
  }>;
  /**
   * Disconnects the currently connected wallet
   * @returns Disconnection result object
   */
  disconnectWallet(): Promise<{
    disconnected: boolean;
    error?: string;
  }>;
  /**
   * Gets current wallet connection status
   *
   * @returns Rich status object with detailed connection state and address information
   */
  getWalletConnectionStatus(): WalletConnectionStatus;
  /**
   * Gets a blockchain explorer URL for an address in this chain.
   * The adapter instance should be pre-configured with the necessary network context.
   *
   * @param address - The address to get the explorer URL for
   * @returns A URL to view the address on a blockchain explorer, or null if not supported
   */
  getExplorerUrl(address: string): string | null;
  /**
   * Optional method to subscribe to wallet connection changes
   *
   * @param callback Function to call when connection status changes
   * @returns Cleanup function to unsubscribe
   */
  onWalletConnectionChange?(callback: (status: WalletConnectionStatus, previousStatus: WalletConnectionStatus) => void): () => void;
  /**
   * Gets a blockchain explorer URL for a transaction in this chain.
   * The adapter instance should be pre-configured with the necessary network context.
   *
   * @param txHash - The hash of the transaction to get the explorer URL for
   * @returns A URL to view the transaction on a blockchain explorer, or null if not supported
   */
  getExplorerTxUrl?(txHash: string): string | null;
  /**
   * Gets the current block/ledger number from the blockchain.
   *
   * This is used for:
   * - Calculating appropriate expiration blocks for time-sensitive operations
   * - Validating expiration parameters before submitting transactions
   * - Determining if pending operations have expired
   *
   * @returns A promise resolving to the current block/ledger number
   * @throws Error if the RPC call fails
   *
   * @example
   * ```typescript
   * const currentBlock = await adapter.getCurrentBlock();
   * // Set expiration to ~1 hour from now
   * const expirationBlock = currentBlock + 300; // ~300 blocks at 12s/block for EVM
   * ```
   */
  getCurrentBlock(): Promise<number>;
  /**
   * (Optional) Waits for a transaction to be confirmed on the blockchain.
   *
   * @param txHash - The hash of the transaction to wait for.
   * @returns A promise resolving to the final status and receipt/error.
   */
  waitForTransactionConfirmation?(txHash: string): Promise<{
    status: 'success' | 'error';
    receipt?: unknown;
    error?: Error;
  }>;
  /**
   * (Optional) Configures the UI kit to be used by this adapter instance.
   * This setting can influence the components and providers returned by other UI facilitation methods.
   * It's typically called by the application during initialization based on global settings or user preferences.
   *
   * @param config - The UI kit configuration, specifying the `kitName` (e.g., 'custom', 'rainbowkit')
   *                 and any `kitConfig` options specific to that kit.
   * @param options - Optional additional options including callback functions for loading configs
   */
  configureUiKit?(config: UiKitConfiguration, options?: {
    /** Optional generic function to load configuration modules by path from the consuming app's source. */
    loadUiKitNativeConfig?: (relativePath: string) => Promise<Record<string, unknown> | null>;
  }): void | Promise<void>;
  /**
   * (Optional) Returns a React component that sets up the necessary UI context for this adapter's ecosystem.
   * For instance, an EVM adapter might return a component that provides WagmiProvider and QueryClientProvider.
   * If a third-party UI kit is configured (via `configureUiKit`), this provider component should also
   * compose that kit's specific provider(s) (e.g., RainbowKitProvider).
   * The returned component is expected to accept `children` props.
   *
   * @returns A React functional component that accepts children, or `undefined` if UI context facilitation is not supported or not configured.
   */
  getEcosystemReactUiContextProvider?(): React.ComponentType<EcosystemReactUiProviderProps> | undefined;
  /**
   * (Optional) Returns an object containing facade React hooks for common wallet and blockchain interactions
   * specific to this adapter's ecosystem. These hooks are designed to be used within the context
   * established by the component from `getEcosystemReactUiContextProvider`.
   * For an EVM adapter, these would typically wrap `wagmi/react` hooks to abstract direct library usage.
   *
   * @returns An object of facade hooks, or `undefined` if not supported.
   */
  getEcosystemReactHooks?(): EcosystemSpecificReactHooks | undefined;
  /**
   * (Optional) Returns an object containing standardized, ready-to-use wallet UI components for this ecosystem.
   * The actual components are sourced either from a configured third-party UI kit (specified via `configureUiKit`)
   * or are basic custom implementations provided by the adapter itself if `kitName` is 'custom' or undefined.
   * Examples include `ConnectButton`, `AccountDisplay`, `NetworkSwitcher`.
   *
   * @returns An object mapping standard component names to React components, or `undefined` if not supported or configured.
   */
  getEcosystemWalletComponents?(): EcosystemWalletComponents | undefined;
  /**
   * Gets the list of available UI kits supported by this adapter.
   *
   * @returns A promise resolving to an array of available UiKit objects.
   */
  getAvailableUiKits(): Promise<AvailableUiKit[]>;
  /**
   * (Optional) Returns adapter-provided UI label overrides for chain-specific verbiage.
   * Keys are consumed by chain-agnostic UI to avoid ecosystem-centric terms.
   * Example keys used today (non-exhaustive):
   * - relayerConfigTitle
   * - relayerConfigActiveDesc
   * - relayerConfigInactiveDesc
   * - relayerConfigPresetTitle
   * - relayerConfigPresetDesc
   * - relayerConfigCustomizeBtn
   * - detailsTitle
   * - network
   * - relayerId
   * - active
   * - paused
   * - systemDisabled
   * - balance
   * - nonce
   * - pending
   * - lastTransaction
   */
  getUiLabels?(): Record<string, string> | undefined;
  /**
   * Generates adapter-specific wallet configuration files for export.
   *
   * @param uiKitConfig The selected UI kit configuration from the builder.
   * @returns A promise resolving to a record of file paths to their content.
   */
  getExportableWalletConfigFiles?(uiKitConfig?: UiKitConfiguration): Promise<Record<string, string>>;
  /**
   * Returns the set of supported contract definition providers for this adapter.
   * The UI can use this to present a provider selection without hardcoding
   * chain-specific values. When not implemented, the UI may fall back to
   * application configuration or hide the selector.
   *
   * Example keys: "etherscan", "sourcify".
   */
  getSupportedContractDefinitionProviders?(): Array<{
    key: string;
    label?: string;
  }>;
  /**
   * Returns a schema for the inputs required to define a contract.
   * This allows adapters to specify what information they need (e.g., address, ABI, artifacts).
   *
   * @returns An array of FormFieldType objects representing the required inputs.
   */
  getContractDefinitionInputs(): FormFieldType[];
  /**
   * Gets the list of available relayers for a specific service.
   *
   * @param serviceUrl The URL of the relayer service.
   * @param accessToken The access token for the relayer service.
   * @returns A promise that resolves to an array of relayer details.
   */
  getRelayers(serviceUrl: string, accessToken: string): Promise<RelayerDetails[]>;
  /**
   * Gets detailed information about a specific relayer including balance and status.
   *
   * @param serviceUrl The URL of the relayer service.
   * @param accessToken The access token for the relayer service.
   * @param relayerId The unique identifier of the relayer.
   * @returns A promise that resolves to enhanced relayer details including balance, status, and other metrics.
   */
  getRelayer(serviceUrl: string, accessToken: string, relayerId: string): Promise<RelayerDetailsRich>;
  /**
   * (Optional) Returns a React component for configuring relayer transaction options.
   * This component should render chain-specific transaction options (e.g., gas settings for EVM).
   * The component will receive props for getting and setting the transaction options.
   *
   * @returns A React component for relayer options configuration, or undefined if not supported.
   */
  getRelayerOptionsComponent?(): React.ComponentType<{
    options: Record<string, unknown>;
    onChange: (options: Record<string, unknown>) => void;
  }> | undefined;
  /**
   * (Optional) Validates an RPC endpoint configuration.
   * Chain-specific validation logic to ensure the RPC URL and configuration are valid.
   *
   * @param rpcConfig - The RPC provider configuration to validate
   * @returns A promise resolving to true if valid, false otherwise
   */
  validateRpcEndpoint?(rpcConfig: UserRpcProviderConfig): Promise<boolean>;
  /**
   * (Optional) Tests the connection to an RPC endpoint.
   * Performs a health check on the RPC endpoint to verify connectivity and measure latency.
   *
   * @param rpcConfig - The RPC provider configuration to test
   * @returns A promise resolving to connection test results
   */
  testRpcConnection?(rpcConfig: UserRpcProviderConfig): Promise<{
    success: boolean;
    latency?: number;
    error?: string;
  }>;
  /**
   * (Optional) Validates a user-provided explorer configuration.
   * Chain-specific validation logic to ensure the explorer URLs and API key are valid.
   *
   * @param explorerConfig - The explorer configuration to validate
   * @returns A promise resolving to true if valid, false otherwise
   */
  validateExplorerConfig?(explorerConfig: UserExplorerConfig): Promise<boolean>;
  /**
   * (Optional) Tests the connection to an explorer API.
   * Performs a health check on the explorer API to verify the API key works and measure latency.
   *
   * @param explorerConfig - The explorer configuration to test
   * @returns A promise resolving to connection test results
   */
  testExplorerConnection?(explorerConfig: UserExplorerConfig): Promise<{
    success: boolean;
    latency?: number;
    error?: string;
  }>;
  /**
   * (Optional) Compares two contract schemas and returns detailed analysis.
   * Provides chain-specific comparison logic for detecting differences between schemas.
   *
   * @param storedSchema - The previously stored contract schema as JSON string
   * @param freshSchema - The newly fetched contract schema as JSON string
   * @returns A promise resolving to detailed comparison results
   */
  compareContractDefinitions?(storedSchema: string, freshSchema: string): Promise<{
    identical: boolean;
    differences: Array<{
      type: 'added' | 'removed' | 'modified';
      section: string;
      name: string;
      details: string;
      impact: 'low' | 'medium' | 'high';
      oldSignature?: string;
      newSignature?: string;
    }>;
    severity: 'none' | 'minor' | 'major' | 'breaking';
    summary: string;
  }>;
  /**
   * (Optional) Validates contract definition structure and format for this chain.
   * Provides chain-specific validation logic for contract definitions.
   *
   * @param definition - The contract definition as JSON string to validate
   * @returns Validation result with errors and warnings
   */
  validateContractDefinition?(definition: string): {
    valid: boolean;
    errors: string[];
    warnings: string[];
  };
  /**
   * (Optional) Creates a deterministic hash of a contract definition for quick comparison.
   * Provides chain-specific normalization and hashing for contract definitions.
   *
   * @param definition - The contract definition as JSON string to hash
   * @returns A deterministic hash string for quick comparison
   */
  hashContractDefinition?(definition: string): string;
  /**
   * (Optional) Provides adapter-specific files and initialization code for exported applications.
   * This method enables adapters to bundle ecosystem-specific artifacts (e.g., Midnight contract artifacts)
   * into exported applications in a chain-agnostic manner.
   *
   * The method receives context including form configuration, contract schema, network configuration,
   * and any adapter-specific artifacts stored during contract loading.
   *
   * Example use case: Midnight adapter bundles ZK proof artifacts, contract modules, and witness code
   * needed for offline transaction execution in exported apps.
   *
   * @param context - Export context containing form config, schema, network, and artifacts
   * @returns Bootstrap configuration with files to include and initialization code, or null if not needed
   */
  getExportBootstrapFiles?(context: AdapterExportContext): Promise<AdapterExportBootstrap | null>;
  /**
   * Optional: guide when and how large artifacts should be persisted.
   */
  getArtifactPersistencePolicy?(): {
    mode: 'immediate' | 'deferredUntilFunctionSelected';
    sizeThresholdBytes?: number;
  } | undefined;
  /**
   * Optional: prepare trimmed artifacts when a function is chosen.
   */
  prepareArtifactsForFunction?(args: {
    functionId: string;
    currentArtifacts: Record<string, unknown>;
    definitionOriginal?: string | null;
  }): Promise<{
    persistableArtifacts?: Record<string, unknown>;
    publicAssets?: Record<string, Uint8Array | Blob>;
    bootstrapSource?: Record<string, unknown>;
  }>;
  /**
   * (Optional) Returns metadata for a runtime secret field required by the ecosystem.
   * This allows adapters to declare that forms should include a runtime-only secret field
   * (not persisted, chain-specific e.g., organizer key for Midnight).
   *
   * When implemented, the builder will auto-add a 'runtimeSecret' field to forms for organizer-only functions,
   * and the field can be customized like any other (hidden, hardcoded, etc.).
   * The field value is passed to the adapter at execution time via the runtimeSecrets bag.
   *
   * @returns Binding metadata with key and display info, or undefined if not needed.
   */
  getRuntimeFieldBinding?(): {
    /**
     * Unique key to bind the field value during execution (e.g., 'organizerSecret')
     */
    key: string;
    /**
     * Display label for the field
     */
    label: string;
    /**
     * Optional helper text for the field
     */
    helperText?: string;
    /**
     * Optional adapter-specific metadata for the runtimeSecret field.
     * The builder does not interpret keys here; it simply persists them with the field.
     */
    metadata?: Record<string, unknown>;
    /**
     * Optional generic configuration for an additional "property name" input that the builder
     * may render under the runtime secret field. This remains chain-agnostic: the adapter
     * specifies which metadata key to use and optional UI hints.
     */
    propertyNameInput?: RuntimeSecretPropertyInput;
  } | undefined;
  /**
   * (Optional) Returns a map of function IDs to their decorations.
   * This allows adapters to add badges, notes, or other UI elements to specific functions.
   *
   * @returns A map of function IDs to their decorations.
   */
  getFunctionDecorations?(): Promise<FunctionDecorationsMap | undefined>;
  /**
   * Returns network service forms (e.g., RPC, Explorer, Indexer) this adapter supports.
   * The UI renders these via DynamicFormField without chain-specific UI code.
   */
  getNetworkServiceForms(): NetworkServiceForm[];
  /**
   * Optional validation for a given service configuration prior to save.
   */
  validateNetworkServiceConfig?(serviceId: string, values: Record<string, unknown>): Promise<boolean>;
  /**
   * Optional connectivity test for a given service configuration.
   */
  testNetworkServiceConnection?(serviceId: string, values: Record<string, unknown>): Promise<{
    success: boolean;
    latency?: number;
    error?: string;
  }>;
  /**
   * Returns the default configuration values for a network service.
   * Used for proactive health checks when no user overrides are configured.
   *
   * Each adapter MUST implement this method to provide default endpoint values
   * for the services it supports. This enables the UI to perform health checks
   * on network services when a network is selected.
   *
   * @param serviceId - The service identifier (e.g., 'rpc', 'indexer', 'explorer')
   * @returns The default configuration values matching the service's form fields,
   *          or null if the service is not supported or has no defaults
   *
   * @example
   * // Midnight adapter returning indexer defaults
   * getDefaultServiceConfig('indexer') // { httpUrl: 'https://...', wsUrl: 'wss://...' }
   *
   * // EVM adapter returning RPC defaults
   * getDefaultServiceConfig('rpc') // { rpcUrl: 'https://...' }
   */
  getDefaultServiceConfig(serviceId: string): Record<string, unknown> | null;
  /**
   * Optional accessor for the Access Control service.
   * Returns an AccessControlService instance if the adapter supports access control operations.
   *
   * @returns The AccessControlService instance, or undefined if not supported
   */
  getAccessControlService?(): AccessControlService | undefined;
  /**
   * Returns complete type mapping information for this adapter.
   *
   * This method enables consuming applications to:
   * - Dynamically render type documentation/demos for all supported types
   * - Understand both primitive types and dynamic type patterns
   * - Validate that a type is supported before calling mapParameterTypeToFieldType()
   * - Keep UIs in sync with adapter capabilities without hardcoding
   *
   * @returns TypeMappingInfo containing primitives and dynamic patterns
   */
  getTypeMappingInfo(): TypeMappingInfo;
}
//#endregion
//#region src/adapters/contract-state.d.ts
/**
 * Extension interface for adapters that support contract state querying
 *
 * This interface defines the capabilities needed for querying and displaying
 * contract state data from read-only (view/pure) functions.
 */
interface ContractStateCapabilities {
  /**
   * Determines if a function is a view/pure function (read-only)
   *
   * @param functionDetails - The function details
   * @returns True if the function is read-only
   */
  isViewFunction(functionDetails: ContractFunction): boolean;
  /**
   * Queries a view function on a contract.
   * The adapter instance should be pre-configured with the necessary network context.
   *
   * @param contractAddress - The contract address
   * @param functionId - The function identifier
   * @param params - Optional parameters for the function call
   * @param contractSchema - Optional pre-loaded contract schema
   * @returns The query result, properly formatted
   */
  queryViewFunction(contractAddress: string, functionId: string, params?: unknown[], contractSchema?: ContractSchema): Promise<unknown>;
  /**
   * Formats a function result for display
   *
   * @param result - The raw result from the contract
   * @param functionDetails - The function details
   * @returns Formatted result ready for display
   */
  formatFunctionResult(result: unknown, functionDetails: ContractFunction): string | Record<string, unknown>;
}
//#endregion
//#region src/adapters/config.d.ts
/**
 * Types related to blockchain adapters configuration.
 * @packageDocumentation
 */
/**
 * Vite configuration fragments for adapters with special build requirements
 */
interface ViteConfigInfo {
  /**
   * Import statements needed in vite.config.ts
   * @example ["import wasm from 'vite-plugin-wasm';", "import topLevelAwait from 'vite-plugin-top-level-await';"]
   */
  imports: string[];
  /**
   * Initialization code to run at the top of defineConfig
   * @example "const midnightConfig = getMidnightViteConfig({ wasm, topLevelAwait });"
   */
  configInit?: string;
  /**
   * Plugin entries to add to the plugins array
   * @example "...midnightConfig.plugins,"
   */
  plugins?: string;
  /**
   * Dedupe configuration
   * @example "dedupe: [...(midnightConfig.resolve?.dedupe || [])],"
   */
  dedupe?: string;
  /**
   * OptimizeDeps configuration
   * @example { include: "...", exclude: "..." }
   */
  optimizeDeps?: {
    include?: string;
    exclude?: string;
  };
}
/**
 * Configuration for blockchain adapters.
 * This interface defines the structure for adapter-specific configuration
 * including dependencies required by the adapter for exported projects.
 */
interface AdapterConfig {
  /**
   * Dependencies configuration for this adapter.
   */
  dependencies: {
    /**
     * Runtime dependencies required by this adapter for an exported project.
     * These will be included in the `dependencies` section of the exported `package.json`.
     *
     * @example { "viem": "^2.0.0" }
     */
    runtime: Record<string, string>;
    /**
     * Development dependencies for the adapter, usually type definitions.
     * These will be included in the `devDependencies` of the exported `package.json`.
     *
     * @example { "@types/react": "^18.0.0" }
     */
    dev?: Record<string, string>;
    /**
     * Build tool dependencies required by this adapter (e.g., Vite plugins, bundler config).
     * These will be included in the `devDependencies` of the exported `package.json`.
     * Used by adapters with special build requirements (e.g., Midnight's WASM support).
     *
     * @example { "vite-plugin-wasm": "^3.3.0", "vite-plugin-top-level-await": "^1.4.4" }
     */
    build?: Record<string, string>;
  };
  /**
   * Optional Vite configuration fragments for adapters with special build requirements.
   * When present, the export system will generate a vite.config.ts that includes these configurations.
   *
   * @example
   * ```typescript
   * viteConfig: {
   *   imports: ["import wasm from 'vite-plugin-wasm';"],
   *   configInit: "const config = getAdapterConfig({ wasm });",
   *   plugins: "...config.plugins,"
   * }
   * ```
   */
  viteConfig?: ViteConfigInfo;
  /**
   * Overrides for transitive dependencies.
   * These will be included in the `overrides` section of the exported `package.json`.
   * This is useful for resolving peer dependency conflicts (e.g., with React 19).
   *
   * @example { "use-sync-external-store": "^1.2.0" }
   */
  overrides?: Record<string, string>;
  /**
   * Patched dependencies that require fixes for browser compatibility or other issues.
   * Each entry maps a package name with version to the patch filename
   * (not including the adapter package's `patches/` directory prefix).
   *
   * When an adapter specifies patches, the export system will:
   * 1. Copy the patch files to the exported project's `patches/` directory
   * 2. Add the corresponding `pnpm.patchedDependencies` entries to `package.json`
   *
   * @example
   * ```typescript
   * patchedDependencies: {
   *   "@midnight-ntwrk/midnight-js-contracts@2.0.2": "@midnight-ntwrk__midnight-js-contracts@2.0.2.patch",
   *   "@midnight-ntwrk/midnight-js-types@2.0.2": "@midnight-ntwrk__midnight-js-types@2.0.2.patch"
   * }
   * ```
   */
  patchedDependencies?: Record<string, string>;
  /**
   * Optional UI kits that can be used with this adapter.
   * Each UI kit can specify its own set of dependencies and overrides.
   */
  uiKits?: Record<string, {
    dependencies: {
      runtime: Record<string, string>;
      dev?: Record<string, string>;
    };
    /**
     * UI Kit-specific overrides for transitive dependencies.
     */
    overrides?: Record<string, string>;
  }>;
}
//#endregion
//#region src/adapters/access-control-errors.d.ts
/**
 * Access Control Error Types
 *
 * Chain-agnostic error classes for access control operations.
 * These errors can be used across any adapter (EVM, Stellar, Solana, Midnight, etc.)
 * that implements access control functionality.
 *
 * Each error type provides specific context for debugging and user-friendly error messages.
 */
/**
 * Base class for all Access Control errors
 *
 * This abstract class serves as the foundation for all access control-related errors.
 * It provides a common structure with optional contract address context.
 */
declare abstract class AccessControlError extends Error {
  readonly contractAddress?: string | undefined;
  /**
   * Creates a new AccessControlError.
   * @param message - Error message describing the issue
   * @param contractAddress - Optional contract address for context
   */
  constructor(message: string, contractAddress?: string | undefined);
}
/**
 * Error thrown when a contract does not implement required interfaces
 *
 * This error indicates that a contract is missing necessary access control functionality
 * or has a partial/incompatible implementation.
 *
 * @example
 * ```typescript
 * throw new UnsupportedContractFeatures(
 *   'Contract missing required Ownable methods',
 *   contractAddress,
 *   ['transfer_ownership', 'renounce_ownership']
 * );
 * ```
 *
 * Common use cases:
 * - Contract missing Ownable or AccessControl methods
 * - Contract has partial implementation that doesn't conform to standards
 * - Contract is a custom access control implementation not compatible with expected interfaces
 */
declare class UnsupportedContractFeatures extends AccessControlError {
  readonly missingFeatures?: string[] | undefined;
  /**
   * Creates a new UnsupportedContractFeatures error.
   * @param message - Error message describing the issue
   * @param contractAddress - Optional contract address for context
   * @param missingFeatures - Optional list of missing feature names
   */
  constructor(message: string, contractAddress?: string, missingFeatures?: string[] | undefined);
}
/**
 * Error thrown when the caller lacks required permissions for an operation
 *
 * This error indicates an authorization failure where the calling account doesn't
 * have the necessary permissions to execute the requested operation.
 *
 * @example
 * ```typescript
 * throw new PermissionDenied(
 *   'Caller is not an admin',
 *   contractAddress,
 *   'ADMIN_ROLE',
 *   callerAddress
 * );
 * ```
 *
 * Common use cases:
 * - Attempting to grant/revoke roles without admin rights
 * - Trying to transfer ownership without being the owner
 * - Executing operations that require specific role membership
 */
declare class PermissionDenied extends AccessControlError {
  readonly requiredRole?: string | undefined;
  readonly callerAddress?: string | undefined;
  /**
   * Creates a new PermissionDenied error.
   * @param message - Error message describing the issue
   * @param contractAddress - Optional contract address for context
   * @param requiredRole - Optional role that was required
   * @param callerAddress - Optional address of the caller who lacked permission
   */
  constructor(message: string, contractAddress?: string, requiredRole?: string | undefined, callerAddress?: string | undefined);
}
/**
 * Error thrown when an indexer is required but not available
 *
 * This error indicates that an operation requires indexer support (e.g., for historical data),
 * but the indexer is not configured, unreachable, or not functioning properly.
 *
 * @example
 * ```typescript
 * throw new IndexerUnavailable(
 *   'History queries require indexer support',
 *   contractAddress,
 *   networkId,
 *   indexerEndpoint
 * );
 * ```
 *
 * Common use cases:
 * - No indexer endpoint configured in network config
 * - Indexer endpoint is unreachable or returning errors
 * - Indexer health check fails
 * - Network doesn't have indexer support
 */
declare class IndexerUnavailable extends AccessControlError {
  readonly networkId?: string | undefined;
  readonly endpointUrl?: string | undefined;
  /**
   * Creates a new IndexerUnavailable error.
   * @param message - Error message describing the issue
   * @param contractAddress - Optional contract address for context
   * @param networkId - Optional network identifier
   * @param endpointUrl - Optional indexer endpoint URL that was unavailable
   */
  constructor(message: string, contractAddress?: string, networkId?: string | undefined, endpointUrl?: string | undefined);
}
/**
 * Error thrown when configuration is invalid or incomplete
 *
 * This error indicates a problem with the configuration provided to access control operations,
 * such as invalid addresses, missing required config, or malformed parameters.
 *
 * @example
 * ```typescript
 * throw new ConfigurationInvalid(
 *   'Contract not registered',
 *   contractAddress,
 *   'contractAddress',
 *   providedAddress
 * );
 * ```
 *
 * Common use cases:
 * - Invalid contract address format
 * - Missing required network configuration
 * - Invalid role identifier
 * - Malformed indexer endpoint
 * - Contract not registered before use
 */
declare class ConfigurationInvalid extends AccessControlError {
  readonly configField?: string | undefined;
  readonly providedValue?: unknown | undefined;
  /**
   * Creates a new ConfigurationInvalid error.
   * @param message - Error message describing the issue
   * @param contractAddress - Optional contract address for context
   * @param configField - Optional name of the invalid configuration field
   * @param providedValue - Optional value that was invalid
   */
  constructor(message: string, contractAddress?: string, configField?: string | undefined, providedValue?: unknown | undefined);
}
/**
 * Error thrown when an operation fails during execution
 *
 * This error indicates a runtime failure during an access control operation.
 * It includes the operation name and can chain the underlying cause for debugging.
 *
 * @example
 * ```typescript
 * try {
 *   // ... operation code
 * } catch (err) {
 *   throw new OperationFailed(
 *     'Failed to read ownership',
 *     contractAddress,
 *     'readOwnership',
 *     err as Error
 *   );
 * }
 * ```
 *
 * Common use cases:
 * - Transaction assembly fails
 * - RPC call returns an error
 * - Transaction simulation fails
 * - On-chain read operation fails
 * - GraphQL query to indexer fails
 * - Snapshot validation fails
 */
declare class OperationFailed extends AccessControlError {
  readonly operation?: string | undefined;
  readonly cause?: Error | undefined;
  /**
   * Creates a new OperationFailed error.
   * @param message - Error message describing the issue
   * @param contractAddress - Optional contract address for context
   * @param operation - Optional name of the operation that failed
   * @param cause - Optional underlying error that caused the failure
   */
  constructor(message: string, contractAddress?: string, operation?: string | undefined, cause?: Error | undefined);
}
//#endregion
//#region src/adapters/index.d.ts
/**
 * Combined adapter interface with all capabilities
 *
 * This type represents a full-featured adapter that implements both the base
 * ContractAdapter interface and additional capabilities like contract state querying.
 */
type FullContractAdapter = ContractAdapter & ContractStateCapabilities;
//#endregion
export { AccessControlCapabilities, AccessControlError, AccessControlService, AccessSnapshot, AdapterConfig, AdapterExportBootstrap, AdapterExportContext, AdminDelayInfo, AdminInfo, AdminState, AppRuntimeConfig, AvailableUiKit, BaseComponentProps, BaseNetworkConfig, BuilderFormConfigLike, CommonFormProperties, ComponentExclusionConfig, ConfigurationInvalid, Connector, ContractAdapter, ContractDefinitionComparisonResult, ContractDefinitionDifference, ContractDefinitionMetadata, ContractDefinitionValidationResult, ContractEvent, ContractFunction, ContractSchema, ContractStateCapabilities, DynamicTypePattern, ECOSYSTEM_WALLET_COMPONENT_KEYS, Ecosystem, EcosystemDefinition, EcosystemFeatureConfig, EcosystemInfo, EcosystemReactUiProviderProps, EcosystemSpecificReactHooks, EcosystemWalletComponentKey, EcosystemWalletComponents, EnrichedRoleAssignment, EnrichedRoleMember, EnumValue, EoaExecutionConfig, EvmNetworkConfig, ExecutionConfig, ExecutionMethodDetail, ExecutionMethodType, ExpirationMetadata, ExplorerApiConfig, FeatureFlags, FieldCondition, FieldTransforms, FieldType, FieldValidation, FieldValue, FormError, FormFieldType, FormLayout, FormValues, FullContractAdapter, FunctionBadge, FunctionBadgeVariant, FunctionDecoration, FunctionDecorationsMap, FunctionParameter, GlobalServiceConfigs, HistoryChangeType, HistoryEntry, HistoryQueryOptions, IndexerEndpointConfig, IndexerUnavailable, MapEntry, MidnightNetworkConfig, MultisigExecutionConfig, NativeConfigLoader, NetworkConfig, NetworkServiceConfigs, NetworkServiceForm, NetworkSpecificIndexerEndpoints, NetworkSpecificRpcEndpoints, NetworkType, OperationFailed, OperationResult, OwnershipInfo, OwnershipState, PageInfo, PaginatedHistoryResult, PendingAdminTransfer, PendingOwnershipTransfer, PermissionDenied, PolkadotExecutionType, PolkadotNetworkCategory, PolkadotNetworkConfig, PolkadotRelayChain, ProxyInfo, RelayerDetails, RelayerDetailsRich, RelayerExecutionConfig, RenderFormSchema, RoleAssignment, RoleIdentifier, RpcEndpointConfig, RuntimeSecretPropertyInput, ServiceParameterConfig, SolanaNetworkConfig, StellarNetworkConfig, SubmitButtonConfig, TransactionFormProps, TransactionStatusUpdate, TxStatus, TypeMappingInfo, UiKitConfiguration, UiKitName, UnsupportedContractFeatures, UserExplorerConfig, UserRpcProviderConfig, ViteConfigInfo, WalletComponentSize, WalletComponentVariant, WalletConnectionStatus, isEnumValue, isEvmEcosystem, isEvmNetworkConfig, isMapEntry, isMapEntryArray, isMidnightEcosystem, isMidnightNetworkConfig, isPolkadotEcosystem, isPolkadotNetworkConfig, isSolanaEcosystem, isSolanaNetworkConfig, isStellarEcosystem, isStellarNetworkConfig, validateNetworkConfig };
//# sourceMappingURL=index.d.cts.map