{"version":3,"file":"index.cjs","names":[],"sources":["../src/adapters/ui-enhancements.ts","../src/adapters/access-control-errors.ts","../src/common/ecosystem.ts","../src/common/enum.ts","../src/common/map.ts","../src/networks/config.ts","../src/networks/validation.ts"],"sourcesContent":["import type React from 'react';\n\nimport type { FormFieldType, FormValues } from '../forms';\n\n/**\n * Configuration for excluding specific wallet components provided by an adapter for its 'custom' kit.\n */\nexport interface ComponentExclusionConfig {\n  /**\n   * Array of component keys (e.g., 'ConnectButton', 'NetworkSwitcher') to exclude\n   * when the adapter provides its 'custom' set of UI components.\n   */\n  exclude?: Array<keyof EcosystemWalletComponents>;\n}\n\n/**\n * Configuration for the desired UI kit to be used by an adapter.\n */\nexport interface UiKitConfiguration {\n  /** Name of the chosen UI kit (e.g., 'rainbowkit', 'connectkit'). Use 'custom' for adapter-provided default components or 'none' to disable adapter UI. */\n  kitName: UiKitName;\n\n  /**\n   * Kit-specific configuration options.\n   * This is an open-ended object to allow adapters to define their own configuration.\n   * The adapter is responsible for validating and type-checking these values.\n   */\n  kitConfig: FormValues;\n\n  customCode?: string;\n}\n\n/**\n * A generic hook function type that can be called with any parameters and returns any result.\n * This allows us to maintain flexibility for adapter implementations while avoiding the use of 'any'.\n */\ntype GenericHook<TParams extends unknown[] = [], TResult = unknown> = (...args: TParams) => TResult;\n\n/**\n * Defines the shape of facade hooks provided by an adapter for its ecosystem.\n * These typically wrap underlying library hooks (e.g., from wagmi for EVM).\n *\n * We use generic hook signatures to allow direct use of library hooks\n * without tightly coupling to their specific parameter and return types.\n *\n * Adapters implementing these facade hooks are responsible for mapping their native\n * library's return values to a conventional set of properties expected by consumers.\n * This ensures that UI components using these facade hooks can remain chain-agnostic.\n *\n * @example For `useSwitchChain`:\n * Consumers will expect an object like:\n * ```typescript\n * {\n *   switchChain: (args: { chainId: number }) => void; // Function to initiate the switch\n *   isPending: boolean;                             // True if the switch is in progress\n *   error: Error | null;                            // Error object if the switch failed\n *   // chains?: Chain[]; // Optional: array of available chains, if provided by underlying hook\n * }\n * ```\n * If an adapter's underlying library uses `isLoading` instead of `isPending`,\n * the adapter's facade implementation for `useSwitchChain` should map `isLoading` to `isPending`.\n *\n * @example For `useAccount`:\n * Consumers will expect an object like:\n * ```typescript\n * {\n *   isConnected: boolean;\n *   address?: string;\n *   chainId?: number;\n *   // Other properties like `connector`, `status` might also be conventionally expected.\n * }\n * ```\n */\nexport interface EcosystemSpecificReactHooks {\n  // Hooks that don't require parameters\n  useAccount?: GenericHook;\n  useConnect?: GenericHook;\n  useDisconnect?: GenericHook;\n  useSwitchChain?: GenericHook;\n  useChainId?: GenericHook;\n  useChains?: GenericHook;\n\n  // Hooks that typically require parameters\n  useBalance?: GenericHook;\n  useSendTransaction?: GenericHook;\n  useWaitForTransactionReceipt?: GenericHook;\n  useSignMessage?: GenericHook;\n  useSignTypedData?: GenericHook;\n  // Other ecosystem-specific hooks can be added as needed\n}\n\n/**\n * Props for the ecosystem-specific UI context provider component.\n */\nexport interface EcosystemReactUiProviderProps {\n  children: React.ReactNode;\n}\n\n/**\n * Size variants available for wallet UI components.\n * Maps to standard button sizing conventions.\n */\nexport type WalletComponentSize = 'sm' | 'default' | 'lg' | 'xl';\n\n/**\n * Visual style variants for wallet UI components.\n */\nexport type WalletComponentVariant = 'default' | 'outline' | 'ghost' | 'secondary';\n\n/**\n * Base props interface that all component props should be compatible with.\n * Components can extend this with additional props as needed.\n *\n * Adapters implementing wallet components should respect these props:\n * - `className`: Additional CSS classes to apply\n * - `size`: Controls the component's size (height, padding, font-size)\n * - `variant`: Controls the visual style (colors, borders)\n * - `fullWidth`: When true, component expands to fill container width\n */\nexport interface BaseComponentProps {\n  /** Additional CSS classes to apply to the component */\n  className?: string;\n  /** Size variant for the component */\n  size?: WalletComponentSize;\n  /** Visual style variant */\n  variant?: WalletComponentVariant;\n  /** If true, component expands to fill its container width */\n  fullWidth?: boolean;\n}\n\n/**\n * Defines standardized names for commonly needed wallet UI components\n * that an adapter might provide.\n */\nexport interface EcosystemWalletComponents {\n  // Using a generic type parameter with a default of BaseComponentProps\n  // This allows components with more specific props that include at least className\n  ConnectButton?: React.ComponentType<BaseComponentProps>;\n  AccountDisplay?: React.ComponentType<BaseComponentProps>;\n  NetworkSwitcher?: React.ComponentType<BaseComponentProps>;\n}\n\n/**\n * Valid component keys for EcosystemWalletComponents.\n * Used for type-safe runtime validation of component exclusion lists.\n */\nexport const ECOSYSTEM_WALLET_COMPONENT_KEYS = [\n  'ConnectButton',\n  'AccountDisplay',\n  'NetworkSwitcher',\n] as const satisfies Array<keyof EcosystemWalletComponents>;\n\nexport type EcosystemWalletComponentKey = (typeof ECOSYSTEM_WALLET_COMPONENT_KEYS)[number];\n\nexport type NativeConfigLoader = (relativePath: string) => Promise<Record<string, unknown> | null>;\n\n/**\n * Describes a UI kit available for a specific adapter, providing all necessary\n * metadata for the builder app to render its configuration options.\n */\nexport interface AvailableUiKit {\n  /** A unique identifier for the UI kit (e.g., 'rainbowkit'). */\n  id: string;\n\n  /** The display name of the UI kit (e.g., 'RainbowKit'). */\n  name: string;\n\n  /** An optional link to the UI kit's documentation. */\n  linkToDocs?: string;\n\n  /**\n   * An optional description of the UI kit and its configuration.\n   * This can contain HTML for formatting (e.g., code blocks, links).\n   */\n  description?: string;\n\n  /** An array of form fields required to configure the UI kit. */\n  configFields: FormFieldType[];\n\n  /**\n   * If true, indicates that this UI kit supports advanced configuration via a code editor.\n   * @default false\n   */\n  hasCodeEditor?: boolean;\n\n  /**\n   * The default boilerplate code to display if `hasCodeEditor` is true.\n   */\n  defaultCode?: string;\n}\n\nexport type UiKitName =\n  // EVM UI Kits\n  | 'rainbowkit'\n  | 'connectkit'\n  | 'appkit'\n  // Stellar UI Kits\n  | 'stellar-wallets-kit'\n  // Generic options\n  | 'custom'\n  | 'none';\n\n/**\n * Badge variant for function decorations\n */\nexport type FunctionBadgeVariant = 'info' | 'warning' | 'neutral';\n\n/**\n * Badge displayed next to a function in the UI\n */\nexport interface FunctionBadge {\n  /** Display text for the badge */\n  text: string;\n  /** Visual variant of the badge */\n  variant?: FunctionBadgeVariant;\n  /** Optional tooltip text shown on hover */\n  tooltip?: string;\n}\n\n/**\n * Decoration for a contract function (badges, notes, etc.)\n */\nexport interface FunctionDecoration {\n  /** Array of badges to display next to the function */\n  badges?: FunctionBadge[];\n  /** Optional note to display when the function is selected */\n  note?: {\n    /** Optional title for the note */\n    title?: string;\n    /** Body text of the note */\n    body: string;\n  };\n  /**\n   * (Optional) If true, the form should auto-add a runtime secret field (if adapter provides getRuntimeFieldBinding).\n   * Used to mark functions like organizer-only circuits that require credentials.\n   * User can customize (hide, hardcode) or remove the field after auto-add.\n   */\n  requiresRuntimeSecret?: boolean;\n}\n\n/**\n * Map of function IDs to their decorations\n */\nexport type FunctionDecorationsMap = Record<string, FunctionDecoration>;\n","/**\n * Access Control Error Types\n *\n * Chain-agnostic error classes for access control operations.\n * These errors can be used across any adapter (EVM, Stellar, Solana, Midnight, etc.)\n * that implements access control functionality.\n *\n * Each error type provides specific context for debugging and user-friendly error messages.\n */\n\n/**\n * Base class for all Access Control errors\n *\n * This abstract class serves as the foundation for all access control-related errors.\n * It provides a common structure with optional contract address context.\n */\nexport abstract class AccessControlError extends Error {\n  /**\n   * Creates a new AccessControlError.\n   * @param message - Error message describing the issue\n   * @param contractAddress - Optional contract address for context\n   */\n  constructor(\n    message: string,\n    public readonly contractAddress?: string\n  ) {\n    super(message);\n    this.name = this.constructor.name;\n  }\n}\n\n/**\n * Error thrown when a contract does not implement required interfaces\n *\n * This error indicates that a contract is missing necessary access control functionality\n * or has a partial/incompatible implementation.\n *\n * @example\n * ```typescript\n * throw new UnsupportedContractFeatures(\n *   'Contract missing required Ownable methods',\n *   contractAddress,\n *   ['transfer_ownership', 'renounce_ownership']\n * );\n * ```\n *\n * Common use cases:\n * - Contract missing Ownable or AccessControl methods\n * - Contract has partial implementation that doesn't conform to standards\n * - Contract is a custom access control implementation not compatible with expected interfaces\n */\nexport class UnsupportedContractFeatures extends AccessControlError {\n  /**\n   * Creates a new UnsupportedContractFeatures error.\n   * @param message - Error message describing the issue\n   * @param contractAddress - Optional contract address for context\n   * @param missingFeatures - Optional list of missing feature names\n   */\n  constructor(\n    message: string,\n    contractAddress?: string,\n    public readonly missingFeatures?: string[]\n  ) {\n    super(message, contractAddress);\n  }\n}\n\n/**\n * Error thrown when the caller lacks required permissions for an operation\n *\n * This error indicates an authorization failure where the calling account doesn't\n * have the necessary permissions to execute the requested operation.\n *\n * @example\n * ```typescript\n * throw new PermissionDenied(\n *   'Caller is not an admin',\n *   contractAddress,\n *   'ADMIN_ROLE',\n *   callerAddress\n * );\n * ```\n *\n * Common use cases:\n * - Attempting to grant/revoke roles without admin rights\n * - Trying to transfer ownership without being the owner\n * - Executing operations that require specific role membership\n */\nexport class PermissionDenied extends AccessControlError {\n  /**\n   * Creates a new PermissionDenied error.\n   * @param message - Error message describing the issue\n   * @param contractAddress - Optional contract address for context\n   * @param requiredRole - Optional role that was required\n   * @param callerAddress - Optional address of the caller who lacked permission\n   */\n  constructor(\n    message: string,\n    contractAddress?: string,\n    public readonly requiredRole?: string,\n    public readonly callerAddress?: string\n  ) {\n    super(message, contractAddress);\n  }\n}\n\n/**\n * Error thrown when an indexer is required but not available\n *\n * This error indicates that an operation requires indexer support (e.g., for historical data),\n * but the indexer is not configured, unreachable, or not functioning properly.\n *\n * @example\n * ```typescript\n * throw new IndexerUnavailable(\n *   'History queries require indexer support',\n *   contractAddress,\n *   networkId,\n *   indexerEndpoint\n * );\n * ```\n *\n * Common use cases:\n * - No indexer endpoint configured in network config\n * - Indexer endpoint is unreachable or returning errors\n * - Indexer health check fails\n * - Network doesn't have indexer support\n */\nexport class IndexerUnavailable extends AccessControlError {\n  /**\n   * Creates a new IndexerUnavailable error.\n   * @param message - Error message describing the issue\n   * @param contractAddress - Optional contract address for context\n   * @param networkId - Optional network identifier\n   * @param endpointUrl - Optional indexer endpoint URL that was unavailable\n   */\n  constructor(\n    message: string,\n    contractAddress?: string,\n    public readonly networkId?: string,\n    public readonly endpointUrl?: string\n  ) {\n    super(message, contractAddress);\n  }\n}\n\n/**\n * Error thrown when configuration is invalid or incomplete\n *\n * This error indicates a problem with the configuration provided to access control operations,\n * such as invalid addresses, missing required config, or malformed parameters.\n *\n * @example\n * ```typescript\n * throw new ConfigurationInvalid(\n *   'Contract not registered',\n *   contractAddress,\n *   'contractAddress',\n *   providedAddress\n * );\n * ```\n *\n * Common use cases:\n * - Invalid contract address format\n * - Missing required network configuration\n * - Invalid role identifier\n * - Malformed indexer endpoint\n * - Contract not registered before use\n */\nexport class ConfigurationInvalid extends AccessControlError {\n  /**\n   * Creates a new ConfigurationInvalid error.\n   * @param message - Error message describing the issue\n   * @param contractAddress - Optional contract address for context\n   * @param configField - Optional name of the invalid configuration field\n   * @param providedValue - Optional value that was invalid\n   */\n  constructor(\n    message: string,\n    contractAddress?: string,\n    public readonly configField?: string,\n    public readonly providedValue?: unknown\n  ) {\n    super(message, contractAddress);\n  }\n}\n\n/**\n * Error thrown when an operation fails during execution\n *\n * This error indicates a runtime failure during an access control operation.\n * It includes the operation name and can chain the underlying cause for debugging.\n *\n * @example\n * ```typescript\n * try {\n *   // ... operation code\n * } catch (err) {\n *   throw new OperationFailed(\n *     'Failed to read ownership',\n *     contractAddress,\n *     'readOwnership',\n *     err as Error\n *   );\n * }\n * ```\n *\n * Common use cases:\n * - Transaction assembly fails\n * - RPC call returns an error\n * - Transaction simulation fails\n * - On-chain read operation fails\n * - GraphQL query to indexer fails\n * - Snapshot validation fails\n */\nexport class OperationFailed extends AccessControlError {\n  /**\n   * Creates a new OperationFailed error.\n   * @param message - Error message describing the issue\n   * @param contractAddress - Optional contract address for context\n   * @param operation - Optional name of the operation that failed\n   * @param cause - Optional underlying error that caused the failure\n   */\n  constructor(\n    message: string,\n    contractAddress?: string,\n    public readonly operation?: string,\n    public readonly cause?: Error\n  ) {\n    super(message, contractAddress);\n  }\n}\n","/**\n * Blockchain Ecosystem Types\n *\n * This file defines core types related to blockchain ecosystems supported\n * by the OpenZeppelin UI ecosystem. It consolidates previously scattered\n * ecosystem-related types into a single source of truth.\n */\n\n/**\n * Supported blockchain ecosystems\n */\nexport type Ecosystem = 'evm' | 'solana' | 'stellar' | 'midnight' | 'polkadot';\n\n/**\n * Network environment types\n */\nexport type NetworkType = 'mainnet' | 'testnet' | 'devnet';\n\n/**\n * Configuration for ecosystem feature flags\n */\nexport interface EcosystemFeatureConfig {\n  /** Whether the ecosystem is enabled and functional */\n  enabled: boolean;\n  /** Whether to show the ecosystem in the UI (even if disabled) */\n  showInUI: boolean;\n  /** Label to display when the ecosystem is disabled */\n  disabledLabel?: string;\n  /** Description to show when the ecosystem is disabled */\n  disabledDescription?: string;\n}\n\n/**\n * Interface for ecosystem-specific data in the registry\n */\nexport interface EcosystemInfo {\n  /** Display name (e.g., 'Ethereum (EVM)') */\n  name: string;\n\n  /** Detailed description of the blockchain */\n  description: string;\n\n  /** Explorer/verification platform guidance */\n  explorerGuidance: string;\n\n  /** Address format example (if applicable) */\n  addressExample?: string;\n\n  /** Icon path for the ecosystem (if available) */\n  iconPath?: string;\n\n  /** Network icon name for @web3icons/react NetworkIcon component */\n  networkIconName?: string;\n\n  /** Background color class for UI elements */\n  bgColorClass?: string;\n\n  /** Text color class for UI elements */\n  textColorClass?: string;\n\n  /** Default feature flag configuration */\n  defaultFeatureConfig: EcosystemFeatureConfig;\n}\n\n/**\n * Blockchain ecosystem metadata for UI display and configuration\n */\nexport interface EcosystemDefinition {\n  /**\n   * Unique identifier for the ecosystem\n   */\n  id: Ecosystem;\n\n  /**\n   * Human-readable name of the ecosystem\n   */\n  name: string;\n\n  /**\n   * Description of the ecosystem's purpose or characteristics\n   */\n  description: string;\n\n  /**\n   * Optional icon for UI display\n   * Note: This uses a generic type as we don't want to introduce React dependencies\n   */\n  icon?: unknown;\n}\n\n/**\n * Type guards for ecosystem types\n */\n\nexport const isEvmEcosystem = (ecosystem: Ecosystem): ecosystem is 'evm' => ecosystem === 'evm';\n\nexport const isSolanaEcosystem = (ecosystem: Ecosystem): ecosystem is 'solana' =>\n  ecosystem === 'solana';\n\nexport const isStellarEcosystem = (ecosystem: Ecosystem): ecosystem is 'stellar' =>\n  ecosystem === 'stellar';\n\nexport const isMidnightEcosystem = (ecosystem: Ecosystem): ecosystem is 'midnight' =>\n  ecosystem === 'midnight';\n\nexport const isPolkadotEcosystem = (ecosystem: Ecosystem): ecosystem is 'polkadot' =>\n  ecosystem === 'polkadot';\n","/**\n * Chain-Agnostic Enum Types\n *\n * This module defines standardized enum types that work across all blockchain adapters.\n * These types represent the UI layer's understanding of enums before they are converted\n * to blockchain-specific formats by individual adapters.\n */\n\n/**\n * Chain-agnostic enum value representation.\n * This is the standardized format that enum fields produce, regardless of the target blockchain.\n * Each adapter transforms this generic format into its blockchain-specific representation.\n *\n * @example Basic Usage\n * ```typescript\n * Unit variant (no payload)\n * const unitEnum: EnumValue = { tag: \"None\" };\n *\n * Tuple variant (with payload)\n * const tupleEnum: EnumValue = {\n *   tag: \"Some\",\n *   values: [\"hello\", 42]\n * };\n * ```\n *\n * @example Cross-Chain Compatibility\n * ```typescript\n * Stellar/Soroban: Transforms to ScVec([Symbol(\"Active\"), payload?])\n * const stellarEnum: EnumValue = { tag: \"Active\", values: [123] };\n * → ScVec([Symbol(\"Active\"), ScU32(123)])\n *\n * EVM/Solidity: Transforms to integer or struct\n * const evmEnum: EnumValue = { tag: \"Pending\" };\n * → uint8(0) for simple enums\n * → { variant: 0, data: [...] } for complex enums\n *\n * Solana/Rust: Transforms to Borsh-encoded enum\n * const solanaEnum: EnumValue = { tag: \"Ok\", values: [\"success\"] };\n * → Result::Ok(\"success\") via Borsh serialization\n *\n * Complex nested example\n * const complexEnum: EnumValue = {\n *   tag: \"TransferResult\",\n *   values: [\n *     { tag: \"Success\", values: [\"0x123...\", 1000] },\n *     { tag: \"Error\", values: [\"Insufficient funds\"] }\n *   ]\n * };\n * ```\n */\nexport interface EnumValue {\n  /** The variant name (e.g., 'None', 'Some', 'Success', 'Error') */\n  tag: string;\n  /** Optional payload values for tuple variants */\n  values?: unknown[];\n}\n\n/**\n * Type guard to check if a value is an EnumValue\n */\nexport function isEnumValue(value: unknown): value is EnumValue {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'tag' in value &&\n    typeof (value as Record<string, unknown>).tag === 'string' &&\n    (!('values' in value) || Array.isArray((value as Record<string, unknown>).values))\n  );\n}\n","/**\n * Chain-Agnostic Map Types\n *\n * This module defines standardized map types that work across all blockchain adapters.\n * These types represent the UI layer's understanding of maps before they are converted\n * to blockchain-specific formats by individual adapters.\n */\n\n/**\n * Chain-agnostic map entry representation.\n * This is the standardized format that map fields produce, regardless of the target blockchain.\n * Each adapter transforms this generic format into its blockchain-specific representation.\n *\n * @example Basic Usage\n * ```typescript\n * Simple key-value pairs\n * const stringMap: MapEntry[] = [\n *   { key: \"name\", value: \"Alice\" },\n *   { key: \"age\", value: 30 }\n * ];\n *\n * Mixed type pairs\n * const mixedMap: MapEntry[] = [\n *   { key: \"config\", value: { enabled: true, timeout: 5000 } },\n *   { key: \"tags\", value: [\"production\", \"api\"] }\n * ];\n * ```\n *\n * @example Cross-Chain Compatibility\n * ```typescript\n * Stellar/Soroban: Transforms to SorobanMapEntry[]\n * const stellarMap: MapEntry[] = [\n *   { key: \"symbol\", value: \"USDC\" },\n *   { key: \"decimals\", value: 6 }\n * ];\n * → [\n *   { key: ScSymbol(\"symbol\"), value: ScSymbol(\"USDC\") },\n *   { key: ScSymbol(\"decimals\"), value: ScU32(6) }\n * ]\n *\n * EVM/Solidity: Transforms to struct array (mappings not supported in function params)\n * const evmMap: MapEntry[] = [\n *   { key: \"0x123...\", value: 1000 },\n *   { key: \"0x456...\", value: 2000 }\n * ];\n * → AddressAmount[] struct array for function parameters\n *\n * Complex nested maps\n * const nestedMap: MapEntry[] = [\n *   {\n *     key: \"user_data\",\n *     value: [\n *       { key: \"balance\", value: \"1000\" },\n *       { key: \"permissions\", value: [\"read\", \"write\"] }\n *     ]\n *   }\n * ];\n * ```\n */\nexport interface MapEntry {\n  /** The map key (can be any serializable type) */\n  key: unknown;\n  /** The map value (can be any serializable type) */\n  value: unknown;\n}\n\n/**\n * Type guard to check if a value is a MapEntry\n */\nexport function isMapEntry(value: unknown): value is MapEntry {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'key' in value &&\n    'value' in value &&\n    Object.keys(value).length >= 2\n  );\n}\n\n/**\n * Type guard to check if a value is an array of MapEntry objects\n */\nexport function isMapEntryArray(value: unknown): value is MapEntry[] {\n  return Array.isArray(value) && value.every(isMapEntry);\n}\n","/**\n * Network Configuration Types\n *\n * This file defines the TypeScript types for network configurations across different blockchain ecosystems.\n * It uses a discriminated union pattern with the 'ecosystem' property as the discriminant to ensure type safety.\n */\nimport type React from 'react';\n\nimport { Ecosystem, NetworkType } from '../common/ecosystem';\n\n/**\n * Base interface with common properties shared across all network configurations\n */\nexport interface BaseNetworkConfig {\n  /**\n   * Unique identifier for the network, e.g., 'ethereum-mainnet', 'polygon-amoy'\n   */\n  id: string;\n\n  /**\n   * User-friendly network name, e.g., 'Ethereum Mainnet'\n   */\n  name: string;\n\n  /**\n   * The blockchain ecosystem this network belongs to (discriminant for the union type)\n   */\n  ecosystem: Ecosystem;\n\n  /**\n   * Parent network name, e.g., 'ethereum', 'polygon'\n   */\n  network: string;\n\n  /**\n   * Network type/environment: 'mainnet', 'testnet', or 'devnet'\n   */\n  type: NetworkType;\n\n  /**\n   * Explicit flag for easy filtering of test networks\n   */\n  isTestnet: boolean;\n\n  /**\n   * The constant name under which this specific network configuration object\n   * is exported from its adapter package's network index file.\n   * Used by the export system to dynamically import the correct config.\n   * Example: 'ethereumMainnet', 'ethereumSepolia'\n   */\n  exportConstName: string;\n\n  /**\n   * Base URL for the block explorer (common across ecosystems)\n   */\n  explorerUrl?: string;\n\n  /**\n   * Optional React component for the network icon.\n   * This allows embedding the icon component directly in the network config,\n   * avoiding dynamic imports and improving build performance.\n   * If provided, this takes precedence over the icon string.\n   */\n  iconComponent?: React.ComponentType<{\n    size?: number;\n    className?: string;\n    variant?: 'mono' | 'branded';\n  }>;\n\n  /**\n   * A unique identifier for the specific explorer API service used by this network.\n   * This is used by the AppConfigService to fetch the correct API key.\n   * Examples: \"etherscan-mainnet\", \"polygonscan-mainnet\", \"bscscan-mainnet\"\n   * Should align with keys in AppRuntimeConfig.networkServiceConfigs\n   */\n  primaryExplorerApiIdentifier?: string;\n\n  /**\n   * Optional indexer GraphQL HTTP endpoint\n   * Used for querying historical blockchain data (e.g., access control events)\n   */\n  indexerUri?: string;\n\n  /**\n   * Optional indexer GraphQL WebSocket endpoint\n   * Used for real-time blockchain data subscriptions\n   */\n  indexerWsUri?: string;\n\n  /**\n   * Optional GraphQL endpoint for the access control indexer.\n   * Used by the access control module for historical queries and role discovery.\n   * Feature-specific field — distinct from the general-purpose `indexerUri` which\n   * may serve different purposes per ecosystem (e.g., Midnight chain indexer).\n   */\n  accessControlIndexerUrl?: string;\n}\n\n/**\n * EVM-specific network configuration\n */\nexport interface EvmNetworkConfig extends BaseNetworkConfig {\n  ecosystem: 'evm';\n\n  /**\n   * EVM chain ID, e.g., 1 for Ethereum Mainnet, 11155111 for Sepolia\n   */\n  chainId: number;\n\n  /**\n   * JSON-RPC endpoint for the network (can be a base URL if API key is resolved from env)\n   */\n  rpcUrl: string;\n\n  /**\n   * Native currency information\n   */\n  nativeCurrency: {\n    name: string; // e.g., 'Ether'\n    symbol: string; // e.g., 'ETH'\n    decimals: number; // typically 18\n  };\n\n  /**\n   * Optional icon name for the network (for use with @web3icons/react or similar)\n   * If not provided, the network property will be used as a fallback\n   */\n  apiUrl?: string;\n\n  /**\n   * Whether this network supports Etherscan V2 API (default: true for all Etherscan-compatible explorers)\n   */\n  supportsEtherscanV2?: boolean;\n\n  /**\n   * Whether this network's explorer requires an API key for basic operations (default: true)\n   * Some explorers like routescan.io provide free access without API keys\n   */\n  requiresExplorerApiKey?: boolean;\n\n  /**\n   * Optional chain-specific configuration object for this network.\n   * For EVM networks, this should be a Viem Chain object.\n   * If provided, this will be used directly by the chain's clients.\n   * If not provided, a fallback or minimal custom chain object might be used.\n   */\n  viemChain?: unknown;\n}\n\n/**\n * Solana-specific network configuration\n */\nexport interface SolanaNetworkConfig extends BaseNetworkConfig {\n  ecosystem: 'solana';\n\n  /**\n   * RPC endpoint for Solana network\n   */\n  rpcEndpoint: string;\n\n  /**\n   * Solana transaction confirmation commitment level\n   */\n  commitment: 'confirmed' | 'finalized';\n}\n\n/**\n * Stellar-specific network configuration\n */\nexport interface StellarNetworkConfig extends BaseNetworkConfig {\n  ecosystem: 'stellar';\n\n  /**\n   * Horizon server URL (for Stellar Classic operations)\n   */\n  horizonUrl: string;\n\n  /**\n   * Soroban RPC server URL (for smart contract operations)\n   */\n  sorobanRpcUrl: string;\n\n  /**\n   * Stellar network passphrase\n   */\n  networkPassphrase: string;\n}\n\n/**\n * Midnight-specific network configuration\n */\nexport interface MidnightNetworkConfig extends BaseNetworkConfig {\n  ecosystem: 'midnight';\n\n  /**\n   * Midnight Network ID enum value\n   * Maps to @midnight-ntwrk/midnight-js-network-id NetworkId enum\n   * Single source of truth for network identity when mapping is not provided.\n   */\n  /**\n   * Mapping of numeric network ID to its enum name.\n   * Example: { 2: 'TestNet' }\n   */\n  networkId: Partial<Record<2 | 3 | 1 | 0, 'TestNet' | 'MainNet' | 'DevNet' | 'Undeployed'>>;\n\n  /**\n   * RPC endpoints for the Midnight network\n   */\n  rpcEndpoints?: {\n    default?: string;\n    [key: string]: string | undefined;\n  };\n\n  // Additional Midnight-specific properties can be added here as the protocol evolves\n}\n\n/**\n * Polkadot execution type - currently supports EVM, with future Substrate support planned\n */\nexport type PolkadotExecutionType = 'evm' | 'substrate';\n\n/**\n * Polkadot network category for UI grouping\n */\nexport type PolkadotNetworkCategory = 'hub' | 'parachain';\n\n/**\n * Polkadot relay chain identifier\n */\nexport type PolkadotRelayChain = 'polkadot' | 'kusama';\n\n/**\n * Polkadot-specific network configuration\n * Extends EVM config since all current Polkadot networks are EVM-compatible.\n * Adds Polkadot-specific fields for execution type routing and UI grouping.\n */\nexport interface PolkadotNetworkConfig extends Omit<EvmNetworkConfig, 'ecosystem'> {\n  ecosystem: 'polkadot';\n\n  /**\n   * Execution type for this network\n   * - 'evm': EVM-compatible (current support)\n   * - 'substrate': Native Substrate/Wasm (future support)\n   */\n  executionType: PolkadotExecutionType;\n\n  /**\n   * Network category for UI grouping\n   * - 'hub': Polkadot/Kusama Hub (Asset Hub) - prioritized in UI\n   * - 'parachain': Parachains like Moonbeam, Moonriver\n   */\n  networkCategory: PolkadotNetworkCategory;\n\n  /**\n   * Optional relay chain identifier\n   * - 'polkadot': Connected to Polkadot relay chain\n   * - 'kusama': Connected to Kusama relay chain\n   * - undefined: Testnet or standalone\n   */\n  relayChain?: PolkadotRelayChain;\n}\n\n/**\n * Union type for all network configurations\n * This allows us to handle network configurations in a type-safe manner\n */\nexport type NetworkConfig =\n  | EvmNetworkConfig\n  | SolanaNetworkConfig\n  | StellarNetworkConfig\n  | MidnightNetworkConfig\n  | PolkadotNetworkConfig;\n\n/**\n * Type guard to check if a network config is for EVM\n * @param config The network configuration to check\n * @returns True if the config is for EVM\n */\nexport const isEvmNetworkConfig = (config: NetworkConfig): config is EvmNetworkConfig =>\n  config.ecosystem === 'evm';\n\n/**\n * Type guard to check if a network config is for Solana\n * @param config The network configuration to check\n * @returns True if the config is for Solana\n */\nexport const isSolanaNetworkConfig = (config: NetworkConfig): config is SolanaNetworkConfig =>\n  config.ecosystem === 'solana';\n\n/**\n * Type guard to check if a network config is for Stellar\n * @param config The network configuration to check\n * @returns True if the config is for Stellar\n */\nexport const isStellarNetworkConfig = (config: NetworkConfig): config is StellarNetworkConfig =>\n  config.ecosystem === 'stellar';\n\n/**\n * Type guard to check if a network config is for Midnight\n * @param config The network configuration to check\n * @returns True if the config is for Midnight\n */\nexport const isMidnightNetworkConfig = (config: NetworkConfig): config is MidnightNetworkConfig =>\n  config.ecosystem === 'midnight';\n\n/**\n * Type guard to check if a network config is for Polkadot\n * @param config The network configuration to check\n * @returns True if the config is for Polkadot\n */\nexport const isPolkadotNetworkConfig = (config: NetworkConfig): config is PolkadotNetworkConfig =>\n  config.ecosystem === 'polkadot';\n","/**\n * Network Configuration Validation\n *\n * This file contains utilities for validating network configurations to ensure they have\n * all required fields and properly typed values for each ecosystem.\n */\nimport {\n  EvmNetworkConfig,\n  isEvmNetworkConfig,\n  isMidnightNetworkConfig,\n  isSolanaNetworkConfig,\n  isStellarNetworkConfig,\n  MidnightNetworkConfig,\n  NetworkConfig,\n  SolanaNetworkConfig,\n  StellarNetworkConfig,\n} from './config';\n\n/**\n * Validate a network configuration\n * @param config The network configuration to validate\n * @returns True if the configuration is valid\n */\nexport function validateNetworkConfig(config: NetworkConfig): boolean {\n  // Validate common fields required for all networks\n  if (!validateBaseNetworkConfig(config)) {\n    return false;\n  }\n\n  // Ecosystem-specific validation\n  if (isEvmNetworkConfig(config)) {\n    return validateEvmNetworkConfig(config);\n  } else if (isSolanaNetworkConfig(config)) {\n    return validateSolanaNetworkConfig(config);\n  } else if (isStellarNetworkConfig(config)) {\n    return validateStellarNetworkConfig(config);\n  } else if (isMidnightNetworkConfig(config)) {\n    return validateMidnightNetworkConfig(config);\n  }\n\n  // Unknown ecosystem\n  return false;\n}\n\n/**\n * Validate the base fields common to all network configurations\n * @param config The network configuration to validate\n * @returns True if the base configuration is valid\n */\nfunction validateBaseNetworkConfig(config: NetworkConfig): boolean {\n  return (\n    typeof config.id === 'string' &&\n    config.id.trim().length > 0 &&\n    typeof config.name === 'string' &&\n    config.name.trim().length > 0 &&\n    typeof config.network === 'string' &&\n    config.network.trim().length > 0 &&\n    ['mainnet', 'testnet', 'devnet'].includes(config.type) &&\n    typeof config.isTestnet === 'boolean' &&\n    (config.explorerUrl === undefined || typeof config.explorerUrl === 'string')\n  );\n}\n\n/**\n * Validate an EVM network configuration\n * @param config The EVM network configuration to validate\n * @returns True if the configuration is valid\n */\nfunction validateEvmNetworkConfig(config: EvmNetworkConfig): boolean {\n  return (\n    typeof config.chainId === 'number' &&\n    config.chainId > 0 &&\n    typeof config.rpcUrl === 'string' &&\n    config.rpcUrl.trim().length > 0 &&\n    validateEvmNativeCurrency(config.nativeCurrency)\n  );\n}\n\n/**\n * Validate the native currency object in an EVM network configuration\n * @param currency The native currency object to validate\n * @returns True if the native currency is valid\n */\nfunction validateEvmNativeCurrency(currency: EvmNetworkConfig['nativeCurrency']): boolean {\n  return (\n    typeof currency === 'object' &&\n    currency !== null &&\n    typeof currency.name === 'string' &&\n    currency.name.trim().length > 0 &&\n    typeof currency.symbol === 'string' &&\n    currency.symbol.trim().length > 0 &&\n    typeof currency.decimals === 'number' &&\n    currency.decimals >= 0\n  );\n}\n\n/**\n * Validate a Solana network configuration\n * @param config The Solana network configuration to validate\n * @returns True if the configuration is valid\n */\nfunction validateSolanaNetworkConfig(config: SolanaNetworkConfig): boolean {\n  return (\n    typeof config.rpcEndpoint === 'string' &&\n    config.rpcEndpoint.trim().length > 0 &&\n    ['confirmed', 'finalized'].includes(config.commitment)\n  );\n}\n\n/**\n * Validate a Stellar network configuration\n * @param config The Stellar network configuration to validate\n * @returns True if the configuration is valid\n */\nfunction validateStellarNetworkConfig(config: StellarNetworkConfig): boolean {\n  return (\n    typeof config.horizonUrl === 'string' &&\n    config.horizonUrl.trim().length > 0 &&\n    typeof config.networkPassphrase === 'string' &&\n    config.networkPassphrase.trim().length > 0\n  );\n}\n\n/**\n * Validate a Midnight network configuration\n * @param config The Midnight network configuration to validate\n * @returns True if the configuration is valid\n */\nfunction validateMidnightNetworkConfig(_config: MidnightNetworkConfig): boolean {\n  // Currently just validates the base fields\n  // Add more validation as Midnight-specific fields are added\n  return true;\n}\n"],"mappings":"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"}