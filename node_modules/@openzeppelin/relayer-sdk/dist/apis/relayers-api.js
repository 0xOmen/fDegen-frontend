"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * OpenZeppelin Relayer API
 * OpenZeppelin Relayer API
 *
 * The version of the OpenAPI document: 1.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RelayersApi = exports.RelayersApiFactory = exports.RelayersApiFp = exports.RelayersApiAxiosParamCreator = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * RelayersApi - axios parameter creator
 * @export
 */
const RelayersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * This endpoint builds a transaction where the relayer will pay the network fees on behalf of the user. The user pays fees in a token of their choice (e.g., USDC) instead of the native network currency.  The endpoint accepts either a pre-built transaction XDR or a set of operations to build a transaction from. It returns a prepared transaction that includes: - The transaction XDR (base64 encoded) ready for signing - The fee amount in both the fee token and native currency (stroops for Stellar) - The fee token identifier - The transaction validity timestamp  After receiving the prepared transaction, the user must sign it and submit it through the standard transaction submission endpoint. For Stellar, the transaction will be wrapped in a fee-bump transaction where the relayer pays the network fees.
         * @summary Prepares a sponsored (gasless) transaction with fee payments.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SponsoredTransactionBuildRequest} sponsoredTransactionBuildRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildSponsoredTransaction: (relayerId_1, sponsoredTransactionBuildRequest_1, ...args_1) => __awaiter(this, [relayerId_1, sponsoredTransactionBuildRequest_1, ...args_1], void 0, function* (relayerId, sponsoredTransactionBuildRequest, options = {}) {
            // verify required parameter 'relayerId' is not null or undefined
            (0, common_1.assertParamExists)('buildSponsoredTransaction', 'relayerId', relayerId);
            // verify required parameter 'sponsoredTransactionBuildRequest' is not null or undefined
            (0, common_1.assertParamExists)('buildSponsoredTransaction', 'sponsoredTransactionBuildRequest', sponsoredTransactionBuildRequest);
            const localVarPath = `/api/v1/relayers/{relayer_id}/transactions/sponsored/build`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(sponsoredTransactionBuildRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Cancels a specific transaction by its ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {string} transactionId The unique identifier of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransaction: (relayerId_1, transactionId_1, ...args_1) => __awaiter(this, [relayerId_1, transactionId_1, ...args_1], void 0, function* (relayerId, transactionId, options = {}) {
            // verify required parameter 'relayerId' is not null or undefined
            (0, common_1.assertParamExists)('cancelTransaction', 'relayerId', relayerId);
            // verify required parameter 'transactionId' is not null or undefined
            (0, common_1.assertParamExists)('cancelTransaction', 'transactionId', transactionId);
            const localVarPath = `/api/v1/relayers/{relayer_id}/transactions/{transaction_id}`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Creates a new relayer.
         * @param {CreateRelayerRequest} createRelayerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelayer: (createRelayerRequest_1, ...args_1) => __awaiter(this, [createRelayerRequest_1, ...args_1], void 0, function* (createRelayerRequest, options = {}) {
            // verify required parameter 'createRelayerRequest' is not null or undefined
            (0, common_1.assertParamExists)('createRelayer', 'createRelayerRequest', createRelayerRequest);
            const localVarPath = `/api/v1/relayers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createRelayerRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Deletes all pending transactions for a specific relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePendingTransactions: (relayerId_1, ...args_1) => __awaiter(this, [relayerId_1, ...args_1], void 0, function* (relayerId, options = {}) {
            // verify required parameter 'relayerId' is not null or undefined
            (0, common_1.assertParamExists)('deletePendingTransactions', 'relayerId', relayerId);
            const localVarPath = `/api/v1/relayers/{relayer_id}/transactions/pending`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Deletes a relayer by ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelayer: (relayerId_1, ...args_1) => __awaiter(this, [relayerId_1, ...args_1], void 0, function* (relayerId, options = {}) {
            // verify required parameter 'relayerId' is not null or undefined
            (0, common_1.assertParamExists)('deleteRelayer', 'relayerId', relayerId);
            const localVarPath = `/api/v1/relayers/{relayer_id}`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieves details of a specific relayer by ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayer: (relayerId_1, ...args_1) => __awaiter(this, [relayerId_1, ...args_1], void 0, function* (relayerId, options = {}) {
            // verify required parameter 'relayerId' is not null or undefined
            (0, common_1.assertParamExists)('getRelayer', 'relayerId', relayerId);
            const localVarPath = `/api/v1/relayers/{relayer_id}`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieves the balance of a specific relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayerBalance: (relayerId_1, ...args_1) => __awaiter(this, [relayerId_1, ...args_1], void 0, function* (relayerId, options = {}) {
            // verify required parameter 'relayerId' is not null or undefined
            (0, common_1.assertParamExists)('getRelayerBalance', 'relayerId', relayerId);
            const localVarPath = `/api/v1/relayers/{relayer_id}/balance`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Fetches the current status of a specific relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayerStatus: (relayerId_1, ...args_1) => __awaiter(this, [relayerId_1, ...args_1], void 0, function* (relayerId, options = {}) {
            // verify required parameter 'relayerId' is not null or undefined
            (0, common_1.assertParamExists)('getRelayerStatus', 'relayerId', relayerId);
            const localVarPath = `/api/v1/relayers/{relayer_id}/status`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieves a specific transaction by its ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {string} transactionId The unique identifier of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById: (relayerId_1, transactionId_1, ...args_1) => __awaiter(this, [relayerId_1, transactionId_1, ...args_1], void 0, function* (relayerId, transactionId, options = {}) {
            // verify required parameter 'relayerId' is not null or undefined
            (0, common_1.assertParamExists)('getTransactionById', 'relayerId', relayerId);
            // verify required parameter 'transactionId' is not null or undefined
            (0, common_1.assertParamExists)('getTransactionById', 'transactionId', transactionId);
            const localVarPath = `/api/v1/relayers/{relayer_id}/transactions/{transaction_id}`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieves a transaction by its nonce value.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {number} nonce The nonce of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByNonce: (relayerId_1, nonce_1, ...args_1) => __awaiter(this, [relayerId_1, nonce_1, ...args_1], void 0, function* (relayerId, nonce, options = {}) {
            // verify required parameter 'relayerId' is not null or undefined
            (0, common_1.assertParamExists)('getTransactionByNonce', 'relayerId', relayerId);
            // verify required parameter 'nonce' is not null or undefined
            (0, common_1.assertParamExists)('getTransactionByNonce', 'nonce', nonce);
            const localVarPath = `/api/v1/relayers/{relayer_id}/transactions/by-nonce/{nonce}`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)))
                .replace(`{${"nonce"}}`, encodeURIComponent(String(nonce)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Note: OpenAPI documentation for these endpoints can be found in the `openapi.rs` file  Lists all relayers with pagination support.
         * @summary Relayer routes implementation
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [perPage] Number of items per page (default: 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRelayers: (page_1, perPage_1, ...args_1) => __awaiter(this, [page_1, perPage_1, ...args_1], void 0, function* (page, perPage, options = {}) {
            const localVarPath = `/api/v1/relayers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Lists all transactions for a specific relayer with pagination.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [perPage] Number of items per page (default: 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions: (relayerId_1, page_1, perPage_1, ...args_1) => __awaiter(this, [relayerId_1, page_1, perPage_1, ...args_1], void 0, function* (relayerId, page, perPage, options = {}) {
            // verify required parameter 'relayerId' is not null or undefined
            (0, common_1.assertParamExists)('listTransactions', 'relayerId', relayerId);
            const localVarPath = `/api/v1/relayers/{relayer_id}/transactions/`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint provides fee estimation for transactions where the relayer will pay the network fees on behalf of the user. The user pays fees in a token of their choice (e.g., USDC) instead of the native network currency (e.g., XLM for Stellar).  The endpoint accepts either a pre-built transaction XDR or a set of operations to build a transaction from. It returns the estimated fee amount in the specified fee token and the conversion rate from the native currency.
         * @summary Estimates fees for a sponsored (gasless) transaction.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SponsoredTransactionQuoteRequest} sponsoredTransactionQuoteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteSponsoredTransaction: (relayerId_1, sponsoredTransactionQuoteRequest_1, ...args_1) => __awaiter(this, [relayerId_1, sponsoredTransactionQuoteRequest_1, ...args_1], void 0, function* (relayerId, sponsoredTransactionQuoteRequest, options = {}) {
            // verify required parameter 'relayerId' is not null or undefined
            (0, common_1.assertParamExists)('quoteSponsoredTransaction', 'relayerId', relayerId);
            // verify required parameter 'sponsoredTransactionQuoteRequest' is not null or undefined
            (0, common_1.assertParamExists)('quoteSponsoredTransaction', 'sponsoredTransactionQuoteRequest', sponsoredTransactionQuoteRequest);
            const localVarPath = `/api/v1/relayers/{relayer_id}/transactions/sponsored/quote`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(sponsoredTransactionQuoteRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Replaces a specific transaction with a new one.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {string} transactionId The unique identifier of the transaction
         * @param {NetworkTransactionRequest} networkTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceTransaction: (relayerId_1, transactionId_1, networkTransactionRequest_1, ...args_1) => __awaiter(this, [relayerId_1, transactionId_1, networkTransactionRequest_1, ...args_1], void 0, function* (relayerId, transactionId, networkTransactionRequest, options = {}) {
            // verify required parameter 'relayerId' is not null or undefined
            (0, common_1.assertParamExists)('replaceTransaction', 'relayerId', relayerId);
            // verify required parameter 'transactionId' is not null or undefined
            (0, common_1.assertParamExists)('replaceTransaction', 'transactionId', transactionId);
            // verify required parameter 'networkTransactionRequest' is not null or undefined
            (0, common_1.assertParamExists)('replaceTransaction', 'networkTransactionRequest', networkTransactionRequest);
            const localVarPath = `/api/v1/relayers/{relayer_id}/transactions/{transaction_id}`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(networkTransactionRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Performs a JSON-RPC call using the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {JsonRpcRequestNetworkRpcRequest} jsonRpcRequestNetworkRpcRequest JSON-RPC request with method and parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpc: (relayerId_1, jsonRpcRequestNetworkRpcRequest_1, ...args_1) => __awaiter(this, [relayerId_1, jsonRpcRequestNetworkRpcRequest_1, ...args_1], void 0, function* (relayerId, jsonRpcRequestNetworkRpcRequest, options = {}) {
            // verify required parameter 'relayerId' is not null or undefined
            (0, common_1.assertParamExists)('rpc', 'relayerId', relayerId);
            // verify required parameter 'jsonRpcRequestNetworkRpcRequest' is not null or undefined
            (0, common_1.assertParamExists)('rpc', 'jsonRpcRequestNetworkRpcRequest', jsonRpcRequestNetworkRpcRequest);
            const localVarPath = `/api/v1/relayers/{relayer_id}/rpc`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jsonRpcRequestNetworkRpcRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Sends a transaction through the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {NetworkTransactionRequest} networkTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction: (relayerId_1, networkTransactionRequest_1, ...args_1) => __awaiter(this, [relayerId_1, networkTransactionRequest_1, ...args_1], void 0, function* (relayerId, networkTransactionRequest, options = {}) {
            // verify required parameter 'relayerId' is not null or undefined
            (0, common_1.assertParamExists)('sendTransaction', 'relayerId', relayerId);
            // verify required parameter 'networkTransactionRequest' is not null or undefined
            (0, common_1.assertParamExists)('sendTransaction', 'networkTransactionRequest', networkTransactionRequest);
            const localVarPath = `/api/v1/relayers/{relayer_id}/transactions`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(networkTransactionRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Signs data using the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SignDataRequest} signDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sign: (relayerId_1, signDataRequest_1, ...args_1) => __awaiter(this, [relayerId_1, signDataRequest_1, ...args_1], void 0, function* (relayerId, signDataRequest, options = {}) {
            // verify required parameter 'relayerId' is not null or undefined
            (0, common_1.assertParamExists)('sign', 'relayerId', relayerId);
            // verify required parameter 'signDataRequest' is not null or undefined
            (0, common_1.assertParamExists)('sign', 'signDataRequest', signDataRequest);
            const localVarPath = `/api/v1/relayers/{relayer_id}/sign`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(signDataRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Signs a transaction using the specified relayer (Stellar only).
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SignTransactionRequest} signTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signTransaction: (relayerId_1, signTransactionRequest_1, ...args_1) => __awaiter(this, [relayerId_1, signTransactionRequest_1, ...args_1], void 0, function* (relayerId, signTransactionRequest, options = {}) {
            // verify required parameter 'relayerId' is not null or undefined
            (0, common_1.assertParamExists)('signTransaction', 'relayerId', relayerId);
            // verify required parameter 'signTransactionRequest' is not null or undefined
            (0, common_1.assertParamExists)('signTransaction', 'signTransactionRequest', signTransactionRequest);
            const localVarPath = `/api/v1/relayers/{relayer_id}/sign-transaction`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(signTransactionRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Signs typed data using the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SignTypedDataRequest} signTypedDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signTypedData: (relayerId_1, signTypedDataRequest_1, ...args_1) => __awaiter(this, [relayerId_1, signTypedDataRequest_1, ...args_1], void 0, function* (relayerId, signTypedDataRequest, options = {}) {
            // verify required parameter 'relayerId' is not null or undefined
            (0, common_1.assertParamExists)('signTypedData', 'relayerId', relayerId);
            // verify required parameter 'signTypedDataRequest' is not null or undefined
            (0, common_1.assertParamExists)('signTypedData', 'signTypedDataRequest', signTypedDataRequest);
            const localVarPath = `/api/v1/relayers/{relayer_id}/sign-typed-data`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(signTypedDataRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Updates a relayer\'s information based on the provided update request.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {UpdateRelayerRequest} updateRelayerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRelayer: (relayerId_1, updateRelayerRequest_1, ...args_1) => __awaiter(this, [relayerId_1, updateRelayerRequest_1, ...args_1], void 0, function* (relayerId, updateRelayerRequest, options = {}) {
            // verify required parameter 'relayerId' is not null or undefined
            (0, common_1.assertParamExists)('updateRelayer', 'relayerId', relayerId);
            // verify required parameter 'updateRelayerRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateRelayer', 'updateRelayerRequest', updateRelayerRequest);
            const localVarPath = `/api/v1/relayers/{relayer_id}`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateRelayerRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.RelayersApiAxiosParamCreator = RelayersApiAxiosParamCreator;
/**
 * RelayersApi - functional programming interface
 * @export
 */
const RelayersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.RelayersApiAxiosParamCreator)(configuration);
    return {
        /**
         * This endpoint builds a transaction where the relayer will pay the network fees on behalf of the user. The user pays fees in a token of their choice (e.g., USDC) instead of the native network currency.  The endpoint accepts either a pre-built transaction XDR or a set of operations to build a transaction from. It returns a prepared transaction that includes: - The transaction XDR (base64 encoded) ready for signing - The fee amount in both the fee token and native currency (stroops for Stellar) - The fee token identifier - The transaction validity timestamp  After receiving the prepared transaction, the user must sign it and submit it through the standard transaction submission endpoint. For Stellar, the transaction will be wrapped in a fee-bump transaction where the relayer pays the network fees.
         * @summary Prepares a sponsored (gasless) transaction with fee payments.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SponsoredTransactionBuildRequest} sponsoredTransactionBuildRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildSponsoredTransaction(relayerId, sponsoredTransactionBuildRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.buildSponsoredTransaction(relayerId, sponsoredTransactionBuildRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RelayersApi.buildSponsoredTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Cancels a specific transaction by its ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {string} transactionId The unique identifier of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransaction(relayerId, transactionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelTransaction(relayerId, transactionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RelayersApi.cancelTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Creates a new relayer.
         * @param {CreateRelayerRequest} createRelayerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelayer(createRelayerRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createRelayer(createRelayerRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RelayersApi.createRelayer']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Deletes all pending transactions for a specific relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePendingTransactions(relayerId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deletePendingTransactions(relayerId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RelayersApi.deletePendingTransactions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Deletes a relayer by ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelayer(relayerId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteRelayer(relayerId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RelayersApi.deleteRelayer']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Retrieves details of a specific relayer by ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayer(relayerId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRelayer(relayerId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RelayersApi.getRelayer']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Retrieves the balance of a specific relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayerBalance(relayerId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRelayerBalance(relayerId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RelayersApi.getRelayerBalance']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Fetches the current status of a specific relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayerStatus(relayerId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRelayerStatus(relayerId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RelayersApi.getRelayerStatus']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Retrieves a specific transaction by its ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {string} transactionId The unique identifier of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById(relayerId, transactionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTransactionById(relayerId, transactionId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RelayersApi.getTransactionById']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Retrieves a transaction by its nonce value.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {number} nonce The nonce of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByNonce(relayerId, nonce, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTransactionByNonce(relayerId, nonce, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RelayersApi.getTransactionByNonce']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Note: OpenAPI documentation for these endpoints can be found in the `openapi.rs` file  Lists all relayers with pagination support.
         * @summary Relayer routes implementation
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [perPage] Number of items per page (default: 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRelayers(page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listRelayers(page, perPage, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RelayersApi.listRelayers']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Lists all transactions for a specific relayer with pagination.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [perPage] Number of items per page (default: 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions(relayerId, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTransactions(relayerId, page, perPage, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RelayersApi.listTransactions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint provides fee estimation for transactions where the relayer will pay the network fees on behalf of the user. The user pays fees in a token of their choice (e.g., USDC) instead of the native network currency (e.g., XLM for Stellar).  The endpoint accepts either a pre-built transaction XDR or a set of operations to build a transaction from. It returns the estimated fee amount in the specified fee token and the conversion rate from the native currency.
         * @summary Estimates fees for a sponsored (gasless) transaction.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SponsoredTransactionQuoteRequest} sponsoredTransactionQuoteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteSponsoredTransaction(relayerId, sponsoredTransactionQuoteRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.quoteSponsoredTransaction(relayerId, sponsoredTransactionQuoteRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RelayersApi.quoteSponsoredTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Replaces a specific transaction with a new one.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {string} transactionId The unique identifier of the transaction
         * @param {NetworkTransactionRequest} networkTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceTransaction(relayerId, transactionId, networkTransactionRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.replaceTransaction(relayerId, transactionId, networkTransactionRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RelayersApi.replaceTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Performs a JSON-RPC call using the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {JsonRpcRequestNetworkRpcRequest} jsonRpcRequestNetworkRpcRequest JSON-RPC request with method and parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpc(relayerId, jsonRpcRequestNetworkRpcRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.rpc(relayerId, jsonRpcRequestNetworkRpcRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RelayersApi.rpc']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Sends a transaction through the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {NetworkTransactionRequest} networkTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction(relayerId, networkTransactionRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.sendTransaction(relayerId, networkTransactionRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RelayersApi.sendTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Signs data using the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SignDataRequest} signDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sign(relayerId, signDataRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.sign(relayerId, signDataRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RelayersApi.sign']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Signs a transaction using the specified relayer (Stellar only).
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SignTransactionRequest} signTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signTransaction(relayerId, signTransactionRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.signTransaction(relayerId, signTransactionRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RelayersApi.signTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Signs typed data using the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SignTypedDataRequest} signTypedDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signTypedData(relayerId, signTypedDataRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.signTypedData(relayerId, signTypedDataRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RelayersApi.signTypedData']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Updates a relayer\'s information based on the provided update request.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {UpdateRelayerRequest} updateRelayerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRelayer(relayerId, updateRelayerRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateRelayer(relayerId, updateRelayerRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RelayersApi.updateRelayer']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.RelayersApiFp = RelayersApiFp;
/**
 * RelayersApi - factory interface
 * @export
 */
const RelayersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.RelayersApiFp)(configuration);
    return {
        /**
         * This endpoint builds a transaction where the relayer will pay the network fees on behalf of the user. The user pays fees in a token of their choice (e.g., USDC) instead of the native network currency.  The endpoint accepts either a pre-built transaction XDR or a set of operations to build a transaction from. It returns a prepared transaction that includes: - The transaction XDR (base64 encoded) ready for signing - The fee amount in both the fee token and native currency (stroops for Stellar) - The fee token identifier - The transaction validity timestamp  After receiving the prepared transaction, the user must sign it and submit it through the standard transaction submission endpoint. For Stellar, the transaction will be wrapped in a fee-bump transaction where the relayer pays the network fees.
         * @summary Prepares a sponsored (gasless) transaction with fee payments.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SponsoredTransactionBuildRequest} sponsoredTransactionBuildRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildSponsoredTransaction(relayerId, sponsoredTransactionBuildRequest, options) {
            return localVarFp.buildSponsoredTransaction(relayerId, sponsoredTransactionBuildRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Cancels a specific transaction by its ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {string} transactionId The unique identifier of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransaction(relayerId, transactionId, options) {
            return localVarFp.cancelTransaction(relayerId, transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a new relayer.
         * @param {CreateRelayerRequest} createRelayerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelayer(createRelayerRequest, options) {
            return localVarFp.createRelayer(createRelayerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes all pending transactions for a specific relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePendingTransactions(relayerId, options) {
            return localVarFp.deletePendingTransactions(relayerId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a relayer by ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelayer(relayerId, options) {
            return localVarFp.deleteRelayer(relayerId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieves details of a specific relayer by ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayer(relayerId, options) {
            return localVarFp.getRelayer(relayerId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieves the balance of a specific relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayerBalance(relayerId, options) {
            return localVarFp.getRelayerBalance(relayerId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Fetches the current status of a specific relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayerStatus(relayerId, options) {
            return localVarFp.getRelayerStatus(relayerId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieves a specific transaction by its ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {string} transactionId The unique identifier of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById(relayerId, transactionId, options) {
            return localVarFp.getTransactionById(relayerId, transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieves a transaction by its nonce value.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {number} nonce The nonce of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByNonce(relayerId, nonce, options) {
            return localVarFp.getTransactionByNonce(relayerId, nonce, options).then((request) => request(axios, basePath));
        },
        /**
         * Note: OpenAPI documentation for these endpoints can be found in the `openapi.rs` file  Lists all relayers with pagination support.
         * @summary Relayer routes implementation
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [perPage] Number of items per page (default: 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRelayers(page, perPage, options) {
            return localVarFp.listRelayers(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Lists all transactions for a specific relayer with pagination.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [perPage] Number of items per page (default: 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions(relayerId, page, perPage, options) {
            return localVarFp.listTransactions(relayerId, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint provides fee estimation for transactions where the relayer will pay the network fees on behalf of the user. The user pays fees in a token of their choice (e.g., USDC) instead of the native network currency (e.g., XLM for Stellar).  The endpoint accepts either a pre-built transaction XDR or a set of operations to build a transaction from. It returns the estimated fee amount in the specified fee token and the conversion rate from the native currency.
         * @summary Estimates fees for a sponsored (gasless) transaction.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SponsoredTransactionQuoteRequest} sponsoredTransactionQuoteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteSponsoredTransaction(relayerId, sponsoredTransactionQuoteRequest, options) {
            return localVarFp.quoteSponsoredTransaction(relayerId, sponsoredTransactionQuoteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Replaces a specific transaction with a new one.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {string} transactionId The unique identifier of the transaction
         * @param {NetworkTransactionRequest} networkTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceTransaction(relayerId, transactionId, networkTransactionRequest, options) {
            return localVarFp.replaceTransaction(relayerId, transactionId, networkTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Performs a JSON-RPC call using the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {JsonRpcRequestNetworkRpcRequest} jsonRpcRequestNetworkRpcRequest JSON-RPC request with method and parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpc(relayerId, jsonRpcRequestNetworkRpcRequest, options) {
            return localVarFp.rpc(relayerId, jsonRpcRequestNetworkRpcRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Sends a transaction through the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {NetworkTransactionRequest} networkTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction(relayerId, networkTransactionRequest, options) {
            return localVarFp.sendTransaction(relayerId, networkTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Signs data using the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SignDataRequest} signDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sign(relayerId, signDataRequest, options) {
            return localVarFp.sign(relayerId, signDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Signs a transaction using the specified relayer (Stellar only).
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SignTransactionRequest} signTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signTransaction(relayerId, signTransactionRequest, options) {
            return localVarFp.signTransaction(relayerId, signTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Signs typed data using the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SignTypedDataRequest} signTypedDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signTypedData(relayerId, signTypedDataRequest, options) {
            return localVarFp.signTypedData(relayerId, signTypedDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a relayer\'s information based on the provided update request.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {UpdateRelayerRequest} updateRelayerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRelayer(relayerId, updateRelayerRequest, options) {
            return localVarFp.updateRelayer(relayerId, updateRelayerRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.RelayersApiFactory = RelayersApiFactory;
/**
 * RelayersApi - object-oriented interface
 * @export
 * @class RelayersApi
 * @extends {BaseAPI}
 */
class RelayersApi extends base_1.BaseAPI {
    /**
     * This endpoint builds a transaction where the relayer will pay the network fees on behalf of the user. The user pays fees in a token of their choice (e.g., USDC) instead of the native network currency.  The endpoint accepts either a pre-built transaction XDR or a set of operations to build a transaction from. It returns a prepared transaction that includes: - The transaction XDR (base64 encoded) ready for signing - The fee amount in both the fee token and native currency (stroops for Stellar) - The fee token identifier - The transaction validity timestamp  After receiving the prepared transaction, the user must sign it and submit it through the standard transaction submission endpoint. For Stellar, the transaction will be wrapped in a fee-bump transaction where the relayer pays the network fees.
     * @summary Prepares a sponsored (gasless) transaction with fee payments.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {SponsoredTransactionBuildRequest} sponsoredTransactionBuildRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    buildSponsoredTransaction(relayerId, sponsoredTransactionBuildRequest, options) {
        return (0, exports.RelayersApiFp)(this.configuration).buildSponsoredTransaction(relayerId, sponsoredTransactionBuildRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Cancels a specific transaction by its ID.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {string} transactionId The unique identifier of the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    cancelTransaction(relayerId, transactionId, options) {
        return (0, exports.RelayersApiFp)(this.configuration).cancelTransaction(relayerId, transactionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates a new relayer.
     * @param {CreateRelayerRequest} createRelayerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    createRelayer(createRelayerRequest, options) {
        return (0, exports.RelayersApiFp)(this.configuration).createRelayer(createRelayerRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes all pending transactions for a specific relayer.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    deletePendingTransactions(relayerId, options) {
        return (0, exports.RelayersApiFp)(this.configuration).deletePendingTransactions(relayerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a relayer by ID.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    deleteRelayer(relayerId, options) {
        return (0, exports.RelayersApiFp)(this.configuration).deleteRelayer(relayerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieves details of a specific relayer by ID.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    getRelayer(relayerId, options) {
        return (0, exports.RelayersApiFp)(this.configuration).getRelayer(relayerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieves the balance of a specific relayer.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    getRelayerBalance(relayerId, options) {
        return (0, exports.RelayersApiFp)(this.configuration).getRelayerBalance(relayerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Fetches the current status of a specific relayer.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    getRelayerStatus(relayerId, options) {
        return (0, exports.RelayersApiFp)(this.configuration).getRelayerStatus(relayerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieves a specific transaction by its ID.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {string} transactionId The unique identifier of the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    getTransactionById(relayerId, transactionId, options) {
        return (0, exports.RelayersApiFp)(this.configuration).getTransactionById(relayerId, transactionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieves a transaction by its nonce value.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {number} nonce The nonce of the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    getTransactionByNonce(relayerId, nonce, options) {
        return (0, exports.RelayersApiFp)(this.configuration).getTransactionByNonce(relayerId, nonce, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Note: OpenAPI documentation for these endpoints can be found in the `openapi.rs` file  Lists all relayers with pagination support.
     * @summary Relayer routes implementation
     * @param {number} [page] Page number for pagination (starts at 1)
     * @param {number} [perPage] Number of items per page (default: 10)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    listRelayers(page, perPage, options) {
        return (0, exports.RelayersApiFp)(this.configuration).listRelayers(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Lists all transactions for a specific relayer with pagination.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {number} [page] Page number for pagination (starts at 1)
     * @param {number} [perPage] Number of items per page (default: 10)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    listTransactions(relayerId, page, perPage, options) {
        return (0, exports.RelayersApiFp)(this.configuration).listTransactions(relayerId, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint provides fee estimation for transactions where the relayer will pay the network fees on behalf of the user. The user pays fees in a token of their choice (e.g., USDC) instead of the native network currency (e.g., XLM for Stellar).  The endpoint accepts either a pre-built transaction XDR or a set of operations to build a transaction from. It returns the estimated fee amount in the specified fee token and the conversion rate from the native currency.
     * @summary Estimates fees for a sponsored (gasless) transaction.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {SponsoredTransactionQuoteRequest} sponsoredTransactionQuoteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    quoteSponsoredTransaction(relayerId, sponsoredTransactionQuoteRequest, options) {
        return (0, exports.RelayersApiFp)(this.configuration).quoteSponsoredTransaction(relayerId, sponsoredTransactionQuoteRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Replaces a specific transaction with a new one.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {string} transactionId The unique identifier of the transaction
     * @param {NetworkTransactionRequest} networkTransactionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    replaceTransaction(relayerId, transactionId, networkTransactionRequest, options) {
        return (0, exports.RelayersApiFp)(this.configuration).replaceTransaction(relayerId, transactionId, networkTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Performs a JSON-RPC call using the specified relayer.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {JsonRpcRequestNetworkRpcRequest} jsonRpcRequestNetworkRpcRequest JSON-RPC request with method and parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    rpc(relayerId, jsonRpcRequestNetworkRpcRequest, options) {
        return (0, exports.RelayersApiFp)(this.configuration).rpc(relayerId, jsonRpcRequestNetworkRpcRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Sends a transaction through the specified relayer.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {NetworkTransactionRequest} networkTransactionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    sendTransaction(relayerId, networkTransactionRequest, options) {
        return (0, exports.RelayersApiFp)(this.configuration).sendTransaction(relayerId, networkTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Signs data using the specified relayer.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {SignDataRequest} signDataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    sign(relayerId, signDataRequest, options) {
        return (0, exports.RelayersApiFp)(this.configuration).sign(relayerId, signDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Signs a transaction using the specified relayer (Stellar only).
     * @param {string} relayerId The unique identifier of the relayer
     * @param {SignTransactionRequest} signTransactionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    signTransaction(relayerId, signTransactionRequest, options) {
        return (0, exports.RelayersApiFp)(this.configuration).signTransaction(relayerId, signTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Signs typed data using the specified relayer.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {SignTypedDataRequest} signTypedDataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    signTypedData(relayerId, signTypedDataRequest, options) {
        return (0, exports.RelayersApiFp)(this.configuration).signTypedData(relayerId, signTypedDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a relayer\'s information based on the provided update request.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {UpdateRelayerRequest} updateRelayerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    updateRelayer(relayerId, updateRelayerRequest, options) {
        return (0, exports.RelayersApiFp)(this.configuration).updateRelayer(relayerId, updateRelayerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RelayersApi = RelayersApi;
