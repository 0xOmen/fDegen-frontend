"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  EvmAdapter: () => EvmAdapter,
  abiComparisonService: () => abiComparisonService,
  arbitrumMainnet: () => arbitrumMainnet,
  arbitrumSepolia: () => arbitrumSepolia,
  avalancheFuji: () => avalancheFuji,
  avalancheMainnet: () => avalancheMainnet,
  baseMainnet: () => baseMainnet,
  baseSepolia: () => baseSepolia,
  bscMainnet: () => bscMainnet,
  bscTestnet: () => bscTestnet,
  ethereumMainnet: () => ethereumMainnet,
  ethereumSepolia: () => ethereumSepolia,
  evmAdapterConfig: () => evmAdapterConfig,
  evmMainnetNetworks: () => evmMainnetNetworks,
  evmNetworks: () => evmNetworks,
  evmTestnetNetworks: () => evmTestnetNetworks,
  extractRainbowKitCustomizations: () => extractRainbowKitCustomizations,
  isEvmContractArtifacts: () => isEvmContractArtifacts,
  isRainbowKitCustomizations: () => isRainbowKitCustomizations,
  lineaMainnet: () => lineaMainnet,
  lineaSepolia: () => lineaSepolia,
  optimismMainnet: () => optimismMainnet,
  optimismSepolia: () => optimismSepolia,
  polygonAmoy: () => polygonAmoy,
  polygonMainnet: () => polygonMainnet,
  polygonZkEvmCardona: () => polygonZkEvmCardona,
  polygonZkEvmMainnet: () => polygonZkEvmMainnet,
  scrollMainnet: () => scrollMainnet,
  scrollSepolia: () => scrollSepolia,
  zkSyncEraMainnet: () => zkSyncEraMainnet,
  zksyncSepoliaTestnet: () => zksyncSepoliaTestnet
});
module.exports = __toCommonJS(index_exports);

// ../adapter-evm-core/dist/index.js
var import_viem = require("viem");
var import_viem2 = require("viem");
var import_ui_utils = require("@openzeppelin/ui-utils");
var import_ui_utils2 = require("@openzeppelin/ui-utils");
var import_viem3 = require("viem");
var import_relayer_sdk = require("@openzeppelin/relayer-sdk");
var import_ui_utils3 = require("@openzeppelin/ui-utils");
var import_ui_utils4 = require("@openzeppelin/ui-utils");
var import_ui_utils5 = require("@openzeppelin/ui-utils");
var import_lodash = require("lodash");
var import_ui_utils6 = require("@openzeppelin/ui-utils");
var import_ui_utils7 = require("@openzeppelin/ui-utils");
var import_ui_utils8 = require("@openzeppelin/ui-utils");
var import_viem4 = require("viem");
var import_ui_utils9 = require("@openzeppelin/ui-utils");
var import_viem5 = require("viem");
var import_ui_utils10 = require("@openzeppelin/ui-utils");
var import_ui_utils11 = require("@openzeppelin/ui-utils");
var import_ui_utils12 = require("@openzeppelin/ui-utils");
var import_lodash2 = require("lodash");
var import_ui_utils13 = require("@openzeppelin/ui-utils");
var import_viem6 = require("viem");
var import_ui_utils14 = require("@openzeppelin/ui-utils");
var import_ui_utils15 = require("@openzeppelin/ui-utils");
var import_viem7 = require("viem");
var import_ui_utils16 = require("@openzeppelin/ui-utils");
var import_viem8 = require("viem");
var import_ui_utils17 = require("@openzeppelin/ui-utils");
var import_ui_utils18 = require("@openzeppelin/ui-utils");
var import_react = require("react");
var import_react2 = require("react");
var import_react3 = require("react");
var import_ui_utils19 = require("@openzeppelin/ui-utils");
var import_jsx_runtime = require("react/jsx-runtime");
var import_lucide_react = require("lucide-react");
var import_react4 = require("react");
var import_ui_components = require("@openzeppelin/ui-components");
var import_ui_react = require("@openzeppelin/ui-react");
var import_ui_utils20 = require("@openzeppelin/ui-utils");
var import_react5 = require("react");
var import_ui_components2 = require("@openzeppelin/ui-components");
var import_ui_react2 = require("@openzeppelin/ui-react");
var import_jsx_runtime2 = require("react/jsx-runtime");
var import_jsx_runtime3 = require("react/jsx-runtime");
var import_lucide_react2 = require("lucide-react");
var import_ui_components3 = require("@openzeppelin/ui-components");
var import_ui_react3 = require("@openzeppelin/ui-react");
var import_ui_utils21 = require("@openzeppelin/ui-utils");
var import_jsx_runtime4 = require("react/jsx-runtime");
var import_lucide_react3 = require("lucide-react");
var import_ui_components4 = require("@openzeppelin/ui-components");
var import_ui_react4 = require("@openzeppelin/ui-react");
var import_ui_utils22 = require("@openzeppelin/ui-utils");
var import_jsx_runtime5 = require("react/jsx-runtime");
var import_ui_utils23 = require("@openzeppelin/ui-utils");
var import_connectors = require("@wagmi/connectors");
var import_core = require("@wagmi/core");
var import_viem9 = require("viem");
var import_ui_utils24 = require("@openzeppelin/ui-utils");
var import_ui_utils25 = require("@openzeppelin/ui-utils");
var import_lucide_react4 = require("lucide-react");
var import_react6 = require("react");
var import_ui_components5 = require("@openzeppelin/ui-components");
var import_ui_utils26 = require("@openzeppelin/ui-utils");
var import_jsx_runtime6 = require("react/jsx-runtime");
var import_core2 = require("@wagmi/core");
var import_ui_utils27 = require("@openzeppelin/ui-utils");
var import_ui_utils28 = require("@openzeppelin/ui-utils");
var import_ui_utils29 = require("@openzeppelin/ui-utils");
var import_ui_utils30 = require("@openzeppelin/ui-utils");
var import_ui_types = require("@openzeppelin/ui-types");
var import_ui_utils31 = require("@openzeppelin/ui-utils");
var import_ui_utils32 = require("@openzeppelin/ui-utils");
var __defProp2 = Object.defineProperty;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
};
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
function isEvmContractArtifacts(obj) {
  return typeof obj === "object" && obj !== null && typeof obj.contractAddress === "string";
}
var init_artifacts = __esm({
  "src/types/artifacts.ts"() {
    "use strict";
  }
});
function validateAndConvertEvmArtifacts(source) {
  if (typeof source === "string") {
    return { contractAddress: source };
  }
  if (!isEvmContractArtifacts(source)) {
    throw new Error(
      "Invalid contract artifacts provided. Expected an object with contractAddress property."
    );
  }
  return source;
}
var init_artifacts2 = __esm({
  "src/utils/artifacts.ts"() {
    "use strict";
    init_artifacts();
  }
});
function stringifyWithBigInt(value, space) {
  const replacer = (_key, val) => {
    if (typeof val === "bigint") {
      return val.toString();
    }
    return val;
  };
  return JSON.stringify(value, replacer, space);
}
var init_json = __esm({
  "src/utils/json.ts"() {
    "use strict";
  }
});
function formatMethodName(name) {
  if (!name) return "";
  return name.replace(/([A-Z])/g, " $1").replace(/^./, (str) => str.toUpperCase()).trim();
}
function formatInputName(name, type) {
  if (!name || name === "") {
    return `Parameter (${type})`;
  }
  return name.replace(/([A-Z])/g, " $1").replace(/_/g, " ").replace(/^./, (str) => str.toUpperCase()).trim();
}
var init_formatting = __esm({
  "src/utils/formatting.ts"() {
    "use strict";
  }
});
function isValidEvmAddress(address) {
  return (0, import_viem.isAddress)(address);
}
var init_validation = __esm({
  "src/utils/validation.ts"() {
    "use strict";
  }
});
var weiToGwei;
var gweiToWei;
var init_gas = __esm({
  "src/utils/gas.ts"() {
    "use strict";
    weiToGwei = (wei) => {
      if (!wei) return void 0;
      return parseFloat((0, import_viem2.formatGwei)(BigInt(wei)));
    };
    gweiToWei = (gwei) => {
      if (!gwei) return void 0;
      return Number((0, import_viem2.parseGwei)(gwei.toString()));
    };
  }
});
var utils_exports = {};
__export2(utils_exports, {
  formatInputName: () => formatInputName,
  formatMethodName: () => formatMethodName,
  gweiToWei: () => gweiToWei,
  isValidEvmAddress: () => isValidEvmAddress,
  stringifyWithBigInt: () => stringifyWithBigInt,
  validateAndConvertEvmArtifacts: () => validateAndConvertEvmArtifacts,
  weiToGwei: () => weiToGwei
});
var init_utils = __esm({
  "src/utils/index.ts"() {
    "use strict";
    init_artifacts2();
    init_json();
    init_formatting();
    init_validation();
    init_gas();
  }
});
async function validateEoaConfig(config, walletStatus) {
  if (!config.allowAny) {
    if (!config.specificAddress) {
      return "EOA execution selected, but no specific address was provided when 'allowAny' is false.";
    }
    if (!isValidEvmAddress(config.specificAddress)) {
      return `Invalid specific EOA address format: ${config.specificAddress}`;
    }
    if (walletStatus?.isConnected && walletStatus.address) {
      if (walletStatus.address.toLowerCase() !== config.specificAddress.toLowerCase()) {
        return `Connected wallet address (${walletStatus.address}) does not match the required specific EOA address (${config.specificAddress}). Please connect the correct wallet.`;
      }
    } else if (walletStatus?.isConnected && !walletStatus.address) {
      import_ui_utils.logger.warn(
        SYSTEM_LOG_TAG,
        "Wallet is connected but address is unavailable for EOA validation."
      );
      return "Connected wallet address is not available for validation against specific EOA.";
    }
  }
  return true;
}
var SYSTEM_LOG_TAG;
var init_eoa = __esm({
  "src/validation/eoa.ts"() {
    "use strict";
    init_validation();
    SYSTEM_LOG_TAG = "EoaValidator";
  }
});
var eoa_exports = {};
__export2(eoa_exports, {
  EoaExecutionStrategy: () => EoaExecutionStrategy
});
var SYSTEM_LOG_TAG2;
var EoaExecutionStrategy;
var init_eoa2 = __esm({
  "src/transaction/eoa.ts"() {
    "use strict";
    init_eoa();
    SYSTEM_LOG_TAG2 = "EoaExecutionStrategy";
    EoaExecutionStrategy = class {
      async execute(transactionData, executionConfig, walletImplementation, onStatusChange, _runtimeApiKey) {
        const { walletClient, accountStatus } = await this.getAuthenticatedWalletClient(walletImplementation);
        const eoaConfig = executionConfig;
        const validationResult = await validateEoaConfig(eoaConfig, {
          isConnected: accountStatus.isConnected,
          address: accountStatus.address
        });
        if (validationResult !== true) {
          throw new Error(validationResult);
        }
        import_ui_utils2.logger.info(SYSTEM_LOG_TAG2, "Using EOA execution strategy.");
        try {
          import_ui_utils2.logger.debug(SYSTEM_LOG_TAG2, "Calling walletClient.writeContract with:", {
            account: accountStatus.address,
            address: transactionData.address,
            abi: transactionData.abi,
            functionName: transactionData.functionName,
            args: transactionData.args,
            value: transactionData.value,
            chain: walletClient.chain
          });
          onStatusChange("pendingSignature", {});
          const hash = await walletClient.writeContract({
            account: accountStatus.address,
            address: transactionData.address,
            abi: transactionData.abi,
            functionName: transactionData.functionName,
            args: transactionData.args,
            value: transactionData.value,
            chain: walletClient.chain
          });
          import_ui_utils2.logger.info(SYSTEM_LOG_TAG2, "EOA Transaction initiated. Hash:", hash);
          return { txHash: hash };
        } catch (error) {
          import_ui_utils2.logger.error(SYSTEM_LOG_TAG2, "Error during EOA writeContract call:", error);
          const errorMessage = error instanceof Error ? error.message : "Unknown EOA transaction error";
          throw new Error(`Transaction failed (EOA): ${errorMessage}`);
        }
      }
      async getAuthenticatedWalletClient(walletImplementation) {
        const walletClient = await walletImplementation.getWalletClient();
        if (!walletClient) {
          import_ui_utils2.logger.error(SYSTEM_LOG_TAG2, "Wallet client not available. Is wallet connected?");
          throw new Error("Wallet is not connected or client is unavailable.");
        }
        const accountStatus = walletImplementation.getWalletConnectionStatus();
        if (!accountStatus.isConnected || !accountStatus.address) {
          import_ui_utils2.logger.error(SYSTEM_LOG_TAG2, "Account not available. Is wallet connected?");
          throw new Error("Wallet is not connected or account address is unavailable.");
        }
        return { walletClient, accountStatus };
      }
    };
  }
});
var relayer_exports = {};
__export2(relayer_exports, {
  RelayerExecutionStrategy: () => RelayerExecutionStrategy
});
var RelayerExecutionStrategy;
var init_relayer = __esm({
  "src/transaction/relayer.ts"() {
    "use strict";
    RelayerExecutionStrategy = class {
      async execute(transactionData, executionConfig, _walletImplementation, onStatusChange, runtimeApiKey) {
        const relayerConfig = executionConfig;
        if (!runtimeApiKey) {
          throw new Error("API Key is required for Relayer execution.");
        }
        const { transactionId } = await this.sendTransactionViaRelayer(
          transactionData,
          relayerConfig,
          runtimeApiKey
        );
        onStatusChange("pendingRelayer", { transactionId });
        const sdkConfig = new import_relayer_sdk.Configuration({
          basePath: relayerConfig.serviceUrl,
          accessToken: runtimeApiKey
        });
        const txHash = await this.pollForTransactionHash(
          relayerConfig.relayer.relayerId,
          transactionId,
          sdkConfig
        );
        return { txHash };
      }
      /**
       * Fetches and filters relayers for a specific EVM network from the OpenZeppelin Relayer service.
       * This function handles pagination to retrieve all available relayers.
       *
       * @param serviceUrl - The base URL of the relayer service.
       * @param accessToken - The session-based API key for authentication.
       * @param networkConfig - EVM-compatible network configuration to filter relayers by (works with any ecosystem).
       * @returns A promise that resolves to an array of compatible relayer details.
       * @throws If the API call fails or returns an unsuccessful response.
       */
      async getEvmRelayers(serviceUrl, accessToken, networkConfig) {
        import_ui_utils3.logger.info(
          "[Relayer] Getting relayers with access token",
          accessToken.slice(0, 5).padEnd(accessToken.length, "*")
        );
        const sdkConfig = new import_relayer_sdk.Configuration({
          basePath: serviceUrl,
          accessToken
        });
        const relayersApi = new import_relayer_sdk.RelayersApi(sdkConfig);
        let allRelayers = [];
        let currentPage = 1;
        let totalItems = 0;
        let hasMore = true;
        do {
          const { data } = await relayersApi.listRelayers(currentPage, 100);
          if (!data.success || !data.data) {
            throw new Error(`Failed to fetch relayers on page ${currentPage}.`);
          }
          allRelayers = [...allRelayers, ...data.data];
          totalItems = data.pagination?.total_items || 0;
          if (allRelayers.length >= totalItems) {
            hasMore = false;
          } else {
            currentPage++;
          }
        } while (hasMore);
        return allRelayers.filter(
          (r) => r.network_type === "evm" && networkConfig.id.includes(r.network)
        ).map((r) => ({
          relayerId: r.id,
          name: r.name,
          address: r.address || "",
          network: r.network,
          paused: r.paused || false
        }));
      }
      /**
       * Fetches comprehensive information about a specific relayer including balance and status.
       * This function combines multiple SDK API calls to provide rich relayer details.
       *
       * @param serviceUrl - The base URL of the relayer service.
       * @param accessToken - The session-based API key for authentication.
       * @param relayerId - The unique identifier of the relayer.
       * @param networkConfig - EVM-compatible network configuration to get the native currency symbol (works with any ecosystem).
       * @returns A promise that resolves to enhanced relayer details including balance and status.
       * @throws If any API call fails or returns an unsuccessful response.
       */
      async getEvmRelayer(serviceUrl, accessToken, relayerId, networkConfig) {
        import_ui_utils3.logger.info("[Relayer] Getting detailed relayer info", relayerId);
        const sdkConfig = new import_relayer_sdk.Configuration({
          basePath: serviceUrl,
          accessToken
        });
        const relayersApi = new import_relayer_sdk.RelayersApi(sdkConfig);
        try {
          const [relayerResponse, balanceResponse, statusResponse] = await Promise.all([
            relayersApi.getRelayer(relayerId),
            relayersApi.getRelayerBalance(relayerId).catch((err) => {
              import_ui_utils3.logger.warn("[Relayer] Failed to fetch balance", err);
              return null;
            }),
            relayersApi.getRelayerStatus(relayerId).catch((err) => {
              import_ui_utils3.logger.warn("[Relayer] Failed to fetch status", err);
              return null;
            })
          ]);
          if (!relayerResponse.data.success || !relayerResponse.data.data) {
            throw new Error(`Failed to fetch relayer details for ID: ${relayerId}`);
          }
          const relayerData = relayerResponse.data.data;
          const enhancedDetails = {
            relayerId: relayerData.id,
            name: relayerData.name,
            address: relayerData.address || "",
            network: relayerData.network,
            paused: relayerData.paused || false,
            systemDisabled: relayerData.system_disabled || false
          };
          if (balanceResponse?.data?.success && balanceResponse.data.data?.balance) {
            try {
              const balanceInWei = BigInt(balanceResponse.data.data.balance);
              const balanceInEth = (0, import_viem3.formatEther)(balanceInWei);
              const currencySymbol = networkConfig.nativeCurrency.symbol;
              enhancedDetails.balance = `${balanceInEth} ${currencySymbol}`;
            } catch (error) {
              import_ui_utils3.logger.warn("[Relayer] Failed to format balance, using raw value", String(error));
              enhancedDetails.balance = String(balanceResponse.data.data.balance);
            }
          }
          if (statusResponse?.data?.success && statusResponse.data.data) {
            const statusData = statusResponse.data.data;
            if (statusData.network_type === "evm") {
              if (statusData.nonce !== void 0 && statusData.nonce !== null) {
                enhancedDetails.nonce = String(statusData.nonce);
              }
              if (statusData.pending_transactions_count !== void 0) {
                enhancedDetails.pendingTransactionsCount = statusData.pending_transactions_count;
              }
              if (statusData.last_confirmed_transaction_timestamp) {
                enhancedDetails.lastConfirmedTransactionTimestamp = statusData.last_confirmed_transaction_timestamp;
              }
            }
          }
          import_ui_utils3.logger.info("[Relayer] Retrieved enhanced relayer details", JSON.stringify(enhancedDetails));
          return enhancedDetails;
        } catch (error) {
          import_ui_utils3.logger.error(
            "[Relayer] Failed to get relayer details",
            error instanceof Error ? error.message : String(error)
          );
          throw error;
        }
      }
      /**
       * Submits a transaction to the relayer service for asynchronous processing.
       * @param transactionData The contract write parameters.
       * @param executionConfig The relayer-specific execution configuration.
       * @param runtimeApiKey The user's session-only API key.
       * @returns A promise that resolves to an object containing the transaction ID assigned by the relayer.
       */
      async sendTransactionViaRelayer(transactionData, executionConfig, runtimeApiKey) {
        const data = (0, import_viem3.encodeFunctionData)({
          abi: transactionData.abi,
          functionName: transactionData.functionName,
          args: transactionData.args
        });
        const evmOptions = executionConfig.transactionOptions;
        const valueBigint = transactionData.value ?? 0n;
        let valueNumber = 0;
        const MAX_SAFE = BigInt(Number.MAX_SAFE_INTEGER);
        if (valueBigint > MAX_SAFE) {
          import_ui_utils3.logger.warn(
            "[Relayer] Value exceeds JS safe integer. Truncating for request.",
            valueBigint.toString()
          );
          valueNumber = Number(MAX_SAFE);
        } else {
          valueNumber = Number(valueBigint);
        }
        const relayerTxRequest = {
          to: transactionData.address,
          data,
          value: valueNumber,
          // If no explicit gas limit is provided, keep a conservative default but warn.
          gas_limit: (() => {
            if (typeof evmOptions?.gasLimit === "number") return evmOptions.gasLimit;
            import_ui_utils3.logger.warn(
              "[Relayer]",
              "No gasLimit provided; using default 210000. Consider setting explicitly."
            );
            return 21e4;
          })(),
          // Note: The OpenZeppelin Relayer API requires exactly one gas pricing strategy to be provided.
          // Valid options are: speed, gas_price, or both max_fee_per_gas + max_priority_fee_per_gas.
          // If none are provided, the API will return a 400 Bad Request error.
          // Only include speed if explicitly set in options
          ...evmOptions?.speed !== void 0 && { speed: evmOptions.speed },
          // Include optional parameters only if provided
          ...evmOptions?.gasPrice !== void 0 && { gas_price: evmOptions.gasPrice },
          ...evmOptions?.maxFeePerGas !== void 0 && { max_fee_per_gas: evmOptions.maxFeePerGas },
          ...evmOptions?.maxPriorityFeePerGas !== void 0 && {
            max_priority_fee_per_gas: evmOptions.maxPriorityFeePerGas
          },
          ...evmOptions?.validUntil !== void 0 && { valid_until: evmOptions.validUntil }
        };
        const sdkConfig = new import_relayer_sdk.Configuration({
          basePath: executionConfig.serviceUrl,
          accessToken: runtimeApiKey
        });
        const relayersApi = new import_relayer_sdk.RelayersApi(sdkConfig);
        const result = await relayersApi.sendTransaction(
          executionConfig.relayer.relayerId,
          relayerTxRequest
        );
        if (!result.data.success || !result.data.data?.id) {
          throw new Error(`Relayer API failed to return a transaction ID. Error: ${result.data.error}`);
        }
        return { transactionId: result.data.data.id };
      }
      /**
       * Polls the relayer for a transaction's status until it is mined and has a hash, or fails.
       * @param relayerId The ID of the relayer processing the transaction.
       * @param transactionId The ID of the transaction to poll.
       * @param sdkConfig The SDK configuration containing the necessary authentication.
       * @returns A promise that resolves to the final transaction hash.
       * @throws If the transaction fails or polling times out.
       */
      async pollForTransactionHash(relayerId, transactionId, sdkConfig) {
        const relayersApi = new import_relayer_sdk.RelayersApi(sdkConfig);
        const POLLING_INTERVAL = 2e3;
        const POLLING_TIMEOUT = 3e5;
        const startTime = Date.now();
        while (Date.now() - startTime < POLLING_TIMEOUT) {
          const { data } = await relayersApi.getTransactionById(relayerId, transactionId);
          if (!data.success || !data.data) {
            throw new Error(`Failed to get transaction status for ID: ${transactionId}`);
          }
          const txResponse = data.data;
          if (txResponse.status === "mined" || txResponse.status === "confirmed") {
            if (!txResponse.hash) {
              throw new Error(
                `Transaction is confirmed but no hash was returned for ID: ${transactionId}`
              );
            }
            return txResponse.hash;
          }
          if (txResponse.status === "failed" || txResponse.status === "canceled" || txResponse.status === "expired") {
            throw new Error(
              `Transaction ${txResponse.status}: ${txResponse.status_reason || "No reason provided."}`
            );
          }
          await new Promise((resolve) => setTimeout(resolve, POLLING_INTERVAL));
        }
        throw new Error(`Polling for transaction hash timed out for ID: ${transactionId}`);
      }
    };
  }
});
init_utils();
function transformAbiToSchema(abi, contractName, address) {
  import_ui_utils4.logger.info("transformAbiToSchema", `Transforming ABI to ContractSchema for: ${contractName}`);
  const functions = [];
  for (const item of abi) {
    if (item.type === "function") {
      const abiFunctionItem = item;
      functions.push({
        // Generate a unique ID for the function within the schema.
        // This often combines name and input types to handle overloads.
        id: `${abiFunctionItem.name}_${abiFunctionItem.inputs?.map((i) => i.type).join("_") || ""}`,
        name: abiFunctionItem.name || "",
        // Fallback for unnamed functions (though rare).
        displayName: formatMethodName(abiFunctionItem.name || ""),
        // Create a more readable name for UI.
        // Recursively map ABI inputs and outputs to our FunctionParameter structure.
        // This ensures that any non-standard properties (like 'internalType') are stripped.
        inputs: mapAbiParametersToSchemaParameters(abiFunctionItem.inputs),
        outputs: mapAbiParametersToSchemaParameters(abiFunctionItem.outputs),
        type: "function",
        // Explicitly set, as we filtered for this type.
        stateMutability: abiFunctionItem.stateMutability,
        // Preserve EVM-specific state mutability.
        // Determine if the function modifies blockchain state based on its `stateMutability`.
        // This is a crucial piece of information for the UI (e.g., to differentiate read vs. write calls).
        modifiesState: !abiFunctionItem.stateMutability || // If undefined, assume it modifies state (safer default)
        !["view", "pure"].includes(abiFunctionItem.stateMutability)
      });
    }
  }
  const contractSchema = {
    ecosystem: "evm",
    // This transformer is specific to EVM.
    name: contractName,
    address,
    functions
  };
  import_ui_utils4.logger.info(
    "transformAbiToSchema",
    `Transformation complete. Found ${contractSchema.functions.length} functions.`
  );
  return contractSchema;
}
function mapAbiParametersToSchemaParameters(abiParams) {
  if (!abiParams) {
    return [];
  }
  return abiParams.map((param) => {
    const schemaParam = {
      name: param.name || "",
      // Ensure name is a string, fallback if undefined in ABI.
      type: param.type,
      // The raw type string from the ABI (e.g., 'uint256', 'address', 'tuple').
      displayName: formatInputName(param.name || "", param.type)
      // Generate a user-friendly name.
      // `description` is not a standard part of an ABI parameter, so it's not mapped here.
      // It can be added later by the user in the builder app UI.
    };
    if (param.type.startsWith("tuple") && "components" in param && // Type guard for discriminated union (AbiParameter)
    param.components && param.components.length > 0) {
      schemaParam.components = mapAbiParametersToSchemaParameters(
        param.components
      );
    }
    return schemaParam;
  });
}
function mapSchemaParameterToAbiParameter(param) {
  if (param.type.startsWith("tuple") && param.components && param.components.length > 0) {
    return {
      name: param.name || void 0,
      // ABI parameter names can be undefined (e.g., for return values).
      type: param.type,
      // Cast to satisfy viem's specific tuple type string.
      // Recursively map nested components back to AbiParameter format.
      components: param.components.map(mapSchemaParameterToAbiParameter)
    };
  }
  return {
    name: param.name || void 0,
    type: param.type
    // `internalType` is not part of our `FunctionParameter` model, so it's not added back here.
    // Other ABI-specific fields like `indexed` (for events) are also not relevant here as
    // this function is focused on function parameters for `AbiFunction`.
  };
}
function createAbiFunctionItem(functionDetails) {
  return {
    name: functionDetails.name,
    type: "function",
    inputs: functionDetails.inputs.map(mapSchemaParameterToAbiParameter),
    outputs: functionDetails.outputs?.map(mapSchemaParameterToAbiParameter) || [],
    stateMutability: functionDetails.stateMutability ?? "view"
  };
}
var ETHERSCAN_V2_BASE_URL = "https://api.etherscan.io/v2/api";
function buildV2ApiUrl(chainId, module2, action, params, apiKey) {
  const url = new URL(ETHERSCAN_V2_BASE_URL);
  url.searchParams.append("chainid", chainId.toString());
  url.searchParams.append("module", module2);
  url.searchParams.append("action", action);
  Object.entries(params).forEach(([key, value]) => {
    url.searchParams.append(key, value);
  });
  if (apiKey) {
    url.searchParams.append("apikey", apiKey);
  }
  return url.toString();
}
function shouldUseV2Api(networkConfig) {
  if (!networkConfig.supportsEtherscanV2) {
    return false;
  }
  return true;
}
async function loadAbiFromEtherscanV2(address, networkConfig) {
  const explorerConfig = resolveExplorerConfig(networkConfig);
  const url = buildV2ApiUrl(
    networkConfig.chainId,
    "contract",
    "getabi",
    { address },
    explorerConfig.apiKey
  );
  let response;
  try {
    import_ui_utils7.logger.info(
      "loadAbiFromEtherscanV2",
      `Fetching ABI from Etherscan V2 API for address: ${address} on chain ${networkConfig.chainId}`
    );
    response = await fetch(url);
  } catch (networkError) {
    import_ui_utils7.logger.error(
      "loadAbiFromEtherscanV2",
      `Network error fetching ABI from Explorer V2 API: ${networkError}`
    );
    throw new Error(`Network error fetching ABI: ${networkError.message}`);
  }
  if (!response.ok) {
    import_ui_utils7.logger.error(
      "loadAbiFromEtherscanV2",
      `Explorer V2 API request failed with status: ${response.status}`
    );
    throw new Error(`Explorer V2 API request failed: ${response.status} ${response.statusText}`);
  }
  let apiResult;
  try {
    apiResult = await response.json();
  } catch (jsonError) {
    import_ui_utils7.logger.error(
      "loadAbiFromEtherscanV2",
      `Failed to parse Explorer V2 API response as JSON: ${jsonError}`
    );
    throw new Error("Invalid JSON response received from Explorer V2 API.");
  }
  if (apiResult.status !== "1") {
    import_ui_utils7.logger.warn(
      "loadAbiFromEtherscanV2",
      `Explorer V2 API error: Status ${apiResult.status}, Message: ${apiResult.message}, Result: ${apiResult.result}`
    );
    if (apiResult.message?.includes("NOTOK")) {
      if (apiResult.result?.includes("Invalid API Key")) {
        throw new Error(
          `Invalid API key for Etherscan V2. Please check your API key configuration.`
        );
      }
      if (apiResult.result?.includes("Contract source code not verified")) {
        throw new Error(
          `Contract not verified on ${networkConfig.name} explorer (address: ${address}). ABI not available. You can provide the contract's ABI manually.`
        );
      }
      if (apiResult.result?.includes("Invalid chain")) {
        throw new Error(
          `Chain ID ${networkConfig.chainId} is not supported by Etherscan V2 API. Please check if this chain is available.`
        );
      }
    }
    throw new Error(`Explorer V2 API Error: ${apiResult.result || apiResult.message}`);
  }
  const originalAbiString = apiResult.result;
  let abi;
  try {
    abi = JSON.parse(originalAbiString);
    if (!Array.isArray(abi)) {
      throw new Error("Parsed ABI from Explorer V2 API is not an array.");
    }
  } catch (error) {
    import_ui_utils7.logger.error(
      "loadAbiFromEtherscanV2",
      `Failed to parse ABI JSON string from Explorer V2 API result: ${error}`
    );
    throw new Error(`Invalid ABI JSON received from Explorer V2 API: ${error.message}`);
  }
  import_ui_utils7.logger.info(
    "loadAbiFromEtherscanV2",
    `Successfully parsed ABI for ${networkConfig.name} with ${abi.length} items using V2 API.`
  );
  const contractName = `Contract_${address.substring(0, 6)}`;
  const schema = transformAbiToSchema(abi, contractName, address);
  return {
    schema,
    originalAbi: originalAbiString
  };
}
async function testEtherscanV2Connection(networkConfig, apiKey) {
  const startTime = Date.now();
  const requiresApiKey = networkConfig.requiresExplorerApiKey ?? true;
  if (requiresApiKey && !apiKey) {
    return {
      success: false,
      error: "API key is required for testing connection to this explorer"
    };
  }
  try {
    const url = buildV2ApiUrl(networkConfig.chainId, "proxy", "eth_blockNumber", {}, apiKey);
    const response = await fetch(url);
    const latency = Date.now() - startTime;
    if (!response.ok) {
      return {
        success: false,
        error: `HTTP ${response.status}: ${response.statusText}`,
        latency
      };
    }
    const data = await response.json();
    if (data.status === "0" && data.message) {
      if (data.result?.includes("Invalid API Key")) {
        return {
          success: false,
          error: "Invalid API key. Please check your Etherscan API key.",
          latency
        };
      }
      if (data.result?.includes("Invalid chain")) {
        return {
          success: false,
          error: `Chain ID ${networkConfig.chainId} is not supported by Etherscan V2 API.`,
          latency
        };
      }
      return {
        success: false,
        error: data.result || data.message,
        latency
      };
    }
    return {
      success: true,
      latency
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Connection test failed",
      latency: Date.now() - startTime
    };
  }
}
init_utils();
function resolveExplorerApiKeyFromAppConfig(networkConfig) {
  const isV2 = networkConfig.supportsEtherscanV2 && networkConfig.primaryExplorerApiIdentifier === "etherscan-v2";
  if (isV2) {
    const globalV2ApiKey = import_ui_utils6.appConfigService.getGlobalServiceConfig("etherscanv2")?.apiKey;
    if (globalV2ApiKey) {
      return globalV2ApiKey;
    }
  }
  if (networkConfig.primaryExplorerApiIdentifier) {
    const globalServiceConfig = import_ui_utils6.appConfigService.getGlobalServiceConfig(
      networkConfig.primaryExplorerApiIdentifier
    );
    const apiKey = globalServiceConfig?.apiKey ?? import_ui_utils6.appConfigService.getExplorerApiKey(networkConfig.primaryExplorerApiIdentifier);
    if (apiKey) {
      return apiKey;
    }
  }
  return void 0;
}
function resolveExplorerConfig(networkConfig) {
  const isV2 = networkConfig.supportsEtherscanV2 && networkConfig.primaryExplorerApiIdentifier === "etherscan-v2";
  const globalV2ApiKey = isV2 ? import_ui_utils6.appConfigService.getGlobalServiceConfig("etherscanv2")?.apiKey : void 0;
  let appApiKey;
  if (networkConfig.primaryExplorerApiIdentifier) {
    const globalServiceConfig = import_ui_utils6.appConfigService.getGlobalServiceConfig(
      networkConfig.primaryExplorerApiIdentifier
    );
    appApiKey = globalServiceConfig?.apiKey ?? import_ui_utils6.appConfigService.getExplorerApiKey(networkConfig.primaryExplorerApiIdentifier);
  }
  const rawCfg = import_ui_utils6.userNetworkServiceConfigService.get(networkConfig.id, "explorer");
  if (rawCfg && typeof rawCfg === "object") {
    const userCfg = rawCfg;
    import_ui_utils6.logger.info("ExplorerConfig", `Using user-configured explorer for ${networkConfig.name}`);
    return {
      explorerUrl: userCfg.explorerUrl ?? networkConfig.explorerUrl,
      apiUrl: userCfg.apiUrl ?? networkConfig.apiUrl,
      apiKey: userCfg.apiKey ?? globalV2ApiKey ?? appApiKey,
      name: `${networkConfig.name} Explorer`,
      isCustom: true
    };
  }
  if (isV2 && globalV2ApiKey) {
    import_ui_utils6.logger.info("ExplorerConfig", `Using global Etherscan V2 API key for ${networkConfig.name}`);
    return {
      explorerUrl: networkConfig.explorerUrl,
      apiUrl: networkConfig.apiUrl,
      apiKey: globalV2ApiKey,
      name: `${networkConfig.name} Explorer (V2 API)`,
      isCustom: false
    };
  }
  if (appApiKey) {
    import_ui_utils6.logger.info("ExplorerConfig", `Using app-configured API key for ${networkConfig.name}`);
    return {
      explorerUrl: networkConfig.explorerUrl,
      apiUrl: networkConfig.apiUrl,
      apiKey: appApiKey,
      name: `${networkConfig.name} Explorer`,
      isCustom: false
    };
  }
  import_ui_utils6.logger.info(
    "ExplorerConfig",
    `Using default explorer for ${networkConfig.name} (no API key configured)`
  );
  return {
    explorerUrl: networkConfig.explorerUrl,
    apiUrl: networkConfig.apiUrl,
    name: `${networkConfig.name} Explorer`,
    isCustom: false
  };
}
function getEvmExplorerAddressUrl(address, networkConfig) {
  if (!isValidEvmAddress(address)) {
    return null;
  }
  const explorerConfig = resolveExplorerConfig(networkConfig);
  if (!explorerConfig.explorerUrl) {
    return null;
  }
  const baseUrl = (0, import_lodash.trimEnd)(explorerConfig.explorerUrl, "/");
  return `${baseUrl}/address/${address}`;
}
function getEvmExplorerTxUrl(txHash, networkConfig) {
  if (!txHash) {
    return null;
  }
  const explorerConfig = resolveExplorerConfig(networkConfig);
  if (!explorerConfig.explorerUrl) {
    return null;
  }
  const baseUrl = (0, import_lodash.trimEnd)(explorerConfig.explorerUrl, "/");
  return `${baseUrl}/tx/${txHash}`;
}
function validateEvmExplorerConfig(explorerConfig) {
  if (explorerConfig.explorerUrl) {
    try {
      new URL(explorerConfig.explorerUrl);
    } catch {
      return false;
    }
  }
  if (explorerConfig.apiUrl) {
    try {
      new URL(explorerConfig.apiUrl);
    } catch {
      return false;
    }
  }
  if (explorerConfig.apiKey !== void 0 && explorerConfig.apiKey.trim().length === 0) {
    return false;
  }
  return true;
}
async function testEvmExplorerConnection(explorerConfig, networkConfig) {
  if (networkConfig && shouldUseV2Api(networkConfig)) {
    import_ui_utils6.logger.info(
      "testEvmExplorerConnection",
      `Using V2 API connection test for ${networkConfig.name}`
    );
    return testEtherscanV2Connection(networkConfig, explorerConfig.apiKey);
  }
  const requiresApiKey = networkConfig && "requiresExplorerApiKey" in networkConfig ? networkConfig.requiresExplorerApiKey !== false : true;
  if (requiresApiKey && !explorerConfig.apiKey) {
    return {
      success: false,
      error: "API key is required for testing connection to this explorer"
    };
  }
  let apiUrl = explorerConfig.apiUrl;
  if (!apiUrl && networkConfig?.apiUrl) {
    apiUrl = networkConfig.apiUrl;
  }
  if (!apiUrl) {
    return {
      success: false,
      error: "API URL is required for testing connection. Please provide an API URL or ensure the network has a default API URL configured."
    };
  }
  const startTime = Date.now();
  try {
    const url = new URL(apiUrl);
    url.searchParams.append("module", "proxy");
    url.searchParams.append("action", "eth_blockNumber");
    if (explorerConfig.apiKey) {
      url.searchParams.append("apikey", explorerConfig.apiKey);
    }
    const response = await fetch(url.toString());
    const latency = Date.now() - startTime;
    if (!response.ok) {
      return {
        success: false,
        error: `HTTP ${response.status}: ${response.statusText}`,
        latency
      };
    }
    const data = await response.json();
    if (data.status === "0" && data.message) {
      return {
        success: false,
        error: data.message,
        latency
      };
    }
    return {
      success: true,
      latency
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Connection test failed",
      latency: Date.now() - startTime
    };
  }
}
async function loadAbiFromEtherscan(address, networkConfig) {
  if (shouldUseV2Api(networkConfig)) {
    import_ui_utils5.logger.info("loadAbiFromEtherscan", "Using V2 API for fetching ABI");
    return loadAbiFromEtherscanV2(address, networkConfig);
  }
  import_ui_utils5.logger.info("loadAbiFromEtherscan", "Using V1 API for fetching ABI");
  return loadAbiFromEtherscanV1(address, networkConfig);
}
async function loadAbiFromEtherscanV1(address, networkConfig) {
  const explorerConfig = resolveExplorerConfig(networkConfig);
  if (!explorerConfig.apiUrl) {
    import_ui_utils5.logger.error(
      "loadAbiFromEtherscanV1",
      `API URL is missing for ${networkConfig.name} explorer.`
    );
    throw new Error(`Explorer API URL for ${networkConfig.name} is not configured.`);
  }
  const url = new URL(explorerConfig.apiUrl);
  url.searchParams.append("module", "contract");
  url.searchParams.append("action", "getabi");
  url.searchParams.append("address", address);
  if (explorerConfig.apiKey) {
    url.searchParams.append("apikey", explorerConfig.apiKey);
  }
  let response;
  try {
    import_ui_utils5.logger.info(
      "loadAbiFromEtherscanV1",
      `Fetching ABI from ${explorerConfig.apiUrl} for address: ${address}`
    );
    response = await fetch(url);
  } catch (networkError) {
    import_ui_utils5.logger.error(
      "loadAbiFromEtherscanV1",
      `Network error fetching ABI from Explorer API: ${networkError}`
    );
    throw new Error(`Network error fetching ABI: ${networkError.message}`);
  }
  if (!response.ok) {
    import_ui_utils5.logger.error(
      "loadAbiFromEtherscanV1",
      `Explorer API request failed with status: ${response.status}`
    );
    throw new Error(`Explorer API request failed: ${response.status} ${response.statusText}`);
  }
  let apiResult;
  try {
    apiResult = await response.json();
  } catch (jsonError) {
    import_ui_utils5.logger.error(
      "loadAbiFromEtherscanV1",
      `Failed to parse Explorer API response as JSON: ${jsonError}`
    );
    throw new Error("Invalid JSON response received from Explorer API.");
  }
  if (apiResult.status !== "1") {
    import_ui_utils5.logger.warn(
      "loadAbiFromEtherscanV1",
      `Explorer API error: Status ${apiResult.status}, Message: ${apiResult.message}, Result: ${apiResult.result}`
    );
    if (apiResult.result?.includes("Contract source code not verified")) {
      throw new Error(
        `Contract not verified on ${networkConfig.name} explorer (address: ${address}). ABI not available. You can provide the contract's ABI manually.`
      );
    }
    throw new Error(`Explorer API Error: ${apiResult.result || apiResult.message}`);
  }
  const originalAbiString = apiResult.result;
  let abi;
  try {
    abi = JSON.parse(originalAbiString);
    if (!Array.isArray(abi)) {
      throw new Error("Parsed ABI from Explorer API is not an array.");
    }
  } catch (error) {
    import_ui_utils5.logger.error(
      "loadAbiFromEtherscanV1",
      `Failed to parse ABI JSON string from Explorer API result: ${error}`
    );
    throw new Error(`Invalid ABI JSON received from Explorer API: ${error.message}`);
  }
  import_ui_utils5.logger.info(
    "loadAbiFromEtherscanV1",
    `Successfully parsed ABI for ${networkConfig.name} with ${abi.length} items.`
  );
  const contractName = `Contract_${address.substring(0, 6)}`;
  const schema = transformAbiToSchema(abi, contractName, address);
  return {
    schema,
    originalAbi: originalAbiString
  };
}
var SOURCIFY_APP_BASE = "https://repo.sourcify.dev";
function getSourcifyContractAppUrl(chainId, address) {
  return `${SOURCIFY_APP_BASE}/${chainId}/${address}`;
}
var SOURCIFY_API_BASE = "https://sourcify.dev/server/v2";
function buildSourcifyApiUrl(chainId, address) {
  const normalizedAddress = address.toLowerCase();
  const url = new URL(
    `${SOURCIFY_API_BASE}/contract/${chainId}/${normalizedAddress}?fields=abi,metadata`
  );
  return url.toString();
}
async function loadAbiFromSourcify(address, networkConfig, timeoutMs = 4e3) {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const url = buildSourcifyApiUrl(networkConfig.chainId, address);
    import_ui_utils8.logger.info("loadAbiFromSourcify", `Fetching contract from ${url}`);
    const response = await fetch(url, { signal: controller.signal });
    if (!response.ok) {
      throw new Error(`Sourcify request failed: ${response.status} ${response.statusText}`);
    }
    const payload = await response.json();
    const abi = payload.abi ?? payload.metadata?.output?.abi;
    if (!abi || !Array.isArray(abi)) {
      throw new Error("Sourcify metadata did not include a valid ABI array");
    }
    const normalizedAddress = address.toLowerCase();
    const contractName = payload.metadata?.contractName || `Contract_${normalizedAddress.substring(0, 6).toUpperCase()}`;
    const schema = transformAbiToSchema(abi, contractName, address);
    return { schema, originalAbi: JSON.stringify(abi) };
  } catch (error) {
    import_ui_utils8.logger.warn("loadAbiFromSourcify", `Failed to fetch ABI from Sourcify: ${String(error)}`);
    throw error;
  } finally {
    clearTimeout(timeout);
  }
}
function buildRpcUrl(config) {
  return config.url;
}
function getUserRpcUrl(networkId) {
  const svcCfg = import_ui_utils11.userNetworkServiceConfigService.get(networkId, "rpc");
  if (svcCfg && typeof svcCfg === "object" && "rpcUrl" in svcCfg) {
    return svcCfg.rpcUrl;
  }
  return void 0;
}
function resolveRpcUrl(networkConfig) {
  const logSystem = "RpcResolver";
  const networkId = networkConfig.id;
  const userRpcUrl = getUserRpcUrl(networkId);
  if (userRpcUrl) {
    const userRpcUrlString = String(userRpcUrl);
    if ((0, import_ui_utils11.isValidUrl)(userRpcUrlString)) {
      import_ui_utils11.logger.info(logSystem, `Using user-configured RPC URL for network ${networkId}`);
      return userRpcUrlString;
    } else {
      import_ui_utils11.logger.warn(
        logSystem,
        `User-configured RPC URL for ${networkId} is invalid: ${userRpcUrlString}. Falling back.`
      );
    }
  }
  const rpcOverrideSetting = import_ui_utils11.appConfigService.getRpcEndpointOverride(networkId);
  let rpcUrlFromOverride;
  if (typeof rpcOverrideSetting === "string") {
    rpcUrlFromOverride = rpcOverrideSetting;
  } else if (typeof rpcOverrideSetting === "object" && rpcOverrideSetting) {
    if ("url" in rpcOverrideSetting && "isCustom" in rpcOverrideSetting) {
      const userConfig = rpcOverrideSetting;
      rpcUrlFromOverride = buildRpcUrl(userConfig);
    } else if ("http" in rpcOverrideSetting) {
      rpcUrlFromOverride = rpcOverrideSetting.http;
    }
  }
  if (rpcUrlFromOverride) {
    import_ui_utils11.logger.info(
      logSystem,
      `Using overridden RPC URL for network ${networkId}: ${rpcUrlFromOverride}`
    );
    if ((0, import_ui_utils11.isValidUrl)(rpcUrlFromOverride)) {
      return rpcUrlFromOverride;
    } else {
      import_ui_utils11.logger.warn(
        logSystem,
        `Overridden RPC URL for ${networkId} is invalid: ${rpcUrlFromOverride}. Falling back.`
      );
    }
  }
  if (networkConfig.rpcUrl && (0, import_ui_utils11.isValidUrl)(networkConfig.rpcUrl)) {
    import_ui_utils11.logger.debug(
      logSystem,
      `Using default RPC URL for network ${networkId}: ${networkConfig.rpcUrl}`
    );
    return networkConfig.rpcUrl;
  }
  import_ui_utils11.logger.error(
    logSystem,
    `No valid RPC URL could be resolved for network ${networkId}. Checked user config, override, and networkConfig.rpcUrl.`
  );
  throw new Error(
    `No valid RPC URL configured for network ${networkConfig.name} (ID: ${networkId}).`
  );
}
function validateEvmRpcEndpoint(rpcConfig) {
  try {
    if (!(0, import_ui_utils11.isValidUrl)(rpcConfig.url)) {
      import_ui_utils11.logger.error("validateEvmRpcEndpoint", `Invalid RPC URL format: ${rpcConfig.url}`);
      return false;
    }
    return true;
  } catch (error) {
    import_ui_utils11.logger.error("validateEvmRpcEndpoint", "Error validating RPC endpoint:", error);
    return false;
  }
}
async function testEvmRpcConnection(rpcConfig, timeoutMs = 5e3) {
  if (!rpcConfig.url) {
    return { success: false, error: "RPC URL is required" };
  }
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const startTime = Date.now();
    const response = await fetch(rpcConfig.url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "eth_blockNumber",
        params: [],
        id: 1
      }),
      signal: controller.signal
    });
    if (!response.ok) {
      return { success: false, error: `HTTP error: ${response.status}` };
    }
    const data = await response.json();
    const latency = Date.now() - startTime;
    if (data.error) {
      return { success: false, error: data.error.message || "RPC error" };
    }
    return { success: true, latency };
  } catch (error) {
    import_ui_utils11.logger.error("testEvmRpcConnection", "Connection test failed:", error);
    if (error instanceof Error && error.name === "AbortError") {
      return {
        success: false,
        error: `Connection timeout after ${timeoutMs}ms`
      };
    }
    return {
      success: false,
      error: error instanceof Error ? error.message : "Connection failed"
    };
  } finally {
    clearTimeout(timeoutId);
  }
}
async function getEvmCurrentBlock(networkConfig) {
  const rpcUrl = resolveRpcUrl(networkConfig);
  try {
    const response = await fetch(rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "eth_blockNumber",
        params: [],
        id: 1
      })
    });
    if (!response.ok) {
      throw new Error(`RPC request failed with status ${response.status}`);
    }
    const data = await response.json();
    if (data.error) {
      throw new Error(data.error.message || "RPC error");
    }
    if (data.result === void 0 || data.result === null) {
      throw new Error("RPC response missing result field");
    }
    const blockNumber = parseInt(data.result, 16);
    if (isNaN(blockNumber)) {
      throw new Error(`Invalid block number returned: ${data.result}`);
    }
    return blockNumber;
  } catch (error) {
    import_ui_utils11.logger.error("getEvmCurrentBlock", "Failed to get current block:", error);
    throw new Error(
      `Failed to get current block: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}
function detectProxyFromAbi(abi) {
  const functions = abi.filter((item) => item.type === "function");
  const events = abi.filter((item) => item.type === "event");
  const errors = abi.filter((item) => item.type === "error");
  const indicators = [];
  let proxyType = null;
  let confidence = "low";
  const hasUpgradeEvent = events.some((e) => e.name === "Upgraded");
  const hasImplementationFunction = functions.some((f) => f.name === "implementation");
  const hasUUPSErrors = errors.some((e) => e.name?.includes("ERC1967"));
  const hasUpgradeToFunction = functions.some(
    (f) => f.name === "upgradeToAndCall" || f.name === "upgradeTo"
  );
  if (hasUpgradeEvent || hasUUPSErrors) {
    indicators.push("ERC1967 upgrade pattern detected");
    proxyType = "uups";
    confidence = "high";
  }
  if (hasImplementationFunction) {
    indicators.push("implementation() function found");
    if (proxyType === "uups") {
      confidence = "high";
    } else {
      proxyType = "transparent";
      confidence = "medium";
    }
  }
  if (hasUpgradeToFunction && proxyType === "uups") {
    indicators.push("UUPS upgrade functions found");
    confidence = "high";
  }
  const hasAdminFunction = functions.some((f) => f.name === "admin");
  const hasProxyAdminErrors = errors.some((e) => e.name?.includes("ProxyDenied"));
  const hasChangeAdminFunction = functions.some((f) => f.name === "changeAdmin");
  if (hasAdminFunction || hasProxyAdminErrors || hasChangeAdminFunction) {
    indicators.push("Transparent proxy admin pattern detected");
    if (proxyType === null) {
      proxyType = "transparent";
      confidence = "medium";
    }
  }
  const hasBeaconFunction = functions.some((f) => f.name === "beacon");
  const hasBeaconUpgrade = events.some((e) => e.name === "BeaconUpgraded");
  if (hasBeaconFunction || hasBeaconUpgrade) {
    indicators.push("Beacon proxy pattern detected");
    proxyType = "beacon";
    confidence = "high";
  }
  const hasDiamondCut = functions.some((f) => f.name === "diamondCut");
  const hasFacets = functions.some((f) => f.name === "facets");
  const hasFacetFunctionSelectors = functions.some((f) => f.name === "facetFunctionSelectors");
  if (hasDiamondCut || hasFacets && hasFacetFunctionSelectors) {
    indicators.push("Diamond (EIP-2535) proxy pattern detected");
    proxyType = "diamond";
    confidence = "high";
  }
  const hasFallback = abi.some((item) => item.type === "fallback");
  const hasProxyConstructor = abi.some(
    (item) => item.type === "constructor" && item.inputs?.some(
      (input) => input.name === "implementation" || input.name === "_logic" || input.name === "_data"
    )
  );
  if (hasFallback) {
    indicators.push("Fallback function present");
  }
  if (hasProxyConstructor) {
    indicators.push("Proxy-style constructor detected");
  }
  const hasMinimalFunctions = functions.length <= 1;
  const hasNoEvents = events.length === 0;
  if (hasMinimalFunctions && hasNoEvents && hasFallback && proxyType === null) {
    indicators.push("Minimal proxy pattern detected");
    proxyType = "minimal";
    confidence = "medium";
  }
  const isProxy = proxyType !== null || hasFallback && hasMinimalFunctions && (hasProxyConstructor || functions.length === 0);
  if (isProxy && proxyType === null) {
    proxyType = "unknown";
    indicators.push("Generic proxy pattern detected");
    confidence = "low";
  }
  return {
    isProxy,
    proxyType,
    confidence,
    indicators
  };
}
async function getImplementationAddress(proxyAddress, networkConfig, proxyType) {
  import_ui_utils10.logger.info(
    "getImplementationAddress",
    `Resolving implementation for ${proxyType} proxy: ${proxyAddress}`
  );
  try {
    switch (proxyType) {
      case "uups":
      case "transparent": {
        const eip1967Impl = await getEIP1967Implementation(proxyAddress, networkConfig);
        if (eip1967Impl) return eip1967Impl;
        const legacyImpl = await getLegacyOZImplementation(proxyAddress, networkConfig);
        if (legacyImpl) return legacyImpl;
        return null;
      }
      case "beacon":
        return await getBeaconImplementation(proxyAddress, networkConfig);
      case "diamond":
        import_ui_utils10.logger.info("getImplementationAddress", "Diamond proxies not fully supported yet");
        return null;
      case "minimal":
        return await getMinimalProxyImplementation(proxyAddress, networkConfig);
      default:
        return await tryCommonImplementationMethods(proxyAddress, networkConfig);
    }
  } catch (error) {
    import_ui_utils10.logger.warn("getImplementationAddress", `Failed to resolve implementation: ${error}`);
    return null;
  }
}
async function getAdminAddress(proxyAddress, networkConfig) {
  try {
    const eip1967Admin = await getEIP1967Admin(proxyAddress, networkConfig);
    if (eip1967Admin) return eip1967Admin;
    const legacyAdmin = await getLegacyOZAdmin(proxyAddress, networkConfig);
    if (legacyAdmin) return legacyAdmin;
    return null;
  } catch (error) {
    import_ui_utils10.logger.warn("getAdminAddress", `Failed to resolve admin: ${error}`);
    return null;
  }
}
async function getEIP1967Implementation(proxyAddress, networkConfig) {
  const implementationSlot = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";
  return await readStorageSlot(proxyAddress, implementationSlot, networkConfig);
}
async function getEIP1967Admin(proxyAddress, networkConfig) {
  const adminSlot = "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103";
  return await readStorageSlot(proxyAddress, adminSlot, networkConfig);
}
async function getLegacyOZAdmin(proxyAddress, networkConfig) {
  try {
    const slot = (0, import_viem5.keccak256)((0, import_viem5.toHex)("org.zeppelinos.proxy.admin"));
    import_ui_utils10.logger.info("getLegacyOZAdmin", `Trying legacy OZ admin slot: ${slot}`);
    return await readStorageSlot(proxyAddress, slot, networkConfig);
  } catch (error) {
    import_ui_utils10.logger.warn("getLegacyOZAdmin", `Failed computing or reading legacy admin slot: ${error}`);
    return null;
  }
}
async function getLegacyOZImplementation(proxyAddress, networkConfig) {
  try {
    const slot = (0, import_viem5.keccak256)((0, import_viem5.toHex)("org.zeppelinos.proxy.implementation"));
    import_ui_utils10.logger.info("getLegacyOZImplementation", `Trying legacy OZ slot: ${slot}`);
    return await readStorageSlot(proxyAddress, slot, networkConfig);
  } catch (error) {
    import_ui_utils10.logger.warn("getLegacyOZImplementation", `Failed computing or reading legacy slot: ${error}`);
    return null;
  }
}
async function getBeaconImplementation(proxyAddress, networkConfig) {
  const beaconSlot = "0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50";
  const beaconAddress = await readStorageSlot(proxyAddress, beaconSlot, networkConfig);
  if (!beaconAddress) {
    return null;
  }
  return await callContractFunction(beaconAddress, "implementation()", [], networkConfig);
}
async function getMinimalProxyImplementation(proxyAddress, networkConfig) {
  try {
    const bytecode = await getContractBytecode(proxyAddress, networkConfig);
    if (!bytecode || bytecode.length < 42) {
      return null;
    }
    if (bytecode.startsWith("0x363d3d373d3d3d363d73") && bytecode.includes("5af43d82803e903d91602b57fd5bf3")) {
      const implementationHex = bytecode.slice(22, 62);
      return "0x" + implementationHex;
    }
    return null;
  } catch (error) {
    import_ui_utils10.logger.warn("getMinimalProxyImplementation", `Error reading bytecode: ${error}`);
    return null;
  }
}
async function tryCommonImplementationMethods(proxyAddress, networkConfig) {
  const commonMethods = [
    "implementation()",
    "getImplementation()",
    "_implementation()",
    "target()"
  ];
  for (const method of commonMethods) {
    try {
      const result = await callContractFunction(proxyAddress, method, [], networkConfig);
      if (result && result !== "0x0000000000000000000000000000000000000000") {
        import_ui_utils10.logger.info(
          "tryCommonImplementationMethods",
          `Found implementation via ${method}: ${result}`
        );
        return result;
      }
    } catch {
      continue;
    }
  }
  return await getEIP1967Implementation(proxyAddress, networkConfig);
}
function createViemClient(networkConfig) {
  const rpcUrl = resolveRpcUrl(networkConfig);
  return (0, import_viem5.createPublicClient)({
    transport: (0, import_viem5.http)(rpcUrl)
  });
}
async function readStorageSlot(address, slot, networkConfig) {
  try {
    const client = createViemClient(networkConfig);
    const storageValue = await client.getStorageAt({
      address,
      slot
    });
    if (storageValue && storageValue !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
      import_ui_utils10.logger.info("readStorageSlot", `Found non-zero value at slot ${slot}: ${storageValue}`);
      const implAddress = "0x" + storageValue.slice(-40);
      return implAddress;
    }
    return null;
  } catch (error) {
    import_ui_utils10.logger.warn("readStorageSlot", `Failed to read storage slot ${slot}: ${error}`);
    return null;
  }
}
async function callContractFunction(address, signature, params, networkConfig) {
  try {
    const client = createViemClient(networkConfig);
    const abi = (0, import_viem5.parseAbi)([signature]);
    const func = abi[0];
    const result = await client.readContract({
      address,
      abi,
      functionName: func.name,
      args: params
    });
    const addressResult = result;
    if (addressResult && addressResult !== "0x0000000000000000000000000000000000000000") {
      return addressResult;
    }
    return null;
  } catch (error) {
    import_ui_utils10.logger.warn("callContractFunction", `Failed to call ${signature}: ${error}`);
    return null;
  }
}
async function getContractBytecode(address, networkConfig) {
  try {
    const client = createViemClient(networkConfig);
    const bytecode = await client.getCode({
      address
    });
    return bytecode || null;
  } catch (error) {
    import_ui_utils10.logger.warn("getContractBytecode", `Failed to get bytecode: ${error}`);
    return null;
  }
}
var EvmProviderKeys = {
  Etherscan: "etherscan",
  Sourcify: "sourcify"
};
var EVM_PROVIDER_ORDER_DEFAULT = [
  EvmProviderKeys.Etherscan,
  EvmProviderKeys.Sourcify
];
function isEvmProviderKey(value) {
  return value === EvmProviderKeys.Etherscan || value === EvmProviderKeys.Sourcify;
}
async function loadAbiFromJson(abiJsonString) {
  let abi;
  try {
    abi = JSON.parse(abiJsonString);
    if (!Array.isArray(abi)) {
      throw new Error("Parsed JSON is not an array.");
    }
  } catch (error) {
    import_ui_utils9.logger.error("loadAbiFromJson", "Failed to parse source string as JSON ABI:", error);
    throw new Error(`Invalid JSON ABI provided: ${error.message}`);
  }
  import_ui_utils9.logger.info("loadAbiFromJson", `Successfully parsed JSON ABI with ${abi.length} items.`);
  const contractName = "ContractFromABI";
  return transformAbiToSchema(abi, contractName, void 0);
}
var PER_PROVIDER_TIMEOUT_MS = 4e3;
var OVERALL_BUDGET_MS = 1e4;
async function loadEvmContract(artifacts, networkConfig, options = {}) {
  const { contractAddress, contractDefinition, __proxyDetectionOptions } = artifacts;
  const proxyOptions = __proxyDetectionOptions;
  if (proxyOptions?.skipProxyDetection) {
    options.skipProxyDetection = true;
  }
  if (!contractAddress || typeof contractAddress !== "string" || !(0, import_viem4.isAddress)(contractAddress)) {
    throw new Error("A valid contract address is required.");
  }
  if (contractDefinition && typeof contractDefinition === "string" && contractDefinition.trim().length > 0) {
    const trimmed = contractDefinition.trim();
    const hasJsonContent = trimmed.includes("[") && trimmed.includes("]") && trimmed.includes("{");
    if (hasJsonContent) {
      import_ui_utils9.logger.info("loadEvmContract", "Manual contract definition provided. Attempting to parse...");
      try {
        const schema = await loadAbiFromJson(contractDefinition);
        return {
          schema: { ...schema, address: contractAddress },
          source: "manual",
          contractDefinitionOriginal: contractDefinition,
          metadata: {
            contractName: schema.name,
            fetchTimestamp: /* @__PURE__ */ new Date(),
            verificationStatus: "unknown"
            // Manual ABI - verification status unknown
          }
          // Note: No proxy detection for manual ABIs - user provides what they want
        };
      } catch (error) {
        import_ui_utils9.logger.error("loadEvmContract", "Failed to parse manually provided ABI:", error);
        throw new Error(`The provided ABI JSON is invalid: ${error.message}`);
      }
    }
  }
  const forcedRaw = artifacts.__forcedProvider || artifacts.service;
  const forcedProvider = isEvmProviderKey(forcedRaw) ? forcedRaw : null;
  import_ui_utils9.logger.info(
    "loadEvmContract",
    `No manual ABI detected. Attempting Etherscan fetch for address: ${contractAddress}...`
  );
  return await loadContractWithProxyDetection(
    contractAddress,
    networkConfig,
    options,
    forcedProvider
  );
}
function buildContractResult(contractAddress, abiResult, networkConfig, sourceProvider, proxyInfo) {
  let fetchedFrom = void 0;
  if (sourceProvider === EvmProviderKeys.Etherscan) {
    fetchedFrom = getEvmExplorerAddressUrl(contractAddress, networkConfig) || void 0;
  } else if (sourceProvider === EvmProviderKeys.Sourcify) {
    fetchedFrom = getSourcifyContractAppUrl(networkConfig.chainId, contractAddress);
  } else {
    fetchedFrom = getEvmExplorerAddressUrl(contractAddress, networkConfig) || void 0;
  }
  return {
    schema: { ...abiResult.schema, address: contractAddress },
    source: "fetched",
    contractDefinitionOriginal: abiResult.originalAbi,
    metadata: {
      fetchedFrom,
      contractName: abiResult.schema.name,
      verificationStatus: "verified",
      fetchTimestamp: /* @__PURE__ */ new Date(),
      definitionHash: (0, import_ui_utils9.simpleHash)(abiResult.originalAbi)
    },
    proxyInfo
  };
}
async function loadImplementationAbi(_contractAddress, implementationAddress, networkConfig, _proxyType) {
  try {
    const implementationResult = await loadAbiFromEtherscan(implementationAddress, networkConfig);
    import_ui_utils9.logger.info(
      "loadImplementationAbi",
      `Successfully fetched implementation ABI with ${implementationResult.schema.functions.length} functions`
    );
    return implementationResult;
  } catch (implementationError) {
    import_ui_utils9.logger.warn(
      "loadImplementationAbi",
      `Failed to load implementation ABI: ${implementationError}`
    );
    return null;
  }
}
async function handleProxyDetection(contractAddress, initialResult, networkConfig, initialProvider) {
  const abi = JSON.parse(initialResult.originalAbi);
  const proxyDetection = detectProxyFromAbi(abi);
  if (!proxyDetection.isProxy) {
    return null;
  }
  import_ui_utils9.logger.info(
    "handleProxyDetection",
    `Proxy detected: ${proxyDetection.proxyType} (confidence: ${proxyDetection.confidence})`
  );
  const proxyType = proxyDetection.proxyType || "unknown";
  const implementationAddress = await getImplementationAddress(
    contractAddress,
    networkConfig,
    proxyType
  );
  const adminAddress = await getAdminAddress(contractAddress, networkConfig);
  if (!implementationAddress) {
    import_ui_utils9.logger.info("handleProxyDetection", "Proxy detected but implementation address not found");
    return buildContractResult(contractAddress, initialResult, networkConfig, initialProvider, {
      isProxy: true,
      proxyType,
      proxyAddress: contractAddress,
      detectionMethod: "automatic"
    });
  }
  import_ui_utils9.logger.info("handleProxyDetection", `Found implementation at: ${implementationAddress}`);
  const implementationResult = await loadImplementationAbi(
    contractAddress,
    implementationAddress,
    networkConfig,
    proxyType
  );
  const baseProxyInfo = {
    isProxy: true,
    proxyType,
    implementationAddress,
    proxyAddress: contractAddress,
    detectionMethod: "automatic",
    ...adminAddress ? { adminAddress } : {}
  };
  if (implementationResult) {
    return buildContractResult(
      contractAddress,
      implementationResult,
      networkConfig,
      EvmProviderKeys.Etherscan,
      baseProxyInfo
    );
  } else {
    return buildContractResult(
      contractAddress,
      initialResult,
      networkConfig,
      initialProvider,
      baseProxyInfo
    );
  }
}
async function loadContractWithProxyDetection(contractAddress, networkConfig, options = {}, forcedProvider = null) {
  try {
    let uiDefault = null;
    const svcCfg = import_ui_utils9.userNetworkServiceConfigService.get(networkConfig.id, "contract-definitions");
    if (svcCfg && typeof svcCfg === "object" && "defaultProvider" in svcCfg) {
      const raw = svcCfg.defaultProvider;
      if (isEvmProviderKey(raw)) uiDefault = raw;
    }
    const appDefaultRaw = import_ui_utils9.appConfigService.getGlobalServiceParam(
      "contractdefinition",
      "defaultProvider"
    );
    const appDefault = typeof appDefaultRaw === "string" && isEvmProviderKey(appDefaultRaw) ? appDefaultRaw : null;
    const buildProviderArray = (primary) => [
      primary,
      primary === EvmProviderKeys.Etherscan ? EvmProviderKeys.Sourcify : EvmProviderKeys.Etherscan
    ];
    const providers = forcedProvider ? [forcedProvider] : uiDefault ? buildProviderArray(uiDefault) : appDefault ? buildProviderArray(appDefault) : [EvmProviderKeys.Etherscan, EvmProviderKeys.Sourcify];
    const overallDeadline = Date.now() + OVERALL_BUDGET_MS;
    let initialResult = null;
    let lastError = null;
    let usedProvider = null;
    for (const provider of providers) {
      try {
        const remainingOverall = Math.max(100, overallDeadline - Date.now());
        const attemptTimeout = Math.min(PER_PROVIDER_TIMEOUT_MS, remainingOverall);
        if (provider === EvmProviderKeys.Etherscan) {
          initialResult = await (0, import_ui_utils9.withTimeout)(
            loadAbiFromEtherscan(contractAddress, networkConfig),
            attemptTimeout,
            "etherscan"
          );
        } else if (provider === EvmProviderKeys.Sourcify) {
          initialResult = await (0, import_ui_utils9.withTimeout)(
            loadAbiFromSourcify(contractAddress, networkConfig, attemptTimeout),
            attemptTimeout,
            "sourcify"
          );
        }
        if (initialResult) {
          usedProvider = provider;
          break;
        }
      } catch (err) {
        lastError = err;
        continue;
      }
    }
    if (!initialResult) throw lastError ?? new Error("No provider succeeded");
    import_ui_utils9.logger.info(
      "loadContractWithProxyDetection",
      `Successfully fetched initial ABI for ${contractAddress} with ${initialResult.schema.functions.length} functions`
    );
    if (!options.skipProxyDetection && !options.treatAsImplementation) {
      const proxyResult = await handleProxyDetection(
        contractAddress,
        initialResult,
        networkConfig,
        usedProvider
      );
      if (proxyResult) {
        return proxyResult;
      }
    }
    return buildContractResult(contractAddress, initialResult, networkConfig, usedProvider);
  } catch (error) {
    import_ui_utils9.logger.warn("loadContractWithProxyDetection", `Contract loading failed: ${error}`);
    if (forcedProvider) {
      throw error;
    }
    const errorMessage = error.message || "";
    if (errorMessage.includes("Contract not verified")) {
      throw new Error(
        `Contract at ${contractAddress} is not verified on the block explorer. Verification status: unverified. Please provide the contract ABI manually.`
      );
    }
    throw error;
  }
}
async function loadContractSchema(source, networkConfig, options) {
  const { validateAndConvertEvmArtifacts: validateAndConvertEvmArtifacts2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
  const artifacts = validateAndConvertEvmArtifacts2(source);
  const result = await loadEvmContract(artifacts, networkConfig, options);
  return result.schema;
}
async function loadContractWithFullMetadata(source, networkConfig) {
  const { validateAndConvertEvmArtifacts: validateAndConvertEvmArtifacts2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
  const artifacts = validateAndConvertEvmArtifacts2(source);
  return loadEvmContract(artifacts, networkConfig);
}
function isValidAbiArray(value) {
  return Array.isArray(value) && value.every(isValidAbiItem);
}
function isValidAbiItem(item) {
  if (typeof item !== "object" || item === null) {
    return false;
  }
  const abiItem = item;
  if (typeof abiItem.type !== "string") {
    return false;
  }
  const validTypes = ["function", "event", "constructor", "error", "fallback", "receive"];
  if (!validTypes.includes(abiItem.type)) {
    return false;
  }
  if ((abiItem.type === "function" || abiItem.type === "event") && typeof abiItem.name !== "string") {
    return false;
  }
  if ((abiItem.type === "function" || abiItem.type === "event" || abiItem.type === "constructor") && abiItem.inputs !== void 0 && !Array.isArray(abiItem.inputs)) {
    return false;
  }
  return true;
}
var AbiComparisonService = class {
  /**
   * Compares two ABIs and returns detailed difference analysis
   */
  compareAbis(abi1, abi2) {
    try {
      const validation1 = this.validateAbi(abi1);
      const validation2 = this.validateAbi(abi2);
      if (!validation1.valid || !validation2.valid) {
        return {
          identical: false,
          differences: [],
          severity: "breaking",
          summary: "One or both ABIs are invalid and cannot be compared"
        };
      }
      const normalized1 = this.normalizeAbi(validation1.normalizedAbi);
      const normalized2 = this.normalizeAbi(validation2.normalizedAbi);
      const hash1 = (0, import_ui_utils12.simpleHash)(JSON.stringify(normalized1));
      const hash2 = (0, import_ui_utils12.simpleHash)(JSON.stringify(normalized2));
      if (hash1 === hash2) {
        return {
          identical: true,
          differences: [],
          severity: "none",
          summary: "ABIs are identical"
        };
      }
      const differences = this.findDifferences(normalized1, normalized2);
      const severity = this.calculateSeverity(differences);
      return {
        identical: false,
        differences,
        severity,
        summary: this.generateSummary(differences)
      };
    } catch (error) {
      import_ui_utils12.logger.error("ABI comparison failed:", error.message);
      return {
        identical: false,
        differences: [],
        severity: "breaking",
        summary: `Comparison failed: ${error.message}`
      };
    }
  }
  /**
   * Validates ABI structure and format
   */
  validateAbi(abiString) {
    const errors = [];
    const warnings = [];
    try {
      const abi = JSON.parse(abiString);
      if (!Array.isArray(abi)) {
        errors.push("ABI must be an array");
        return { valid: false, errors, warnings };
      }
      if (abi.length === 0) {
        errors.push(
          "ABI array cannot be empty - contract must have at least one function, event, or constructor"
        );
        return { valid: false, errors, warnings };
      }
      for (let i = 0; i < abi.length; i++) {
        const item = abi[i];
        if (!item.type) {
          errors.push(`Item ${i}: Missing 'type' field`);
          continue;
        }
        if (!["function", "event", "constructor", "error", "fallback", "receive"].includes(item.type)) {
          errors.push(`Item ${i}: Invalid type '${item.type}'`);
        }
        if (item.type === "function" && !item.name) {
          errors.push(`Item ${i}: Function missing 'name' field`);
        }
        if ((item.type === "function" || item.type === "event") && !Array.isArray(item.inputs)) {
          errors.push(`Item ${i}: Missing or invalid 'inputs' array`);
        }
        if (item.type === "function" && !Array.isArray(item.outputs)) {
          warnings.push(`Item ${i}: Function missing 'outputs' array`);
        }
      }
      if (errors.length === 0 && !isValidAbiArray(abi)) {
        errors.push("ABI does not conform to expected format");
      }
      return {
        valid: errors.length === 0,
        errors,
        warnings,
        normalizedAbi: errors.length === 0 ? abi : void 0
      };
    } catch (parseError) {
      errors.push(`Invalid JSON: ${parseError.message}`);
      return { valid: false, errors, warnings };
    }
  }
  /**
   * Creates deterministic hash of ABI for quick comparison
   */
  hashAbi(abiString) {
    try {
      const validation = this.validateAbi(abiString);
      if (!validation.valid || !validation.normalizedAbi) {
        throw new Error("Cannot hash invalid ABI");
      }
      const normalized = this.normalizeAbi(validation.normalizedAbi);
      const normalizedString = JSON.stringify(normalized);
      return (0, import_ui_utils12.simpleHash)(normalizedString);
    } catch (error) {
      import_ui_utils12.logger.error("ABI hashing failed:", error.message);
      throw new Error(`Failed to hash ABI: ${error.message}`);
    }
  }
  /**
   * Normalizes ABI for consistent comparison
   */
  normalizeAbi(abi) {
    return abi.map((item) => {
      const normalized = { ...item };
      if (normalized.inputs) {
        normalized.inputs = [...normalized.inputs].sort(
          (a, b) => (a.name || "").localeCompare(b.name || "")
        );
      }
      if (normalized.outputs) {
        normalized.outputs = [...normalized.outputs].sort(
          (a, b) => (a.name || "").localeCompare(b.name || "")
        );
      }
      return normalized;
    }).sort((a, b) => {
      const typeOrder = {
        constructor: 0,
        fallback: 1,
        receive: 2,
        function: 3,
        event: 4,
        error: 5
      };
      const aOrder = typeOrder[a.type] ?? 99;
      const bOrder = typeOrder[b.type] ?? 99;
      if (aOrder !== bOrder) return aOrder - bOrder;
      const aName = a.name || "";
      const bName = b.name || "";
      return aName.localeCompare(bName);
    });
  }
  /**
   * Finds detailed differences between two normalized ABIs
   */
  findDifferences(abi1, abi2) {
    const differences = [];
    const map1 = this.createAbiMap(abi1);
    const map2 = this.createAbiMap(abi2);
    for (const [key, item] of map1) {
      if (!map2.has(key)) {
        differences.push({
          type: "removed",
          section: item.type,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          name: item.name || item.type,
          details: `${item.type} was removed`,
          impact: this.calculateImpact(item.type, "removed"),
          oldSignature: this.generateSignature(item)
        });
      }
    }
    for (const [key, item] of map2) {
      if (!map1.has(key)) {
        differences.push({
          type: "added",
          section: item.type,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          name: item.name || item.type,
          details: `${item.type} was added`,
          impact: this.calculateImpact(item.type, "added"),
          newSignature: this.generateSignature(item)
        });
      }
    }
    for (const [key, item1] of map1) {
      const item2 = map2.get(key);
      if (item2 && !this.itemsEqual(item1, item2)) {
        differences.push({
          type: "modified",
          section: item1.type,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          name: item1.name || item1.type,
          details: `${item1.type} signature changed`,
          impact: this.calculateImpact(item1.type, "modified"),
          oldSignature: this.generateSignature(item1),
          newSignature: this.generateSignature(item2)
        });
      }
    }
    return differences;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  createAbiMap(abi) {
    const map = /* @__PURE__ */ new Map();
    for (const item of abi) {
      const key = this.generateItemKey(item);
      map.set(key, item);
    }
    return map;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  generateItemKey(item) {
    if (item.type === "constructor" || item.type === "fallback" || item.type === "receive") {
      return item.type;
    }
    const name = item.name || "";
    const inputs = item.inputs?.map((input) => input.type).join(",") || "";
    return `${item.type}:${name}(${inputs})`;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  generateSignature(item) {
    if (item.type === "constructor") {
      const inputs = (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        item.inputs?.map((input) => `${input.type} ${input.name || ""}`).join(", ") || ""
      );
      return `constructor(${inputs})`;
    }
    if (item.type === "fallback" || item.type === "receive") {
      return item.type + "()";
    }
    if (item.type === "function") {
      const inputs = (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        item.inputs?.map((input) => `${input.type} ${input.name || ""}`).join(", ") || ""
      );
      const outputs = item.outputs?.map((output) => output.type).join(", ") || "";
      const mutability = item.stateMutability ? ` ${item.stateMutability}` : "";
      return `function ${item.name}(${inputs})${mutability}${outputs ? ` returns (${outputs})` : ""}`;
    }
    if (item.type === "event") {
      const inputs = item.inputs?.map((input) => {
        const indexed = input.indexed ? " indexed" : "";
        return `${input.type}${indexed} ${input.name || ""}`;
      }).join(", ") || "";
      return `event ${item.name}(${inputs})`;
    }
    return JSON.stringify(item);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  itemsEqual(item1, item2) {
    return JSON.stringify(item1) === JSON.stringify(item2);
  }
  calculateImpact(type, changeType) {
    if (type === "constructor" || type === "fallback" || type === "receive") {
      return changeType === "modified" ? "high" : "medium";
    }
    if (type === "function") {
      if (changeType === "removed") return "high";
      if (changeType === "modified") return "medium";
      if (changeType === "added") return "low";
    }
    if (type === "event") {
      return "low";
    }
    if (type === "error") {
      return "low";
    }
    return "medium";
  }
  calculateSeverity(differences) {
    if (differences.length === 0) return "none";
    const hasHighImpact = differences.some((d) => d.impact === "high");
    const hasMediumImpact = differences.some((d) => d.impact === "medium");
    const hasRemovedFunctions = differences.some(
      (d) => d.type === "removed" && d.section === "function"
    );
    if (hasRemovedFunctions || hasHighImpact) return "breaking";
    if (hasMediumImpact) return "major";
    return "minor";
  }
  generateSummary(differences) {
    const counts = {
      added: differences.filter((d) => d.type === "added").length,
      removed: differences.filter((d) => d.type === "removed").length,
      modified: differences.filter((d) => d.type === "modified").length
    };
    const parts = [];
    if (counts.added > 0) parts.push(`${counts.added} added`);
    if (counts.removed > 0) parts.push(`${counts.removed} removed`);
    if (counts.modified > 0) parts.push(`${counts.modified} modified`);
    const summary = parts.join(", ");
    return `${summary}`;
  }
};
var abiComparisonService = new AbiComparisonService();
async function compareContractDefinitions(storedSchema, freshSchema) {
  return abiComparisonService.compareAbis(storedSchema, freshSchema);
}
function validateContractDefinition(definition) {
  return abiComparisonService.validateAbi(definition);
}
function hashContractDefinition(definition) {
  return abiComparisonService.hashAbi(definition);
}
var EVM_TYPE_TO_FIELD_TYPE = {
  address: "blockchain-address",
  string: "text",
  uint: "number",
  uint8: "number",
  uint16: "number",
  uint32: "number",
  uint64: "bigint",
  uint128: "bigint",
  uint256: "bigint",
  int: "number",
  int8: "number",
  int16: "number",
  int32: "number",
  int64: "bigint",
  int128: "bigint",
  int256: "bigint",
  bool: "checkbox",
  bytes: "bytes",
  bytes32: "bytes"
};
var EVM_DYNAMIC_PATTERNS = [
  { name: "array", syntax: "T[]", mapsTo: "array", description: "Dynamic array of primitives" },
  { name: "fixed-array", syntax: "T[N]", mapsTo: "array", description: "Fixed-size array" },
  {
    name: "tuple-array",
    syntax: "tuple[]",
    mapsTo: "array-object",
    description: "Array of structs"
  },
  { name: "tuple", syntax: "tuple", mapsTo: "object", description: "Struct/tuple type" }
];
function getEvmTypeMappingInfo() {
  return {
    primitives: { ...EVM_TYPE_TO_FIELD_TYPE },
    dynamicPatterns: EVM_DYNAMIC_PATTERNS
  };
}
function mapEvmParamTypeToFieldType(parameterType) {
  if (parameterType.match(/^tuple\[\d*\]$/)) {
    return "array-object";
  }
  if (parameterType.match(/\[\d*\]$/)) {
    return "array";
  }
  const baseType = parameterType.replace(/\[\d*\]/g, "");
  if (baseType.startsWith("tuple")) {
    return "object";
  }
  if (baseType.match(/^bytes\d+$/)) {
    return "bytes";
  }
  return EVM_TYPE_TO_FIELD_TYPE[baseType] || "text";
}
function getEvmCompatibleFieldTypes(parameterType) {
  if (parameterType.match(/^tuple\[\d*\]$/)) {
    return ["array-object", "textarea", "text"];
  }
  if (parameterType.match(/\[\d*\]$/)) {
    return ["array", "textarea", "text"];
  }
  const baseType = parameterType.replace(/\[\d*\]/g, "");
  if (baseType.startsWith("tuple")) {
    return ["object", "textarea", "text"];
  }
  const compatibilityMap = {
    address: ["blockchain-address", "text"],
    uint: ["number", "amount", "text"],
    uint8: ["number", "amount", "text"],
    uint16: ["number", "amount", "text"],
    uint32: ["number", "amount", "text"],
    uint64: ["bigint", "number", "amount", "text"],
    uint128: ["bigint", "number", "amount", "text"],
    uint256: ["bigint", "number", "amount", "text"],
    int: ["number", "text"],
    int8: ["number", "text"],
    int16: ["number", "text"],
    int32: ["number", "text"],
    int64: ["bigint", "number", "text"],
    int128: ["bigint", "number", "text"],
    int256: ["bigint", "number", "text"],
    bool: ["checkbox", "select", "radio", "text"],
    string: ["text", "textarea", "email", "password"],
    bytes: ["bytes", "textarea", "text"],
    bytes32: ["bytes", "textarea", "text"]
  };
  if (baseType.match(/^bytes\d+$/)) {
    return ["bytes", "textarea", "text"];
  }
  return compatibilityMap[baseType] || ["text"];
}
function extractBytesSize(parameterType) {
  const match = parameterType.match(/^bytes(\d+)$/);
  if (match) {
    return Number.parseInt(match[1], 10);
  }
  return void 0;
}
function extractArrayElementType(parameterType) {
  const arrayMatch = parameterType.match(/^(.+)\[\d*\]$/);
  if (arrayMatch) {
    return arrayMatch[1];
  }
  return null;
}
function getDefaultValidation() {
  return { required: true };
}
var EVM_NUMERIC_BOUNDS = {
  uint: { min: 0 },
  uint8: { min: 0, max: 255 },
  uint16: { min: 0, max: 65535 },
  uint32: { min: 0, max: 4294967295 },
  int: {},
  int8: { min: -128, max: 127 },
  int16: { min: -32768, max: 32767 },
  int32: { min: -2147483648, max: 2147483647 }
};
function generateEvmDefaultField(parameter) {
  const fieldType = mapEvmParamTypeToFieldType(parameter.type);
  const baseField = {
    id: `field-${Math.random().toString(36).substring(2, 9)}`,
    name: parameter.name || parameter.type,
    // Use type if name missing
    label: (0, import_lodash2.startCase)(parameter.displayName || parameter.name || parameter.type),
    type: fieldType,
    placeholder: `Enter ${parameter.displayName || parameter.name || parameter.type}`,
    helperText: parameter.description || "",
    defaultValue: (0, import_ui_utils13.getDefaultValueForType)(fieldType),
    validation: (0, import_ui_utils13.enhanceNumericValidation)(
      getDefaultValidation(),
      parameter.type,
      EVM_NUMERIC_BOUNDS
    ),
    width: "full"
  };
  const bytesSize = extractBytesSize(parameter.type);
  if (bytesSize !== void 0) {
    baseField.metadata = {
      ...baseField.metadata ?? {},
      exactBytes: bytesSize
    };
  }
  if (fieldType === "array") {
    const elementType = extractArrayElementType(parameter.type);
    if (elementType) {
      const elementFieldType = mapEvmParamTypeToFieldType(elementType);
      const elementBytesSize = extractBytesSize(elementType);
      const arrayField = {
        ...baseField,
        elementType: elementFieldType,
        elementFieldConfig: {
          type: elementFieldType,
          validation: (0, import_ui_utils13.enhanceNumericValidation)(
            getDefaultValidation(),
            elementType,
            EVM_NUMERIC_BOUNDS
          ),
          placeholder: `Enter ${elementType}`,
          // Include exactBytes metadata for fixed-size bytes array elements (e.g., bytes32[])
          ...elementBytesSize !== void 0 && {
            metadata: { exactBytes: elementBytesSize }
          }
        }
      };
      return arrayField;
    }
  }
  if (parameter.components && (fieldType === "object" || fieldType === "array-object")) {
    const result = {
      ...baseField,
      components: parameter.components
    };
    return result;
  }
  return baseField;
}
function parseEvmInput(param, rawValue, isRecursive = false) {
  const { type, name } = param;
  const baseType = type.replace(/\[\d*\]$/, "");
  const isArray = type.endsWith("]");
  try {
    if (isArray) {
      let parsedArray;
      if (!isRecursive) {
        if (typeof rawValue !== "string") {
          throw new Error("Array input must be a JSON string representation.");
        }
        try {
          parsedArray = JSON.parse(rawValue);
        } catch (e) {
          throw new Error(`Invalid JSON for array: ${e.message}`);
        }
      } else {
        if (!Array.isArray(rawValue)) {
          throw new Error("Internal error: Expected array in recursive call.");
        }
        parsedArray = rawValue;
      }
      if (!Array.isArray(parsedArray)) {
        throw new Error("Parsed JSON is not an array.");
      }
      const itemAbiParam = { ...param, type: baseType };
      return parsedArray.map((item) => parseEvmInput(itemAbiParam, item, true));
    }
    if (baseType === "tuple") {
      if (!param.components) {
        throw new Error(`ABI definition missing 'components' for tuple parameter '${name}'.`);
      }
      let parsedObject;
      if (!isRecursive) {
        if (typeof rawValue !== "string") {
          throw new Error("Tuple input must be a JSON string representation of an object.");
        }
        try {
          parsedObject = JSON.parse(rawValue);
        } catch (e) {
          throw new Error(`Invalid JSON for tuple: ${e.message}`);
        }
      } else {
        if (typeof rawValue !== "object" || rawValue === null || Array.isArray(rawValue)) {
          throw new Error("Internal error: Expected object in recursive tuple call.");
        }
        parsedObject = rawValue;
      }
      if (typeof parsedObject !== "object" || parsedObject === null || Array.isArray(parsedObject)) {
        throw new Error("Parsed JSON is not an object for tuple.");
      }
      const resultObject = {};
      for (const component of param.components) {
        if (!(component.name in parsedObject)) {
          throw new Error(`Missing component '${component.name}' in tuple JSON.`);
        }
        resultObject[component.name] = parseEvmInput(
          component,
          parsedObject[component.name],
          true
          // Pass isRecursive=true
        );
      }
      if (Object.keys(parsedObject).length !== param.components.length) {
        const expectedKeys = param.components.map((c) => c.name).join(", ");
        const actualKeys = Object.keys(parsedObject).join(", ");
        throw new Error(
          `Tuple object has incorrect number of keys. Expected ${param.components.length} (${expectedKeys}), but got ${Object.keys(parsedObject).length} (${actualKeys}).`
        );
      }
      return resultObject;
    }
    if (baseType.startsWith("bytes")) {
      if (typeof rawValue !== "string") {
        throw new Error("Bytes input must be a string.");
      }
      if (!/^0x([0-9a-fA-F]{2})*$/.test(rawValue)) {
        throw new Error(
          `Invalid hex string format for ${type}: must start with 0x and contain only hex characters.`
        );
      }
      const fixedSizeMatch = baseType.match(/^bytes(\d+)$/);
      if (fixedSizeMatch) {
        const expectedBytes = parseInt(fixedSizeMatch[1], 10);
        const actualBytes = (rawValue.length - 2) / 2;
        if (actualBytes !== expectedBytes) {
          throw new Error(
            `Invalid length for ${type}: expected ${expectedBytes} bytes (${expectedBytes * 2} hex chars), got ${actualBytes} bytes.`
          );
        }
      }
      return rawValue;
    }
    if (baseType.startsWith("uint") || baseType.startsWith("int")) {
      if (rawValue === "" || rawValue === null || rawValue === void 0)
        throw new Error("Numeric value cannot be empty.");
      try {
        return BigInt(rawValue);
      } catch {
        throw new Error(`Invalid numeric value: '${rawValue}'.`);
      }
    } else if (baseType === "address") {
      if (typeof rawValue !== "string" || !rawValue)
        throw new Error("Address value must be a non-empty string.");
      if (!(0, import_viem6.isAddress)(rawValue)) throw new Error(`Invalid address format: '${rawValue}'.`);
      return (0, import_viem6.getAddress)(rawValue);
    } else if (baseType === "bool") {
      if (typeof rawValue === "boolean") return rawValue;
      if (typeof rawValue === "string") {
        const lowerVal = rawValue.toLowerCase().trim();
        if (lowerVal === "true") return true;
        if (lowerVal === "false") return false;
      }
      return Boolean(rawValue);
    } else if (baseType === "string") {
      return String(rawValue);
    }
    import_ui_utils14.logger.warn(
      "parseEvmInput",
      `Unknown EVM parameter type encountered: '${type}'. Using raw value.`
    );
    return rawValue;
  } catch (error) {
    throw new Error(
      `Failed to parse value for parameter '${name || "(unnamed)"}' (type '${type}'): ${error.message}`
    );
  }
}
init_utils();
function formatEvmFunctionResult(decodedValue, functionDetails) {
  if (!functionDetails.outputs || !Array.isArray(functionDetails.outputs)) {
    import_ui_utils15.logger.warn(
      "formatEvmFunctionResult",
      `Output ABI definition missing or invalid for function ${functionDetails.name}.`
    );
    return "[Error: Output ABI definition missing]";
  }
  try {
    let valueToFormat;
    if (Array.isArray(decodedValue)) {
      if (decodedValue.length === 1) {
        valueToFormat = decodedValue[0];
      } else {
        valueToFormat = decodedValue;
      }
    } else {
      valueToFormat = decodedValue;
    }
    if (typeof valueToFormat === "bigint") {
      return valueToFormat.toString();
    } else if (typeof valueToFormat === "string" || typeof valueToFormat === "number" || typeof valueToFormat === "boolean") {
      return String(valueToFormat);
    } else if (valueToFormat === null || valueToFormat === void 0) {
      return "(null)";
    } else {
      return stringifyWithBigInt(valueToFormat, 2);
    }
  } catch (error) {
    const errorMessage = `Error formatting result for ${functionDetails.name}: ${error.message}`;
    import_ui_utils15.logger.error("formatEvmFunctionResult", errorMessage, {
      functionName: functionDetails.name,
      decodedValue,
      error
    });
    return `[${errorMessage}]`;
  }
}
function isEvmViewFunction(functionDetails) {
  return functionDetails.stateMutability === "view" || functionDetails.stateMutability === "pure";
}
function createPublicClientWithRpc(networkConfig, rpcUrl) {
  let chainForViem;
  if (networkConfig.viemChain) {
    chainForViem = networkConfig.viemChain;
  } else {
    import_ui_utils16.logger.warn(
      "createPublicClientWithRpc",
      `Viem chain object (viemChain) not provided in EvmNetworkConfig for ${networkConfig.name} (query). Creating a minimal one.`
    );
    if (!networkConfig.rpcUrl) {
      throw new Error(
        `RPC URL is missing in networkConfig for ${networkConfig.name} and viemChain is not set for query client.`
      );
    }
    chainForViem = {
      id: networkConfig.chainId,
      name: networkConfig.name,
      nativeCurrency: networkConfig.nativeCurrency,
      rpcUrls: {
        default: { http: [networkConfig.rpcUrl] },
        public: { http: [networkConfig.rpcUrl] }
      },
      blockExplorers: networkConfig.explorerUrl ? { default: { name: `${networkConfig.name} Explorer`, url: networkConfig.explorerUrl } } : void 0
    };
  }
  try {
    const publicClient = (0, import_viem7.createPublicClient)({
      chain: chainForViem,
      transport: (0, import_viem7.http)(rpcUrl)
    });
    return publicClient;
  } catch (error) {
    import_ui_utils16.logger.error(
      "createPublicClientWithRpc",
      "Failed to create network-specific public client for query:",
      error
    );
    throw new Error(
      `Failed to create network-specific public client for query: ${error.message}`
    );
  }
}
async function queryEvmViewFunction(contractAddress, functionId, params, schema, rpcUrl, networkConfig) {
  import_ui_utils16.logger.info(
    "queryEvmViewFunction",
    `Querying view function: ${functionId} on ${contractAddress}`,
    { params }
  );
  try {
    if (!contractAddress || !(0, import_viem7.isAddress)(contractAddress)) {
      throw new Error(`Invalid contract address provided: ${contractAddress}`);
    }
    const functionDetails = schema.functions.find((fn) => fn.id === functionId);
    if (!functionDetails) {
      throw new Error(`Function with ID ${functionId} not found in contract schema.`);
    }
    if (!isEvmViewFunction(functionDetails)) {
      throw new Error(`Function ${functionDetails.name} is not a view function.`);
    }
    const expectedInputs = functionDetails.inputs;
    if (params.length !== expectedInputs.length) {
      throw new Error(
        `Incorrect number of parameters provided for ${functionDetails.name}. Expected ${expectedInputs.length}, got ${params.length}.`
      );
    }
    const args = expectedInputs.map((inputParam, index) => {
      let rawValue = params[index];
      if (typeof inputParam.type === "string" && inputParam.type.endsWith("[]") && Array.isArray(rawValue)) {
        rawValue = JSON.stringify(rawValue);
      }
      return parseEvmInput(inputParam, rawValue, false);
    });
    import_ui_utils16.logger.debug("queryEvmViewFunction", "Parsed Args for readContract:", args);
    const minimalConfig = networkConfig || {
      id: "query-network",
      name: "Query Network",
      ecosystem: "evm",
      network: "unknown",
      type: "mainnet",
      isTestnet: false,
      chainId: 1,
      // Default to mainnet chain ID
      rpcUrl,
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      exportConstName: "queryNetwork"
    };
    const publicClient = createPublicClientWithRpc(minimalConfig, rpcUrl);
    const functionAbiItem = createAbiFunctionItem(functionDetails);
    import_ui_utils16.logger.debug(
      "queryEvmViewFunction",
      `[Query ${functionDetails.name}] Calling readContract with ABI:`,
      functionAbiItem,
      "Args:",
      args
    );
    let decodedResult;
    try {
      decodedResult = await publicClient.readContract({
        address: contractAddress,
        abi: [functionAbiItem],
        functionName: functionDetails.name,
        args
      });
    } catch (readError) {
      import_ui_utils16.logger.error(
        "queryEvmViewFunction",
        `[Query ${functionDetails.name}] publicClient.readContract specific error:`,
        readError
      );
      throw new Error(
        `Viem readContract failed for ${functionDetails.name}: ${readError.message}`
      );
    }
    import_ui_utils16.logger.debug(
      "queryEvmViewFunction",
      `[Query ${functionDetails.name}] Raw decoded result:`,
      decodedResult
    );
    return decodedResult;
  } catch (error) {
    const errorMessage = `Failed to query view function ${functionId}: ${error.message}`;
    import_ui_utils16.logger.error("queryEvmViewFunction", errorMessage, {
      contractAddress,
      functionId,
      params,
      error
    });
    throw new Error(errorMessage);
  }
}
function formatEvmTransactionData(contractSchema, functionId, submittedInputs, fields) {
  import_ui_utils17.logger.info(
    "formatEvmTransactionData",
    `Formatting EVM transaction data for function: ${functionId}`
  );
  const functionDetails = contractSchema.functions.find((fn) => fn.id === functionId);
  if (!functionDetails) {
    throw new Error(`Function definition for ${functionId} not found in provided contract schema.`);
  }
  const expectedArgs = functionDetails.inputs;
  const orderedRawValues = [];
  for (const expectedArg of expectedArgs) {
    const fieldConfig = fields.find((field) => field.name === expectedArg.name);
    if (!fieldConfig) {
      throw new Error(`Configuration missing for argument: ${expectedArg.name} in provided fields`);
    }
    let value;
    if (fieldConfig.isHardcoded) {
      value = fieldConfig.hardcodedValue;
    } else if (fieldConfig.isHidden) {
      throw new Error(`Field '${fieldConfig.name}' cannot be hidden without being hardcoded.`);
    } else {
      if (!(fieldConfig.name in submittedInputs)) {
        throw new Error(`Missing submitted input for required field: ${fieldConfig.name}`);
      }
      value = submittedInputs[fieldConfig.name];
    }
    orderedRawValues.push(value);
  }
  const transformedArgs = expectedArgs.map((param, index) => {
    let valueToParse = orderedRawValues[index];
    if (typeof param.type === "string" && param.type.endsWith("[]") && Array.isArray(valueToParse)) {
      valueToParse = JSON.stringify(valueToParse);
    }
    return parseEvmInput(param, valueToParse, false);
  });
  const isPayable = functionDetails.stateMutability === "payable";
  let transactionValue = 0n;
  if (isPayable) {
    import_ui_utils17.logger.warn(
      "formatEvmTransactionData",
      "Payable function detected, but sending 0 ETH. Implement value input."
    );
  }
  const functionAbiItem = createAbiFunctionItem(functionDetails);
  if (!contractSchema.address || !(0, import_viem8.isAddress)(contractSchema.address)) {
    throw new Error("Contract address is missing or invalid in the provided schema.");
  }
  const paramsForSignAndBroadcast = {
    address: contractSchema.address,
    abi: [functionAbiItem],
    functionName: functionDetails.name,
    args: transformedArgs,
    value: transactionValue
    // Pass BigInt value
  };
  return paramsForSignAndBroadcast;
}
init_eoa2();
init_relayer();
var SYSTEM_LOG_TAG3 = "evm-core-sender";
async function executeEvmTransaction(transactionData, executionConfig, walletImplementation, onStatusChange, runtimeApiKey) {
  const method = executionConfig.method || "eoa";
  import_ui_utils18.logger.info(SYSTEM_LOG_TAG3, "executeEvmTransaction: Starting transaction execution", { method });
  const { EoaExecutionStrategy: EoaExecutionStrategy2 } = await Promise.resolve().then(() => (init_eoa2(), eoa_exports));
  const { RelayerExecutionStrategy: RelayerExecutionStrategy2 } = await Promise.resolve().then(() => (init_relayer(), relayer_exports));
  let strategy;
  switch (method) {
    case "eoa":
      strategy = new EoaExecutionStrategy2();
      break;
    case "relayer":
      strategy = new RelayerExecutionStrategy2();
      break;
    case "multisig":
      import_ui_utils18.logger.warn(SYSTEM_LOG_TAG3, "Multisig execution not yet implemented");
      throw new Error("Multisig execution is not yet supported.");
    default: {
      const exhaustiveCheck = method;
      throw new Error(`Unsupported execution method: ${exhaustiveCheck}`);
    }
  }
  return strategy.execute(
    transactionData,
    executionConfig,
    walletImplementation,
    onStatusChange,
    runtimeApiKey
  );
}
async function waitForEvmTransactionConfirmation(txHash, walletImplementation) {
  import_ui_utils18.logger.info(SYSTEM_LOG_TAG3, `Waiting for tx: ${txHash}`);
  try {
    const resolvedPublicClient = await walletImplementation.getPublicClient();
    if (!resolvedPublicClient) {
      throw new Error("Public client not available to wait for transaction.");
    }
    const receipt = await resolvedPublicClient.waitForTransactionReceipt({
      hash: txHash
    });
    import_ui_utils18.logger.info(SYSTEM_LOG_TAG3, "Received receipt:", receipt);
    if (receipt.status === "success") {
      return { status: "success", receipt };
    } else {
      import_ui_utils18.logger.error(SYSTEM_LOG_TAG3, "Transaction reverted:", receipt);
      return { status: "error", receipt, error: new Error("Transaction reverted.") };
    }
  } catch (error) {
    import_ui_utils18.logger.error(SYSTEM_LOG_TAG3, "Error waiting for transaction confirmation:", error);
    return {
      status: "error",
      error: error instanceof Error ? error : new Error(String(error))
    };
  }
}
var WagmiProviderInitializedContext = (0, import_react.createContext)(false);
var useIsWagmiProviderInitialized = () => {
  return (0, import_react2.useContext)(WagmiProviderInitializedContext);
};
var SafeWagmiComponent = ({
  children,
  fallback = null
}) => {
  const isProviderInitialized = useIsWagmiProviderInitialized();
  const [hasError, setHasError] = (0, import_react3.useState)(false);
  (0, import_react3.useEffect)(() => {
    if (isProviderInitialized) {
      setHasError(false);
    }
  }, [isProviderInitialized]);
  (0, import_react3.useEffect)(() => {
    const handleError = (event) => {
      if (event.error?.message?.includes("useConfig") || event.error?.message?.includes("WagmiProvider")) {
        import_ui_utils19.logger.debug(
          "SafeWagmiComponent",
          "Caught wagmi error via window error event:",
          event.error
        );
        setHasError(true);
        event.preventDefault();
      }
    };
    window.addEventListener("error", handleError);
    return () => {
      window.removeEventListener("error", handleError);
    };
  }, []);
  if (!isProviderInitialized || hasError) {
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: fallback });
  }
  try {
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
  } catch (error) {
    if (error instanceof Error && (error.message.includes("useConfig") || error.message.includes("WagmiProvider"))) {
      import_ui_utils19.logger.debug("SafeWagmiComponent", "Caught wagmi error:", error);
      setHasError(true);
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: fallback });
    }
    throw error;
  }
};
var ConnectorDialog = ({
  open,
  onOpenChange,
  showInjectedConnector = false
}) => {
  const unavailableContent = /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_ui_components2.Dialog, { open, onOpenChange, children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_ui_components2.DialogContent, { className: "sm:max-w-[425px]", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(import_ui_components2.DialogHeader, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_ui_components2.DialogTitle, { children: "Wallet Connection Unavailable" }),
    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_ui_components2.DialogDescription, { children: "The wallet connection system is not properly initialized." })
  ] }) }) });
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(SafeWagmiComponent, { fallback: unavailableContent, children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
    ConnectorDialogContent,
    {
      open,
      onOpenChange,
      showInjectedConnector
    }
  ) });
};
var ConnectorDialogContent = ({
  open,
  onOpenChange,
  showInjectedConnector = false
}) => {
  const { connect: connect2, connectors, error: connectError, isConnecting } = (0, import_ui_react2.useDerivedConnectStatus)();
  const { isConnected } = (0, import_ui_react2.useDerivedAccountStatus)();
  const [connectingId, setConnectingId] = (0, import_react5.useState)(null);
  (0, import_react5.useEffect)(() => {
    if (isConnected && connectingId) {
      onOpenChange(false);
      setConnectingId(null);
    }
  }, [isConnected, connectingId, onOpenChange]);
  if (!connect2) {
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_ui_components2.Dialog, { open, onOpenChange, children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(import_ui_components2.DialogContent, { className: "sm:max-w-[425px]", children: [
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_ui_components2.DialogHeader, { children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_ui_components2.DialogTitle, { children: "Error" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("p", { children: "Wallet connection function is not available." })
    ] }) });
  }
  const handleConnectorSelect = (selectedConnector) => {
    setConnectingId(selectedConnector.id);
    connect2({ connector: selectedConnector });
  };
  const filteredConnectors = connectors.filter((connector) => {
    const isInjected = connector.id === "injected";
    return !(isInjected && !showInjectedConnector);
  });
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_ui_components2.Dialog, { open, onOpenChange, children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(import_ui_components2.DialogContent, { className: "sm:max-w-[425px]", children: [
    /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(import_ui_components2.DialogHeader, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_ui_components2.DialogTitle, { children: "Connect Wallet" }),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_ui_components2.DialogDescription, { children: "Select a wallet provider to connect with this application." })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "grid gap-4 py-4", children: filteredConnectors.length === 0 ? /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("p", { className: "text-center text-muted-foreground", children: "No wallet connectors available." }) : filteredConnectors.map((connector) => /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
      import_ui_components2.Button,
      {
        onClick: () => handleConnectorSelect(connector),
        disabled: isConnecting && connectingId === connector.id,
        variant: "outline",
        className: "flex justify-between items-center w-full py-6",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { children: connector.name }),
          isConnecting && connectingId === connector.id && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "ml-2 text-xs", children: "Connecting..." })
        ]
      },
      connector.id
    )) }),
    connectError && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("p", { className: "text-sm text-red-500 mt-1", children: connectError.message || "Error connecting wallet" })
  ] }) });
};
var CustomConnectButton = ({
  className,
  size,
  variant,
  fullWidth,
  hideWhenConnected = true,
  showInjectedConnector = false
}) => {
  const [dialogOpen, setDialogOpen] = (0, import_react4.useState)(false);
  const sizeProps = (0, import_ui_utils20.getWalletButtonSizeProps)(size);
  const unavailableButton = /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: (0, import_ui_utils20.cn)("flex items-center", fullWidth && "w-full", className), children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(
    import_ui_components.Button,
    {
      disabled: true,
      variant: variant || "outline",
      size: sizeProps.size,
      className: (0, import_ui_utils20.cn)(sizeProps.className, fullWidth && "w-full"),
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_lucide_react.Wallet, { className: (0, import_ui_utils20.cn)(sizeProps.iconSize, "mr-1") }),
        "Wallet Unavailable"
      ]
    }
  ) });
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(SafeWagmiComponent, { fallback: unavailableButton, children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
    ConnectButtonContent,
    {
      className,
      size,
      variant,
      fullWidth,
      dialogOpen,
      setDialogOpen,
      hideWhenConnected,
      showInjectedConnector
    }
  ) });
};
var ConnectButtonContent = ({
  className,
  size,
  variant,
  fullWidth,
  dialogOpen,
  setDialogOpen,
  hideWhenConnected,
  showInjectedConnector
}) => {
  const { isConnected } = (0, import_ui_react.useDerivedAccountStatus)();
  const { isConnecting: isHookConnecting, error: connectError } = (0, import_ui_react.useDerivedConnectStatus)();
  const [isManuallyInitiated, setIsManuallyInitiated] = (0, import_react4.useState)(false);
  const sizeProps = (0, import_ui_utils20.getWalletButtonSizeProps)(size);
  (0, import_react4.useEffect)(() => {
    if (isConnected && hideWhenConnected) {
      setDialogOpen(false);
      setIsManuallyInitiated(false);
    }
  }, [isConnected, hideWhenConnected, setDialogOpen]);
  (0, import_react4.useEffect)(() => {
    if (!dialogOpen) {
      setIsManuallyInitiated(false);
    }
  }, [dialogOpen]);
  (0, import_react4.useEffect)(() => {
    if (isHookConnecting) {
      setIsManuallyInitiated(false);
    }
  }, [isHookConnecting]);
  const handleConnectClick = () => {
    if (!isConnected) {
      setIsManuallyInitiated(true);
      setDialogOpen(true);
    }
  };
  if (isConnected && hideWhenConnected) {
    return null;
  }
  const showButtonLoading = isHookConnecting || isManuallyInitiated;
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: (0, import_ui_utils20.cn)("flex items-center", fullWidth && "w-full", className), children: [
    /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(
      import_ui_components.Button,
      {
        onClick: handleConnectClick,
        disabled: showButtonLoading || isConnected,
        variant: variant || "outline",
        size: sizeProps.size,
        className: (0, import_ui_utils20.cn)(sizeProps.className, fullWidth && "w-full"),
        title: isConnected ? "Connected" : connectError?.message || "Connect Wallet",
        children: [
          showButtonLoading ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_lucide_react.Loader2, { className: (0, import_ui_utils20.cn)(sizeProps.iconSize, "animate-spin mr-1") }) : /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_lucide_react.Wallet, { className: (0, import_ui_utils20.cn)(sizeProps.iconSize, "mr-1") }),
          showButtonLoading ? "Connecting..." : "Connect Wallet"
        ]
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      ConnectorDialog,
      {
        open: dialogOpen,
        onOpenChange: (open) => {
          setDialogOpen(open);
          if (!open) {
            setIsManuallyInitiated(false);
          }
        },
        showInjectedConnector
      }
    )
  ] });
};
var CustomAccountDisplay = ({
  className,
  size,
  variant,
  fullWidth
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(SafeWagmiComponent, { fallback: null, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
    AccountDisplayContent,
    {
      className,
      size,
      variant,
      fullWidth
    }
  ) });
};
var AccountDisplayContent = ({
  className,
  size,
  variant,
  fullWidth
}) => {
  const { isConnected, address, chainId } = (0, import_ui_react3.useDerivedAccountStatus)();
  const { disconnect: disconnect2 } = (0, import_ui_react3.useDerivedDisconnect)();
  const sizeProps = (0, import_ui_utils21.getWalletAccountDisplaySizeProps)(size);
  if (!isConnected || !address || !disconnect2) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: (0, import_ui_utils21.cn)("flex items-center gap-2", fullWidth && "w-full", className), children: [
    /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: (0, import_ui_utils21.cn)("flex flex-col", fullWidth && "flex-1"), children: [
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { className: (0, import_ui_utils21.cn)(sizeProps.textSize, "font-medium"), children: (0, import_ui_utils21.truncateMiddle)(address, 4, 4) }),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { className: (0, import_ui_utils21.cn)(sizeProps.subTextSize, "text-muted-foreground -mt-0.5"), children: chainId ? `Chain ID: ${chainId}` : "Chain ID: N/A" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
      import_ui_components3.Button,
      {
        onClick: () => disconnect2(),
        variant: variant || "ghost",
        size: "icon",
        className: (0, import_ui_utils21.cn)(sizeProps.iconButtonSize, "p-0"),
        title: "Disconnect wallet",
        children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(import_lucide_react2.LogOut, { className: sizeProps.iconSize })
      }
    )
  ] });
};
var CustomNetworkSwitcher = ({
  className,
  size,
  variant,
  fullWidth
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(SafeWagmiComponent, { fallback: null, children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
    NetworkSwitcherContent,
    {
      className,
      size,
      variant,
      fullWidth
    }
  ) });
};
var NetworkSwitcherContent = ({
  className,
  size,
  variant,
  fullWidth
}) => {
  const { isConnected } = (0, import_ui_react4.useDerivedAccountStatus)();
  const { currentChainId, availableChains: unknownChains } = (0, import_ui_react4.useDerivedChainInfo)();
  const { switchChain: switchChain2, isSwitching: isPending, error } = (0, import_ui_react4.useDerivedSwitchChainStatus)();
  const sizeProps = (0, import_ui_utils22.getWalletNetworkSwitcherSizeProps)(size);
  const variantClassName = (0, import_ui_utils22.getWalletNetworkSwitcherVariantClassName)(variant);
  const typedAvailableChains = unknownChains;
  if (!isConnected || !switchChain2 || typedAvailableChains.length === 0) {
    return null;
  }
  const handleNetworkChange = (chainId) => {
    if (chainId !== currentChainId) {
      switchChain2({ chainId });
    }
  };
  const currentChain = typedAvailableChains.find((chain) => chain.id === currentChainId);
  const currentChainName = currentChain?.name || "Network";
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: (0, import_ui_utils22.cn)("flex items-center", fullWidth && "w-full", className), children: [
    /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(
      import_ui_components4.Select,
      {
        value: currentChainId?.toString() ?? "",
        onValueChange: (value) => handleNetworkChange(Number(value)),
        disabled: isPending || typedAvailableChains.length === 0,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
            import_ui_components4.SelectTrigger,
            {
              className: (0, import_ui_utils22.cn)(
                sizeProps.triggerClassName,
                variantClassName,
                fullWidth && "w-full max-w-none"
              ),
              children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_ui_components4.SelectValue, { placeholder: "Network", children: currentChainName })
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
            import_ui_components4.SelectContent,
            {
              position: "popper",
              sideOffset: 5,
              align: "start",
              className: "w-auto min-w-[160px] max-h-[300px]",
              children: typedAvailableChains.map((chain) => /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                import_ui_components4.SelectItem,
                {
                  value: chain.id.toString(),
                  className: sizeProps.itemClassName,
                  children: chain.name
                },
                chain.id
              ))
            }
          )
        ]
      }
    ),
    isPending && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { className: "text-muted-foreground ml-2", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_lucide_react3.Loader2, { className: (0, import_ui_utils22.cn)(sizeProps.loaderSize, "animate-spin") }) }),
    error && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { className: "text-xs text-red-500 ml-2", children: "!" })
  ] });
};
var DEFAULT_DISCONNECTED_STATUS = {
  isConnected: false,
  isConnecting: false,
  isDisconnected: true,
  isReconnecting: false,
  status: "disconnected",
  address: void 0,
  addresses: void 0,
  chainId: void 0,
  chain: void 0,
  connector: void 0
};
async function connectAndEnsureCorrectNetworkCore(impl, connectorId, targetChainId, logSystem) {
  const connectionResult = await impl.connect(connectorId);
  if (!connectionResult.connected || !connectionResult.address || !connectionResult.chainId) {
    return { connected: false, error: connectionResult.error || "Connection failed" };
  }
  if (connectionResult.chainId !== targetChainId) {
    import_ui_utils23.logger.info(
      logSystem,
      `Connected to chain ${connectionResult.chainId}, but target is ${targetChainId}. Attempting switch.`
    );
    try {
      await impl.switchNetwork(targetChainId);
      const postSwitchStatus = impl.getWalletConnectionStatus();
      if (postSwitchStatus.chainId !== targetChainId) {
        const switchError = `Failed to switch to target network ${targetChainId}. Current: ${postSwitchStatus.chainId}`;
        import_ui_utils23.logger.error(logSystem, switchError);
        try {
          await impl.disconnect();
        } catch (e) {
          import_ui_utils23.logger.warn(logSystem, "Failed to disconnect after network switch failure.", e);
        }
        return { connected: false, error: switchError };
      }
      import_ui_utils23.logger.info(logSystem, `Successfully switched to target chain ${targetChainId}.`);
      return { ...connectionResult, chainId: postSwitchStatus.chainId };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      import_ui_utils23.logger.error(logSystem, "Network switch failed:", errorMessage);
      try {
        await impl.disconnect();
      } catch (e) {
        import_ui_utils23.logger.warn(logSystem, "Failed to disconnect after network switch failure.", e);
      }
      return { connected: false, error: `Network switch failed: ${errorMessage}` };
    }
  }
  return connectionResult;
}
init_artifacts();
async function validateEvmNetworkServiceConfig(serviceId, values) {
  if (serviceId === "rpc") {
    const cfg = { url: String(values.rpcUrl || ""), isCustom: true };
    return validateEvmRpcEndpoint(cfg);
  }
  if (serviceId === "explorer") {
    const cfg = {
      explorerUrl: values.explorerUrl ? String(values.explorerUrl) : void 0,
      apiUrl: values.apiUrl ? String(values.apiUrl) : void 0,
      apiKey: values.apiKey ? String(values.apiKey) : void 0,
      isCustom: true,
      applyToAllNetworks: Boolean(values.applyToAllNetworks)
    };
    return validateEvmExplorerConfig(cfg);
  }
  if (serviceId === "contract-definitions") {
    const raw = values.defaultProvider;
    if (raw === void 0 || raw === null || raw === "") return true;
    return isEvmProviderKey(raw);
  }
  return true;
}
async function testEvmNetworkServiceConnection(serviceId, values, networkConfig) {
  if (serviceId === "rpc") {
    const cfg = { url: String(values.rpcUrl || ""), isCustom: true };
    return testEvmRpcConnection(cfg);
  }
  if (serviceId === "explorer") {
    const cfg = {
      explorerUrl: values.explorerUrl ? String(values.explorerUrl) : void 0,
      apiUrl: values.apiUrl ? String(values.apiUrl) : void 0,
      apiKey: values.apiKey ? String(values.apiKey) : void 0,
      isCustom: true,
      applyToAllNetworks: Boolean(values.applyToAllNetworks)
    };
    return testEvmExplorerConnection(cfg, networkConfig);
  }
  return { success: true };
}
function getSupportedChainsFromNetworks(networkConfigs, logSystem) {
  const chains = networkConfigs.filter((network) => network.viemChain).map((network) => network.viemChain).filter((chain, index, self) => self.findIndex((c) => c.id === chain.id) === index);
  import_ui_utils24.logger.info(
    logSystem,
    `Generated supported chains from network configurations: ${chains.length} chains`,
    chains.map((c) => ({ id: c.id, name: c.name }))
  );
  return chains;
}
function getChainIdToNetworkIdMapping(networkConfigs, logSystem) {
  const mapping = networkConfigs.filter((network) => network.viemChain).reduce(
    (acc, network) => {
      acc[network.chainId] = network.id;
      return acc;
    },
    {}
  );
  import_ui_utils24.logger.info(
    logSystem,
    "Generated chain ID to network ID mapping from network configurations:",
    mapping
  );
  return mapping;
}
var WagmiWalletImplementation = class {
  /**
   * Constructs the WagmiWalletImplementation.
   * Configuration for Wagmi is deferred until actually needed or set externally.
   *
   * @param config - Configuration options for the wallet implementation
   */
  constructor(config) {
    __publicField2(this, "defaultInstanceConfig", null);
    __publicField2(this, "activeWagmiConfig", null);
    __publicField2(this, "unsubscribe");
    __publicField2(this, "initialized", false);
    __publicField2(this, "walletConnectProjectId");
    __publicField2(this, "rpcConfigUnsubscribe");
    __publicField2(this, "supportedChains");
    __publicField2(this, "chainIdToNetworkId");
    __publicField2(this, "logSystem");
    __publicField2(this, "rainbowKitConfigFn");
    this.logSystem = config.logSystem ?? "WagmiWalletImplementation";
    this.walletConnectProjectId = config.walletConnectProjectId;
    this.supportedChains = config.chains.length > 0 ? config.chains : getSupportedChainsFromNetworks(config.networkConfigs, this.logSystem);
    this.chainIdToNetworkId = getChainIdToNetworkIdMapping(config.networkConfigs, this.logSystem);
    import_ui_utils24.logger.info(
      this.logSystem,
      "Constructor called. Initial anticipated kitName:",
      config.initialUiKitConfig?.kitName
    );
    this.initialized = true;
    import_ui_utils24.logger.info(
      this.logSystem,
      "WagmiWalletImplementation instance initialized (Wagmi config creation deferred)."
    );
    this.setupRpcConfigListener();
  }
  /**
   * Sets the RainbowKit config retrieval function.
   * This allows adapters to inject their own RainbowKit integration.
   *
   * @param fn - Function to get RainbowKit wagmi config
   */
  setRainbowKitConfigFn(fn) {
    this.rainbowKitConfigFn = fn;
  }
  /**
   * Gets the supported chains for this implementation.
   */
  getSupportedChains() {
    return this.supportedChains;
  }
  /**
   * Gets the chain ID to network ID mapping.
   */
  getChainIdToNetworkIdMapping() {
    return this.chainIdToNetworkId;
  }
  /**
   * Sets up a listener for RPC configuration changes to invalidate the cached Wagmi config
   * when user changes RPC settings.
   */
  setupRpcConfigListener() {
    import("@openzeppelin/ui-utils").then(({ userRpcConfigService }) => {
      this.rpcConfigUnsubscribe = userRpcConfigService.subscribe("*", (event) => {
        if (event.type === "rpc-config-changed" || event.type === "rpc-config-cleared") {
          import_ui_utils24.logger.info(
            this.logSystem,
            `RPC config changed for network ${event.networkId}. Invalidating cached Wagmi config.`
          );
          this.defaultInstanceConfig = null;
        }
      });
    }).catch((error) => {
      import_ui_utils24.logger.error(this.logSystem, "Failed to setup RPC config listener:", error);
    });
  }
  /**
   * Cleanup method to unsubscribe from RPC config changes
   */
  cleanup() {
    if (this.rpcConfigUnsubscribe) {
      this.rpcConfigUnsubscribe();
      this.rpcConfigUnsubscribe = void 0;
    }
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = void 0;
    }
  }
  /**
   * Sets the externally determined, currently active WagmiConfig instance.
   * This is typically called by UiKitManager after it has resolved the appropriate
   * config for the selected UI kit (e.g., RainbowKit's config or a default custom config).
   *
   * @param config - The Wagmi Config object to set as active, or null to clear it.
   */
  setActiveWagmiConfig(config) {
    import_ui_utils24.logger.info(
      this.logSystem,
      "setActiveWagmiConfig called with config:",
      config ? "Valid Config" : "Null"
    );
    this.activeWagmiConfig = config;
    if (this.unsubscribe) {
      import_ui_utils24.logger.warn(
        this.logSystem,
        "setActiveWagmiConfig: Active WagmiConfig instance has changed. Existing direct watchAccount subscription (via onWalletConnectionChange) may be stale and operating on an old config instance."
      );
    }
  }
  /**
   * Checks if an active wagmi config has been set.
   * Subclasses can use this to determine if the wallet is ready for operations.
   *
   * @returns true if an active wagmi config is set
   */
  hasActiveConfig() {
    return this.activeWagmiConfig !== null;
  }
  /**
   * Creates a default WagmiConfig instance on demand.
   * This configuration includes standard connectors (injected, MetaMask, Safe)
   * and WalletConnect if a project ID is available.
   * Used as a fallback or for 'custom' UI kit mode.
   *
   * @returns A Wagmi Config object.
   */
  createDefaultConfig() {
    const baseConnectors = [(0, import_connectors.injected)(), (0, import_connectors.metaMask)(), (0, import_connectors.safe)()];
    if (this.walletConnectProjectId?.trim()) {
      baseConnectors.push((0, import_connectors.walletConnect)({ projectId: this.walletConnectProjectId }));
      import_ui_utils24.logger.info(this.logSystem, "WalletConnect connector added to DEFAULT config.");
    } else {
      import_ui_utils24.logger.warn(
        this.logSystem,
        "WalletConnect Project ID not provided; WC connector unavailable for DEFAULT config."
      );
    }
    const transportsConfig = this.supportedChains.reduce(
      (acc, chainDefinition) => {
        let rpcUrlToUse = chainDefinition.rpcUrls.default?.http?.[0];
        const appNetworkIdString = this.chainIdToNetworkId[chainDefinition.id];
        if (appNetworkIdString) {
          let httpRpcOverride = getUserRpcUrl(appNetworkIdString);
          if (!httpRpcOverride) {
            const rpcOverrideSetting = import_ui_utils24.appConfigService.getRpcEndpointOverride(appNetworkIdString);
            if (typeof rpcOverrideSetting === "string") {
              httpRpcOverride = rpcOverrideSetting;
            } else if (typeof rpcOverrideSetting === "object") {
              if ("http" in rpcOverrideSetting && rpcOverrideSetting.http) {
                httpRpcOverride = rpcOverrideSetting.http;
              } else if ("url" in rpcOverrideSetting && rpcOverrideSetting.url) {
                httpRpcOverride = rpcOverrideSetting.url;
              }
            }
          }
          if (httpRpcOverride) {
            import_ui_utils24.logger.info(
              this.logSystem,
              `Using overridden RPC for chain ${chainDefinition.name} (default config): ${httpRpcOverride}`
            );
            rpcUrlToUse = httpRpcOverride;
          }
        }
        acc[chainDefinition.id] = (0, import_viem9.http)(rpcUrlToUse);
        return acc;
      },
      {}
    );
    try {
      const defaultConfig2 = (0, import_core.createConfig)({
        chains: this.supportedChains,
        connectors: baseConnectors,
        transports: transportsConfig
      });
      import_ui_utils24.logger.info(this.logSystem, "Default Wagmi config created successfully on demand.");
      return defaultConfig2;
    } catch (error) {
      import_ui_utils24.logger.error(this.logSystem, "Error creating default Wagmi config on demand:", error);
      return (0, import_core.createConfig)({
        chains: [this.supportedChains[0]],
        connectors: [(0, import_connectors.injected)()],
        transports: { [this.supportedChains[0].id]: (0, import_viem9.http)() }
      });
    }
  }
  /**
   * Wrapper function to convert AppConfigService RPC overrides to the format expected by RainbowKit.
   *
   * @param networkId - The network ID to get RPC override for
   * @returns RPC configuration in the format expected by RainbowKit
   */
  getRpcOverrideForRainbowKit(networkId) {
    const userRpcUrl = getUserRpcUrl(networkId);
    if (userRpcUrl) {
      return { http: userRpcUrl };
    }
    const rpcOverrideSetting = import_ui_utils24.appConfigService.getRpcEndpointOverride(networkId);
    if (typeof rpcOverrideSetting === "string") {
      return rpcOverrideSetting;
    } else if (typeof rpcOverrideSetting === "object" && rpcOverrideSetting !== null) {
      if ("url" in rpcOverrideSetting && typeof rpcOverrideSetting.url === "string") {
        return {
          http: rpcOverrideSetting.url
        };
      } else if ("http" in rpcOverrideSetting || "ws" in rpcOverrideSetting) {
        const config = rpcOverrideSetting;
        return {
          http: config.http,
          ws: config.ws
        };
      }
    }
    return void 0;
  }
  /**
   * Retrieves or creates the WagmiConfig specifically for RainbowKit.
   * This delegates to the injected RainbowKit config function if available.
   *
   * @param currentAdapterUiKitConfig - The fully resolved UI kit configuration for the adapter.
   * @returns A Promise resolving to the RainbowKit-specific Wagmi Config object, or null if creation fails or not RainbowKit.
   */
  async getConfigForRainbowKit(currentAdapterUiKitConfig) {
    if (!this.initialized) {
      import_ui_utils24.logger.error(
        this.logSystem,
        "getConfigForRainbowKit called before implementation initialization."
      );
      return null;
    }
    if (currentAdapterUiKitConfig?.kitName !== "rainbowkit") {
      import_ui_utils24.logger.warn(
        this.logSystem,
        "getConfigForRainbowKit called, but kitName is not rainbowkit. Returning null."
      );
      return null;
    }
    import_ui_utils24.logger.info(
      this.logSystem,
      "getConfigForRainbowKit: Kit is RainbowKit. Proceeding to create/get config. CurrentAdapterUiKitConfig:",
      currentAdapterUiKitConfig
    );
    if (this.rainbowKitConfigFn) {
      const rainbowKitWagmiConfig = await this.rainbowKitConfigFn(
        currentAdapterUiKitConfig,
        this.supportedChains,
        this.chainIdToNetworkId,
        this.getRpcOverrideForRainbowKit.bind(this)
      );
      if (rainbowKitWagmiConfig) {
        import_ui_utils24.logger.info(this.logSystem, "Returning RainbowKit-specific Wagmi config for provider.");
        return rainbowKitWagmiConfig;
      }
    }
    import_ui_utils24.logger.warn(this.logSystem, "RainbowKit specific Wagmi config creation failed.");
    return null;
  }
  /**
   * Determines and returns the WagmiConfig to be used by UiKitManager during its configuration process.
   * If RainbowKit is specified in the passed uiKitConfig, it attempts to get its specific config.
   * Otherwise, it falls back to creating/returning a default instance config.
   *
   * @param uiKitConfig - The fully resolved UiKitConfiguration that the manager is currently processing.
   * @returns A Promise resolving to the determined Wagmi Config object.
   */
  async getActiveConfigForManager(uiKitConfig2) {
    if (!this.initialized) {
      import_ui_utils24.logger.error(
        this.logSystem,
        "getActiveConfigForManager called before initialization! Creating fallback."
      );
      return (0, import_core.createConfig)({
        chains: [this.supportedChains[0]],
        transports: { [this.supportedChains[0].id]: (0, import_viem9.http)() }
      });
    }
    if (uiKitConfig2?.kitName === "rainbowkit") {
      const rkConfig = await this.getConfigForRainbowKit(uiKitConfig2);
      if (rkConfig) return rkConfig;
      import_ui_utils24.logger.warn(
        this.logSystem,
        "getActiveConfigForManager: RainbowKit config failed, falling back to default."
      );
    }
    if (!this.defaultInstanceConfig) {
      this.defaultInstanceConfig = this.createDefaultConfig();
    }
    return this.defaultInstanceConfig;
  }
  /**
   * @deprecated Prefer using methods that rely on the externally set `activeWagmiConfig`
   * or methods that determine contextually appropriate config like `getActiveConfigForManager` (for manager use)
   * or ensure `activeWagmiConfig` is set before calling wagmi actions.
   * This method returns the internally cached default config or the active one if set.
   *
   * @returns The current default or active Wagmi Config object.
   */
  getConfig() {
    import_ui_utils24.logger.warn(
      this.logSystem,
      "getConfig() is deprecated. Internal calls should use activeWagmiConfig if set, or ensure default is created."
    );
    if (this.activeWagmiConfig) return this.activeWagmiConfig;
    if (!this.defaultInstanceConfig) {
      this.defaultInstanceConfig = this.createDefaultConfig();
    }
    return this.defaultInstanceConfig;
  }
  /**
   * Gets the current wallet connection status (isConnected, address, chainId, etc.).
   * This is a synchronous operation and uses the `activeWagmiConfig` if set by `UiKitManager`,
   * otherwise falls back to the default instance config (created on demand).
   *
   * @returns The current account status from Wagmi.
   */
  getWalletConnectionStatus() {
    import_ui_utils24.logger.debug(this.logSystem, "getWalletConnectionStatus called.");
    const configToUse = this.activeWagmiConfig || this.defaultInstanceConfig || (this.defaultInstanceConfig = this.createDefaultConfig());
    if (!configToUse) {
      import_ui_utils24.logger.error(this.logSystem, "No config available for getWalletConnectionStatus!");
      return {
        isConnected: false,
        isConnecting: false,
        isDisconnected: true,
        isReconnecting: false,
        status: "disconnected",
        address: void 0,
        addresses: void 0,
        chainId: void 0,
        chain: void 0,
        connector: void 0
      };
    }
    return (0, import_core.getAccount)(configToUse);
  }
  /**
   * Subscribes to account and connection status changes from Wagmi.
   * The subscription is bound to the `activeWagmiConfig` if available at the time of call,
   * otherwise to the default instance config.
   *
   * @param callback - Function to call when connection status changes.
   * @returns A function to unsubscribe from the changes.
   */
  onWalletConnectionChange(callback) {
    if (!this.initialized) {
      import_ui_utils24.logger.warn(this.logSystem, "onWalletConnectionChange called before initialization. No-op.");
      return () => {
      };
    }
    if (this.unsubscribe) {
      this.unsubscribe();
      import_ui_utils24.logger.debug(this.logSystem, "Previous watchAccount unsubscribed.");
    }
    const configToUse = this.activeWagmiConfig || this.defaultInstanceConfig || (this.defaultInstanceConfig = this.createDefaultConfig());
    if (!configToUse) {
      import_ui_utils24.logger.error(
        this.logSystem,
        "No config available for onWalletConnectionChange! Subscription not set."
      );
      return () => {
      };
    }
    this.unsubscribe = (0, import_core.watchAccount)(configToUse, { onChange: callback });
    import_ui_utils24.logger.info(
      this.logSystem,
      "watchAccount subscription established/re-established using config:",
      configToUse === this.activeWagmiConfig ? "activeExternal" : "defaultInstance"
    );
    return this.unsubscribe;
  }
  /**
   * Gets the Viem Wallet Client for the currently connected account and chain.
   *
   * @returns A Promise resolving to the Viem WalletClient or null if not connected.
   */
  async getWalletClient() {
    if (!this.initialized || !this.activeWagmiConfig) {
      import_ui_utils24.logger.warn(
        this.logSystem,
        "getWalletClient: Not initialized or no activeWagmiConfig. Returning null."
      );
      return null;
    }
    const accountStatus = (0, import_core.getAccount)(this.activeWagmiConfig);
    if (!accountStatus.isConnected || !accountStatus.chainId || !accountStatus.address) {
      return null;
    }
    return (0, import_core.getWalletClient)(this.activeWagmiConfig, {
      chainId: accountStatus.chainId,
      account: accountStatus.address
    });
  }
  /**
   * Gets the Viem Public Client for the currently connected chain.
   *
   * @returns A Promise resolving to the Viem PublicClient or null.
   */
  async getPublicClient() {
    if (!this.initialized || !this.activeWagmiConfig) {
      import_ui_utils24.logger.warn(
        this.logSystem,
        "getPublicClient: Not initialized or no activeWagmiConfig. Returning null."
      );
      return null;
    }
    const accountStatus = (0, import_core.getAccount)(this.activeWagmiConfig);
    const currentChainId = accountStatus.chainId;
    if (!currentChainId) {
      import_ui_utils24.logger.warn(
        this.logSystem,
        "getPublicClient: No connected chainId available from accountStatus. Returning null."
      );
      return null;
    }
    try {
      const publicClient = (0, import_core.getPublicClient)(this.activeWagmiConfig, {
        chainId: currentChainId
      });
      if (publicClient) {
        import_ui_utils24.logger.info(
          this.logSystem,
          `getPublicClient: Successfully retrieved public client for chainId ${currentChainId}.`
        );
        return publicClient;
      }
      import_ui_utils24.logger.warn(
        this.logSystem,
        `getPublicClient: getWagmiCorePublicClient returned undefined/null for chainId ${currentChainId}.`
      );
      return null;
    } catch (error) {
      import_ui_utils24.logger.error(this.logSystem, "Error getting public client from wagmi/core:", error);
      return null;
    }
  }
  /**
   * Gets the list of available wallet connectors from the active Wagmi config.
   *
   * @returns A Promise resolving to an array of available connectors.
   */
  async getAvailableConnectors() {
    if (!this.initialized || !this.activeWagmiConfig) return [];
    return this.activeWagmiConfig.connectors.map((co) => ({ id: co.uid, name: co.name }));
  }
  /**
   * Initiates the connection process for a specific connector.
   *
   * @param connectorId - The ID of the connector to use.
   * @returns A Promise with connection result including address and chainId if successful.
   */
  async connect(connectorId) {
    if (!this.initialized || !this.activeWagmiConfig) {
      throw new Error("Wallet not initialized or no active config");
    }
    const connectorToUse = this.activeWagmiConfig.connectors.find(
      (cn52) => cn52.id === connectorId || cn52.uid === connectorId
    );
    if (!connectorToUse) {
      throw new Error(`Connector ${connectorId} not found`);
    }
    const res = await (0, import_core.connect)(this.activeWagmiConfig, { connector: connectorToUse });
    return { connected: true, address: res.accounts[0], chainId: res.chainId };
  }
  /**
   * Disconnects the currently connected wallet.
   *
   * @returns A Promise with disconnection result.
   */
  async disconnect() {
    if (!this.initialized || !this.activeWagmiConfig) {
      return { disconnected: false, error: "Wallet not initialized or no active config" };
    }
    await (0, import_core.disconnect)(this.activeWagmiConfig);
    return { disconnected: true };
  }
  /**
   * Prompts the user to switch to the specified network.
   *
   * @param chainId - The target chain ID to switch to.
   * @returns A Promise that resolves if the switch is successful, or rejects with an error.
   */
  async switchNetwork(chainId) {
    if (!this.initialized || !this.activeWagmiConfig) {
      throw new Error("Wallet not initialized or no active config");
    }
    await (0, import_core.switchChain)(this.activeWagmiConfig, { chainId });
  }
};
var DEFAULT_OPTIONS = {
  defaultAppName: "My RainbowKit App",
  headerComment: `// RainbowKit configuration for your exported application
// This file is used ONLY in the exported app, not in the builder app preview`
};
function generateRainbowKitConfigFile(userConfig, options = {}) {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const config = userConfig || {};
  const appName = config.appName || opts.defaultAppName;
  const learnMoreUrl = config.learnMoreUrl || "https://openzeppelin.com";
  const projectId = config.projectId || "YOUR_PROJECT_ID";
  const appInfoLines = [`appName: '${appName}'`];
  if (learnMoreUrl) {
    appInfoLines.push(`learnMoreUrl: '${learnMoreUrl}'`);
  }
  const appInfoContent = appInfoLines.join(",\n      ");
  const fileContent = `${opts.headerComment}

// Uncomment imports as needed:
// import { darkTheme, lightTheme } from '@rainbow-me/rainbowkit';

const rainbowKitAppConfig = {
  wagmiParams: {
    appName: '${appName}',
    projectId: '${projectId}', // Get yours at https://cloud.walletconnect.com
    
    // Additional options:
    // ssr: true,
    // wallets: [...],
  },
  providerProps: {
    appInfo: {
      ${appInfoContent}
    },
    
    // UI customization - all features work in exported apps:
    // theme: darkTheme(),
    // modalSize: 'compact',
    // showRecentTransactions: true,
    // coolMode: true,
  },
};

export default rainbowKitAppConfig;`;
  return fileContent;
}
function generateRainbowKitExportables(uiKitConfig2, options = {}) {
  const filePath = "src/config/wallet/rainbowkit.config.ts";
  const content = uiKitConfig2.customCode || generateRainbowKitConfigFile(uiKitConfig2.kitConfig, options);
  return { [filePath]: content };
}
function isRainbowKitCustomizations(obj) {
  return typeof obj === "object" && obj !== null && "connectButton" in obj;
}
function extractRainbowKitCustomizations(kitConfig) {
  if (!kitConfig || !kitConfig.customizations) {
    return void 0;
  }
  const customizations = kitConfig.customizations;
  return isRainbowKitCustomizations(customizations) ? customizations : void 0;
}
function validateRainbowKitConfig(kitConfig) {
  import_ui_utils25.logger.debug(
    "validateRainbowKitConfig",
    "Received kitConfig for validation:",
    JSON.stringify(kitConfig)
  );
  if (!kitConfig) {
    import_ui_utils25.logger.warn("validateRainbowKitConfig", "Validation failed: No kitConfig provided.");
    return { isValid: false, error: "No kitConfig provided for RainbowKit" };
  }
  const wagmiParamsFromKitConfig = kitConfig.wagmiParams;
  if (!wagmiParamsFromKitConfig || typeof wagmiParamsFromKitConfig !== "object" || wagmiParamsFromKitConfig === null) {
    import_ui_utils25.logger.warn(
      "validateRainbowKitConfig",
      "Validation failed: kitConfig.wagmiParams is missing or invalid.",
      { wagmiParamsFromKitConfig }
    );
    return { isValid: false, error: "kitConfig.wagmiParams is missing or not a valid object" };
  }
  const missingFields = [];
  if (!("appName" in wagmiParamsFromKitConfig) || typeof wagmiParamsFromKitConfig.appName !== "string") {
    missingFields.push("wagmiParams.appName");
  }
  if (!("projectId" in wagmiParamsFromKitConfig) || typeof wagmiParamsFromKitConfig.projectId !== "string") {
    missingFields.push("wagmiParams.projectId");
  }
  if (missingFields.length > 0) {
    const errorMsg = `Missing or invalid required fields in wagmiParams: ${missingFields.join(", ")}`;
    import_ui_utils25.logger.warn("validateRainbowKitConfig", "Validation failed:", errorMsg, { missingFields });
    return {
      isValid: false,
      missingFields,
      error: errorMsg
    };
  }
  import_ui_utils25.logger.debug("validateRainbowKitConfig", "Validation successful.");
  return { isValid: true };
}
var MIN_COMPONENT_LOADING_DISPLAY_MS = 1e3;
function createRainbowKitConnectButton(uiKitManager) {
  const RainbowKitConnectButtonComponent = (props) => {
    const [Component, setComponent] = (0, import_react6.useState)(null);
    const [error, setError] = (0, import_react6.useState)(null);
    const [isLoadingComponent, setIsLoadingComponent] = (0, import_react6.useState)(true);
    const [showComponentLoadingOverride, setShowComponentLoadingOverride] = (0, import_react6.useState)(false);
    const componentLoadingTimerRef = (0, import_react6.useRef)(null);
    const [managerState, setManagerState] = (0, import_react6.useState)(uiKitManager.getState());
    const isWagmiProviderReady = (0, import_react6.useContext)(WagmiProviderInitializedContext);
    (0, import_react6.useEffect)(() => {
      const unsubscribe = uiKitManager.subscribe(() => {
        setManagerState(uiKitManager.getState());
      });
      return unsubscribe;
    }, []);
    (0, import_react6.useEffect)(() => {
      let isMounted = true;
      setIsLoadingComponent(true);
      setShowComponentLoadingOverride(true);
      if (componentLoadingTimerRef.current) {
        clearTimeout(componentLoadingTimerRef.current);
      }
      componentLoadingTimerRef.current = setTimeout(() => {
        if (isMounted) {
          setShowComponentLoadingOverride(false);
        }
        componentLoadingTimerRef.current = null;
      }, MIN_COMPONENT_LOADING_DISPLAY_MS);
      const loadComponent = async () => {
        try {
          const rainbowKit = await import("@rainbow-me/rainbowkit");
          if (isMounted) {
            setComponent(() => rainbowKit.ConnectButton);
            setIsLoadingComponent(false);
          }
        } catch (err) {
          if (isMounted) {
            setError(err instanceof Error ? err : new Error(String(err)));
            setIsLoadingComponent(false);
            import_ui_utils26.logger.error(
              "RainbowKitConnectButton",
              "Failed to load RainbowKit ConnectButton:",
              err
            );
          }
        }
      };
      loadComponent();
      return () => {
        isMounted = false;
        if (componentLoadingTimerRef.current) {
          clearTimeout(componentLoadingTimerRef.current);
        }
      };
    }, []);
    const sizeProps = (0, import_ui_utils26.getWalletButtonSizeProps)(props.size);
    const renderLoadingPlaceholder = (message) => /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(
      import_ui_components5.Button,
      {
        disabled: true,
        variant: props.variant || "outline",
        size: sizeProps.size,
        className: (0, import_ui_utils26.cn)(sizeProps.className, props.fullWidth && "w-full", props.className),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_lucide_react4.Loader2, { className: (0, import_ui_utils26.cn)(sizeProps.iconSize, "animate-spin mr-1.5") }),
          message
        ]
      }
    );
    if (error) {
      import_ui_utils26.logger.warn(
        "RainbowKitConnectButton",
        "Error loading RainbowKit ConnectButton. Displaying fallback CustomConnectButton."
      );
      return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CustomConnectButton, { ...props });
    }
    if (isLoadingComponent || showComponentLoadingOverride) {
      return renderLoadingPlaceholder("Loading Wallet...");
    }
    if (!isWagmiProviderReady) {
      return renderLoadingPlaceholder("Initializing Provider...");
    }
    if (!Component) {
      import_ui_utils26.logger.warn(
        "RainbowKitConnectButton",
        "Component is null after loading phase, falling back."
      );
      return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(CustomConnectButton, { ...props });
    }
    const kitConfig = managerState.currentFullUiKitConfig?.kitConfig;
    const customizations = extractRainbowKitCustomizations(kitConfig);
    const connectButtonConfig = customizations?.connectButton;
    const finalProps = {
      ...connectButtonConfig,
      // Apply custom configuration from config
      ...props
      // Allow props to override configuration
    };
    import_ui_utils26.logger.debug("RainbowKitConnectButton", "Rendering with configuration:", {
      configFromFile: connectButtonConfig,
      finalProps
    });
    return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Component, { ...finalProps });
  };
  RainbowKitConnectButtonComponent.displayName = "RainbowKitConnectButton";
  return RainbowKitConnectButtonComponent;
}
function createRainbowKitComponents(RainbowKitConnectButton2) {
  return {
    ConnectButton: RainbowKitConnectButton2
    // RainbowKit's ConnectButton is comprehensive and typically includes account display
    // So we don't provide separate AccountDisplay or NetworkSwitcher components
  };
}
var LOG_PREFIX = "rainbowkit/config-service";
async function createRainbowKitWagmiConfig(userFullNativeConfig, chains, chainIdToNetworkIdMap, getRpcEndpointOverride) {
  try {
    const { getDefaultConfig } = await import("@rainbow-me/rainbowkit");
    if (!getDefaultConfig) {
      import_ui_utils27.logger.error(LOG_PREFIX, "Failed to import getDefaultConfig from RainbowKit");
      return null;
    }
    const wagmiParams = userFullNativeConfig?.wagmiParams;
    if (!wagmiParams) {
      import_ui_utils27.logger.warn(
        LOG_PREFIX,
        "Resolved kitConfig does not contain a `wagmiParams` object. Cannot create RainbowKit Wagmi config."
      );
      return null;
    }
    if (typeof wagmiParams.appName !== "string" || !wagmiParams.appName) {
      import_ui_utils27.logger.warn(LOG_PREFIX, "kitConfig.wagmiParams is missing or has invalid `appName`.");
      return null;
    }
    if (typeof wagmiParams.projectId !== "string" || !wagmiParams.projectId) {
      import_ui_utils27.logger.warn(LOG_PREFIX, "kitConfig.wagmiParams is missing or has invalid `projectId`.");
      return null;
    }
    const transportsConfig = chains.reduce(
      (acc, chainDefinition) => {
        let rpcUrlToUse = chainDefinition.rpcUrls.default?.http?.[0];
        const appNetworkIdString = chainIdToNetworkIdMap[chainDefinition.id];
        if (appNetworkIdString) {
          const rpcOverrideSetting = getRpcEndpointOverride(appNetworkIdString);
          let httpRpcOverride;
          if (typeof rpcOverrideSetting === "string") {
            httpRpcOverride = rpcOverrideSetting;
          } else if (typeof rpcOverrideSetting === "object" && rpcOverrideSetting) {
            if ("http" in rpcOverrideSetting && rpcOverrideSetting.http) {
              httpRpcOverride = rpcOverrideSetting.http;
            } else if ("url" in rpcOverrideSetting && rpcOverrideSetting.url) {
              httpRpcOverride = rpcOverrideSetting.url;
            }
          }
          if (httpRpcOverride) {
            import_ui_utils27.logger.info(
              LOG_PREFIX,
              `Using overridden RPC for chain ${chainDefinition.name}: ${httpRpcOverride}`
            );
            rpcUrlToUse = httpRpcOverride;
          }
        }
        acc[chainDefinition.id] = (0, import_core2.http)(rpcUrlToUse);
        return acc;
      },
      {}
    );
    const finalConfigOptions = {
      ...wagmiParams,
      // User's native params (appName, projectId, wallets, ssr, etc.)
      chains,
      // Adapter controls this
      transports: transportsConfig
      // Adapter controls this
    };
    const config = getDefaultConfig(finalConfigOptions);
    import_ui_utils27.logger.info(LOG_PREFIX, "Successfully created RainbowKit Wagmi config object.", config);
    return config;
  } catch (error) {
    import_ui_utils27.logger.error(LOG_PREFIX, "Error creating RainbowKit Wagmi config:", error);
    return null;
  }
}
async function getWagmiConfigForRainbowKit(uiKitConfiguration, chains, chainIdToNetworkIdMap, getRpcEndpointOverride) {
  if (!uiKitConfiguration || uiKitConfiguration.kitName !== "rainbowkit" || !uiKitConfiguration.kitConfig) {
    import_ui_utils27.logger.debug(
      LOG_PREFIX,
      "Not configured for RainbowKit or kitConfig (resolved native + programmatic) is missing."
    );
    return null;
  }
  const resolvedKitConfig = uiKitConfiguration.kitConfig;
  return createRainbowKitWagmiConfig(
    resolvedKitConfig,
    // Pass the resolved kitConfig
    chains,
    chainIdToNetworkIdMap,
    getRpcEndpointOverride
  );
}
function createUiKitManager(deps) {
  const { getWalletImplementation, loadRainbowKitAssets, logPrefix } = deps;
  const initialState = {
    currentFullUiKitConfig: null,
    wagmiConfig: null,
    kitProviderComponent: null,
    isKitAssetsLoaded: false,
    isInitializing: false,
    error: null
  };
  let state = { ...initialState };
  const listeners = /* @__PURE__ */ new Set();
  function notifyListeners() {
    listeners.forEach((listener) => {
      try {
        listener();
      } catch (error) {
        import_ui_utils28.logger.error(logPrefix, "Error in listener:", error);
      }
    });
  }
  function subscribe(listener) {
    listeners.add(listener);
    return () => {
      listeners.delete(listener);
    };
  }
  function getState() {
    return { ...state };
  }
  async function configure(newFullUiKitConfig) {
    import_ui_utils28.logger.info(`${logPrefix}:configure`, "Configuring UI kit. New config:", newFullUiKitConfig);
    const oldKitName = state.currentFullUiKitConfig?.kitName;
    const newKitName = newFullUiKitConfig.kitName;
    const kitChanged = oldKitName !== newKitName;
    state = {
      ...state,
      isInitializing: true,
      error: null,
      currentFullUiKitConfig: newFullUiKitConfig,
      kitProviderComponent: kitChanged ? null : state.kitProviderComponent,
      isKitAssetsLoaded: kitChanged ? false : state.isKitAssetsLoaded
    };
    notifyListeners();
    let newWagmiConfigAttempt = null;
    const walletImpl = await Promise.resolve(getWalletImplementation());
    try {
      if (newKitName === "rainbowkit") {
        if (kitChanged || !state.kitProviderComponent || !state.isKitAssetsLoaded) {
          import_ui_utils28.logger.info(`${logPrefix}:configure`, "Ensuring RainbowKit assets are loaded...");
          const rkAssets = await loadRainbowKitAssets();
          state.kitProviderComponent = rkAssets.ProviderComponent;
          state.isKitAssetsLoaded = rkAssets.cssLoaded && !!rkAssets.ProviderComponent;
          if (!state.isKitAssetsLoaded) {
            throw new Error("Failed to load critical RainbowKit assets.");
          }
        }
        newWagmiConfigAttempt = await walletImpl.getConfigForRainbowKit(newFullUiKitConfig);
        import_ui_utils28.logger.info(`${logPrefix}:configure`, "WagmiConfig for RainbowKit obtained.");
      } else if (newKitName === "custom" || !newKitName) {
        newWagmiConfigAttempt = await walletImpl.getActiveConfigForManager(newFullUiKitConfig);
        import_ui_utils28.logger.info(`${logPrefix}:configure`, "ActiveConfig for custom/default obtained.");
        if (kitChanged) {
          state.kitProviderComponent = null;
          state.isKitAssetsLoaded = false;
        }
      } else {
        import_ui_utils28.logger.warn(`${logPrefix}:configure`, `Unsupported kitName: ${newKitName}.`);
        state.kitProviderComponent = null;
        state.isKitAssetsLoaded = false;
      }
      state.wagmiConfig = newWagmiConfigAttempt;
      walletImpl.setActiveWagmiConfig(state.wagmiConfig);
      state.error = null;
      if (!newWagmiConfigAttempt && newKitName && newKitName !== "none" && newKitName !== "custom") {
        state.error = new Error(`Failed to obtain WagmiConfig for ${newKitName}`);
        import_ui_utils28.logger.error(`${logPrefix}:configure`, state.error.message);
      }
    } catch (err) {
      import_ui_utils28.logger.error(`${logPrefix}:configure`, "Error during UI kit configuration process:", err);
      state.error = err instanceof Error ? err : new Error(String(err));
      state.wagmiConfig = null;
      walletImpl.setActiveWagmiConfig(null);
    } finally {
      state.isInitializing = false;
      import_ui_utils28.logger.info(
        `${logPrefix}:configure`,
        "Configuration attempt finished. Final wagmiConfig:",
        state.wagmiConfig ? "Set" : "Null",
        "Kit Provider Component:",
        state.kitProviderComponent ? "Set" : "Null",
        "Kit Assets Loaded:",
        state.isKitAssetsLoaded,
        "Error state:",
        state.error ? state.error.message : "None"
      );
      notifyListeners();
    }
  }
  return {
    getState,
    subscribe,
    configure
  };
}
var loadedAssets = null;
var providerPromise = null;
var cssPromise = null;
var LOG_PREFIX2 = "RainbowKitAssetManager";
async function ensureRainbowKitAssetsLoaded() {
  if (loadedAssets) {
    import_ui_utils29.logger.debug(LOG_PREFIX2, "Assets already loaded, returning cached.");
    return loadedAssets;
  }
  if (!providerPromise) {
    providerPromise = import("@rainbow-me/rainbowkit").then((module2) => {
      const component = module2.RainbowKitProvider;
      import_ui_utils29.logger.info(LOG_PREFIX2, "RainbowKitProvider module loaded.");
      return component;
    }).catch((err) => {
      import_ui_utils29.logger.error(LOG_PREFIX2, "Failed to load RainbowKitProvider module:", err);
      return null;
    });
  }
  if (!cssPromise) {
    cssPromise = import("@rainbow-me/rainbowkit/styles.css").then(() => {
      import_ui_utils29.logger.info(LOG_PREFIX2, "RainbowKit CSS loaded successfully.");
      return true;
    }).catch((err) => {
      import_ui_utils29.logger.error(LOG_PREFIX2, "Failed to load RainbowKit CSS:", err);
      return false;
    });
  }
  try {
    const [ProviderComponent, cssLoadedSuccess] = await Promise.all([providerPromise, cssPromise]);
    loadedAssets = { ProviderComponent, cssLoaded: cssLoadedSuccess };
    if (!ProviderComponent || !cssLoadedSuccess) {
      import_ui_utils29.logger.warn(LOG_PREFIX2, "One or more RainbowKit assets failed to load.", loadedAssets);
    }
    return loadedAssets;
  } catch (error) {
    import_ui_utils29.logger.error(LOG_PREFIX2, "Error in Promise.all for asset loading:", error);
    loadedAssets = { ProviderComponent: null, cssLoaded: false };
    return loadedAssets;
  }
}
var LOG_PREFIX3 = "ConfigResolutionService";
async function resolveAndInitializeKitConfig(kitName, programmaticKitConfig, loadConfigModule) {
  import_ui_utils30.logger.debug(
    `${LOG_PREFIX3}:resolveAndInitializeKitConfig`,
    `Resolving native config for kit: ${kitName || "none"}`,
    {
      hasProgrammaticKitConfig: !!programmaticKitConfig,
      hasLoadConfigModule: !!loadConfigModule
    }
  );
  let userNativeConfig = null;
  if (kitName && kitName !== "custom" && kitName !== "none" && loadConfigModule) {
    const conventionalConfigPath = `./config/wallet/${kitName}.config.ts`;
    try {
      userNativeConfig = await loadConfigModule(conventionalConfigPath);
    } catch (error) {
      import_ui_utils30.logger.warn(
        `${LOG_PREFIX3}:resolveAndInitializeKitConfig`,
        `Call to load native config for ${kitName} from ${conventionalConfigPath} failed. Error:`,
        error
      );
    }
  }
  if (userNativeConfig && programmaticKitConfig) {
    const mergedConfig = { ...userNativeConfig, ...programmaticKitConfig };
    return mergedConfig;
  } else if (userNativeConfig) {
    return userNativeConfig;
  } else if (programmaticKitConfig) {
    return programmaticKitConfig;
  }
  import_ui_utils30.logger.debug(
    `${LOG_PREFIX3}:resolveAndInitializeKitConfig`,
    `No native or programmatic kitConfig provided for ${kitName || "none"}. Returning null.`
  );
  return null;
}
async function resolveFullUiKitConfiguration(programmaticOverrides, initialAppServiceKitName, currentAppServiceConfig, options) {
  import_ui_utils30.logger.debug(`${LOG_PREFIX3}:resolveFullUiKitConfiguration`, "Starting resolution with:", {
    programmaticOverrides,
    initialAppServiceKitName,
    currentAppServiceConfig,
    hasLoadNativeCallback: !!options?.loadUiKitNativeConfig,
    hasCustomCode: !!programmaticOverrides.customCode
  });
  const effectiveKitName = programmaticOverrides.kitName || initialAppServiceKitName || currentAppServiceConfig.kitName || "custom";
  const resolvedUserNativeAndProgrammaticKitConfig = await resolveAndInitializeKitConfig(
    effectiveKitName,
    programmaticOverrides.kitConfig,
    options?.loadUiKitNativeConfig
  );
  const finalFullConfig = {
    kitName: effectiveKitName,
    kitConfig: {
      ...currentAppServiceConfig.kitConfig || {},
      ...resolvedUserNativeAndProgrammaticKitConfig || {}
      // customCode is NOT applied to runtime config
    },
    // Pass through customCode for export purposes only
    customCode: programmaticOverrides.customCode
  };
  import_ui_utils30.logger.debug(
    `${LOG_PREFIX3}:resolveFullUiKitConfiguration`,
    "Resolved finalFullConfig:",
    finalFullConfig
  );
  return finalFullConfig;
}
function filterWalletComponents(allPossibleComponents, exclusions, kitName = "custom") {
  import_ui_utils31.logger.debug(
    "filterWalletComponents",
    `Filtering components for kit: ${kitName}. Exclusions: ${exclusions.join(", ")}.`
  );
  if (!allPossibleComponents || Object.keys(allPossibleComponents).length === 0) {
    import_ui_utils31.logger.debug("filterWalletComponents", `No components provided to filter for kit: ${kitName}.`);
    return void 0;
  }
  if (exclusions.length === 0) {
    import_ui_utils31.logger.debug(
      "filterWalletComponents",
      `Providing all components for kit: ${kitName}.`,
      allPossibleComponents
    );
    return allPossibleComponents;
  }
  const filteredComponents = {};
  let componentCount = 0;
  for (const key in allPossibleComponents) {
    const componentKey = key;
    if (!exclusions.includes(componentKey)) {
      if (allPossibleComponents[componentKey]) {
        filteredComponents[componentKey] = allPossibleComponents[componentKey];
        componentCount++;
      }
    }
  }
  if (componentCount > 0) {
    import_ui_utils31.logger.debug(
      "filterWalletComponents",
      `Providing filtered components for kit: ${kitName} after exclusions (${exclusions.join(", ")}).`,
      filteredComponents
    );
    return filteredComponents;
  }
  import_ui_utils31.logger.debug("filterWalletComponents", `All components were excluded for kit: ${kitName}.`);
  return void 0;
}
function getComponentExclusionsFromConfig(kitConfig) {
  if (kitConfig && typeof kitConfig === "object" && "components" in kitConfig) {
    const componentsCfg = kitConfig.components;
    if (componentsCfg && typeof componentsCfg === "object" && "exclude" in componentsCfg && Array.isArray(componentsCfg.exclude)) {
      return componentsCfg.exclude.filter(
        (key) => typeof key === "string" && import_ui_types.ECOSYSTEM_WALLET_COMPONENT_KEYS.includes(key)
      );
    }
  }
  return [];
}
init_eoa();
async function validateRelayerConfig(config) {
  if (!config.serviceUrl) {
    return "Relayer execution selected, but no service URL was provided.";
  }
  if (!config.relayer?.relayerId) {
    return "Relayer execution selected, but no relayer was chosen from the list.";
  }
  return true;
}
init_eoa();
var SYSTEM_LOG_TAG4 = "evm-execution-config";
async function validateEvmExecutionConfig(config, walletStatus) {
  import_ui_utils32.logger.info(SYSTEM_LOG_TAG4, "Validating EVM execution config:", { config, walletStatus });
  switch (config.method) {
    case "eoa":
      return validateEoaConfig(config, walletStatus);
    case "relayer":
      return validateRelayerConfig(config);
    case "multisig":
      return "Multisig execution is not yet supported";
    default: {
      const unknownMethod = config.method;
      import_ui_utils32.logger.warn(SYSTEM_LOG_TAG4, `Unsupported execution method type: ${unknownMethod}`);
      return `Unsupported execution method: ${unknownMethod}`;
    }
  }
}
init_validation();
init_utils();

// src/adapter.ts
var import_ui_utils42 = require("@openzeppelin/ui-utils");

// src/wallet/components/EvmWalletUiRoot.tsx
var import_react_query = require("@tanstack/react-query");
var import_core3 = require("@wagmi/core");
var import_chains3 = require("viem/chains");
var import_wagmi = require("wagmi");
var import_react9 = require("react");
var import_ui_utils34 = require("@openzeppelin/ui-utils");

// src/wallet/utils/walletImplementationManager.ts
var import_ui_utils33 = require("@openzeppelin/ui-utils");

// src/networks/mainnet.ts
var import_react7 = require("@web3icons/react");
var import_chains = require("viem/chains");
var ethereumMainnet = {
  id: "ethereum-mainnet",
  exportConstName: "ethereumMainnet",
  name: "Ethereum",
  ecosystem: "evm",
  network: "ethereum",
  type: "mainnet",
  isTestnet: false,
  chainId: 1,
  rpcUrl: import_chains.mainnet.rpcUrls.default.http[0],
  explorerUrl: "https://etherscan.io",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: import_react7.NetworkEthereum,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: import_chains.mainnet
};
var arbitrumMainnet = {
  id: "arbitrum-mainnet",
  exportConstName: "arbitrumMainnet",
  name: "Arbitrum One",
  ecosystem: "evm",
  network: "arbitrum",
  type: "mainnet",
  isTestnet: false,
  chainId: 42161,
  rpcUrl: import_chains.arbitrum.rpcUrls.default.http[0],
  explorerUrl: "https://arbiscan.io",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: import_react7.NetworkArbitrumOne,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: import_chains.arbitrum
};
var polygonMainnet = {
  id: "polygon-mainnet",
  exportConstName: "polygonMainnet",
  name: "Polygon",
  ecosystem: "evm",
  network: "polygon",
  type: "mainnet",
  isTestnet: false,
  chainId: 137,
  rpcUrl: import_chains.polygon.rpcUrls.default.http[0],
  explorerUrl: "https://polygonscan.com",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: import_react7.NetworkPolygon,
  nativeCurrency: {
    name: "MATIC",
    symbol: "MATIC",
    decimals: 18
  },
  viemChain: import_chains.polygon
};
var polygonZkEvmMainnet = {
  id: "polygon-zkevm-mainnet",
  exportConstName: "polygonZkEvmMainnet",
  name: "Polygon zkEVM",
  ecosystem: "evm",
  network: "polygon-zkevm",
  type: "mainnet",
  isTestnet: false,
  chainId: 1101,
  rpcUrl: import_chains.polygonZkEvm.rpcUrls.default.http[0],
  explorerUrl: "https://zkevm.polygonscan.com",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: import_react7.NetworkPolygon,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: import_chains.polygonZkEvm
};
var baseMainnet = {
  id: "base-mainnet",
  exportConstName: "baseMainnet",
  name: "Base",
  ecosystem: "evm",
  network: "base",
  type: "mainnet",
  isTestnet: false,
  chainId: 8453,
  rpcUrl: import_chains.base.rpcUrls.default.http[0],
  explorerUrl: "https://basescan.org",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: import_react7.NetworkBase,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: import_chains.base
};
var bscMainnet = {
  id: "bsc-mainnet",
  exportConstName: "bscMainnet",
  name: "BNB Smart Chain",
  ecosystem: "evm",
  network: "bsc",
  type: "mainnet",
  isTestnet: false,
  chainId: 56,
  rpcUrl: import_chains.bsc.rpcUrls.default.http[0],
  explorerUrl: "https://bscscan.com",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: import_react7.NetworkBinanceSmartChain,
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  viemChain: import_chains.bsc
};
var optimismMainnet = {
  id: "optimism-mainnet",
  exportConstName: "optimismMainnet",
  name: "OP Mainnet",
  ecosystem: "evm",
  network: "optimism",
  type: "mainnet",
  isTestnet: false,
  chainId: 10,
  rpcUrl: import_chains.optimism.rpcUrls.default.http[0],
  explorerUrl: "https://optimistic.etherscan.io",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: import_react7.NetworkOptimism,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: import_chains.optimism
};
var avalancheMainnet = {
  id: "avalanche-mainnet",
  exportConstName: "avalancheMainnet",
  name: "Avalanche C-Chain",
  ecosystem: "evm",
  network: "avalanche",
  type: "mainnet",
  isTestnet: false,
  chainId: 43114,
  rpcUrl: import_chains.avalanche.rpcUrls.default.http[0],
  explorerUrl: "https://snowscan.xyz",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: import_react7.NetworkAvalanche,
  nativeCurrency: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18
  },
  viemChain: import_chains.avalanche
};
var zkSyncEraMainnet = {
  id: "zksync-era-mainnet",
  exportConstName: "zkSyncEraMainnet",
  name: "ZkSync Era",
  ecosystem: "evm",
  network: "zksync-era",
  type: "mainnet",
  isTestnet: false,
  chainId: 324,
  rpcUrl: import_chains.zksync.rpcUrls.default.http[0],
  explorerUrl: "https://explorer.zksync.io",
  apiUrl: "https://block-explorer-api.mainnet.zksync.io/api",
  primaryExplorerApiIdentifier: "zksync-era-mainnet",
  supportsEtherscanV2: false,
  iconComponent: import_react7.NetworkZksync,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: import_chains.zksync
};
var scrollMainnet = {
  id: "scroll-mainnet",
  exportConstName: "scrollMainnet",
  name: "Scroll",
  ecosystem: "evm",
  network: "scroll",
  type: "mainnet",
  isTestnet: false,
  chainId: 534352,
  rpcUrl: import_chains.scroll.rpcUrls.default.http[0],
  explorerUrl: "https://scrollscan.com",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: import_react7.NetworkScroll,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: import_chains.scroll
};
var lineaMainnet = {
  id: "linea-mainnet",
  exportConstName: "lineaMainnet",
  name: "Linea",
  ecosystem: "evm",
  network: "linea",
  type: "mainnet",
  isTestnet: false,
  chainId: 59144,
  rpcUrl: import_chains.linea.rpcUrls.default.http[0],
  explorerUrl: "https://lineascan.build",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: import_react7.NetworkLinea,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: import_chains.linea
};

// src/networks/testnet.ts
var import_react8 = require("@web3icons/react");
var import_chains2 = require("viem/chains");
var ethereumSepolia = {
  id: "ethereum-sepolia",
  exportConstName: "ethereumSepolia",
  name: "Sepolia",
  ecosystem: "evm",
  network: "ethereum",
  type: "testnet",
  isTestnet: true,
  chainId: 11155111,
  rpcUrl: import_chains2.sepolia.rpcUrls.default.http[0],
  explorerUrl: "https://sepolia.etherscan.io",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: import_react8.NetworkEthereum,
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: import_chains2.sepolia
};
var arbitrumSepolia = {
  id: "arbitrum-sepolia",
  exportConstName: "arbitrumSepolia",
  name: "Arbitrum Sepolia",
  ecosystem: "evm",
  network: "arbitrum",
  type: "testnet",
  isTestnet: true,
  chainId: 421614,
  rpcUrl: import_chains2.arbitrumSepolia.rpcUrls.default.http[0],
  explorerUrl: "https://sepolia.arbiscan.io",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: import_react8.NetworkArbitrumOne,
  nativeCurrency: {
    name: "Arbitrum Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: import_chains2.arbitrumSepolia
};
var polygonAmoy = {
  id: "polygon-amoy",
  exportConstName: "polygonAmoy",
  name: "Polygon Amoy",
  ecosystem: "evm",
  network: "polygon",
  type: "testnet",
  isTestnet: true,
  chainId: 80002,
  rpcUrl: import_chains2.polygonAmoy.rpcUrls.default.http[0],
  explorerUrl: "https://amoy.polygonscan.com",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: import_react8.NetworkPolygon,
  nativeCurrency: {
    name: "MATIC",
    symbol: "MATIC",
    decimals: 18
  },
  viemChain: import_chains2.polygonAmoy
};
var polygonZkEvmCardona = {
  id: "polygon-zkevm-cardona",
  exportConstName: "polygonZkEvmCardona",
  name: "Polygon zkEVM Cardona",
  ecosystem: "evm",
  network: "polygon-zkevm",
  type: "testnet",
  isTestnet: true,
  chainId: 2442,
  rpcUrl: import_chains2.polygonZkEvmCardona.rpcUrls.default.http[0],
  explorerUrl: "https://cardona-zkevm.polygonscan.com",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: import_react8.NetworkPolygon,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: import_chains2.polygonZkEvmCardona
};
var baseSepolia = {
  id: "base-sepolia",
  exportConstName: "baseSepolia",
  name: "Base Sepolia",
  ecosystem: "evm",
  network: "base",
  type: "testnet",
  isTestnet: true,
  chainId: 84532,
  rpcUrl: import_chains2.baseSepolia.rpcUrls.default.http[0],
  explorerUrl: "https://sepolia.basescan.org",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: import_react8.NetworkBase,
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: import_chains2.baseSepolia
};
var bscTestnet = {
  id: "bsc-testnet",
  exportConstName: "bscTestnet",
  name: "BSC Testnet",
  ecosystem: "evm",
  network: "bsc",
  type: "testnet",
  isTestnet: true,
  chainId: 97,
  rpcUrl: import_chains2.bscTestnet.rpcUrls.default.http[0],
  explorerUrl: "https://testnet.bscscan.com",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: import_react8.NetworkBinanceSmartChain,
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  viemChain: import_chains2.bscTestnet
};
var optimismSepolia = {
  id: "optimism-sepolia",
  exportConstName: "optimismSepolia",
  name: "OP Sepolia",
  ecosystem: "evm",
  network: "optimism",
  type: "testnet",
  isTestnet: true,
  chainId: 11155420,
  rpcUrl: import_chains2.optimismSepolia.rpcUrls.default.http[0],
  explorerUrl: "https://sepolia-optimism.etherscan.io",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: import_react8.NetworkOptimism,
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: import_chains2.optimismSepolia
};
var avalancheFuji = {
  id: "avalanche-fuji",
  exportConstName: "avalancheFuji",
  name: "Avalanche Fuji C-Chain",
  ecosystem: "evm",
  network: "avalanche",
  type: "testnet",
  isTestnet: true,
  chainId: 43113,
  rpcUrl: import_chains2.avalancheFuji.rpcUrls.default.http[0],
  explorerUrl: "https://testnet.snowscan.xyz",
  apiUrl: "https://api.etherscan.io/v2/api",
  // Using Etherscan V2 unified API
  primaryExplorerApiIdentifier: "etherscan-v2",
  // Unified identifier for V2 API
  supportsEtherscanV2: true,
  requiresExplorerApiKey: true,
  iconComponent: import_react8.NetworkAvalanche,
  nativeCurrency: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18
  },
  viemChain: import_chains2.avalancheFuji
};
var zksyncSepoliaTestnet = {
  id: "zksync-era-sepolia",
  exportConstName: "zksyncSepoliaTestnet",
  name: "ZkSync Era Sepolia",
  ecosystem: "evm",
  network: "zksync-era",
  type: "testnet",
  isTestnet: true,
  chainId: 300,
  rpcUrl: import_chains2.zksyncSepoliaTestnet.rpcUrls.default.http[0],
  explorerUrl: "https://sepolia.explorer.zksync.io",
  apiUrl: "https://block-explorer-api.sepolia.zksync.dev/api",
  primaryExplorerApiIdentifier: "zksync-era-sepolia",
  supportsEtherscanV2: false,
  iconComponent: import_react8.NetworkZksync,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: import_chains2.zksyncSepoliaTestnet
};
var scrollSepolia = {
  id: "scroll-sepolia",
  exportConstName: "scrollSepolia",
  name: "Scroll Sepolia",
  ecosystem: "evm",
  network: "scroll",
  type: "testnet",
  isTestnet: true,
  chainId: 534351,
  rpcUrl: import_chains2.scrollSepolia.rpcUrls.default.http[0],
  explorerUrl: "https://sepolia.scrollscan.dev",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: import_react8.NetworkScroll,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: import_chains2.scrollSepolia
};
var lineaSepolia = {
  id: "linea-sepolia",
  exportConstName: "lineaSepolia",
  name: "Linea Sepolia",
  ecosystem: "evm",
  network: "linea",
  type: "testnet",
  isTestnet: true,
  chainId: 59141,
  rpcUrl: import_chains2.lineaSepolia.rpcUrls.default.http[0],
  explorerUrl: "https://sepolia.lineascan.build",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: import_react8.NetworkLinea,
  nativeCurrency: {
    name: "Linea Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: import_chains2.lineaSepolia
};
var monadTestnet = {
  id: "monad-testnet",
  exportConstName: "monadTestnet",
  name: "Monad Testnet",
  ecosystem: "evm",
  network: "monad",
  type: "testnet",
  isTestnet: true,
  chainId: 10143,
  rpcUrl: import_chains2.monadTestnet.rpcUrls.default.http[0],
  explorerUrl: "https://testnet.monadexplorer.com",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: import_react8.NetworkMonad,
  nativeCurrency: {
    name: "Monad",
    symbol: "MON",
    decimals: 18
  },
  viemChain: import_chains2.monadTestnet
};

// src/networks/index.ts
var evmMainnetNetworks = [
  ethereumMainnet,
  arbitrumMainnet,
  baseMainnet,
  polygonMainnet,
  polygonZkEvmMainnet,
  bscMainnet,
  optimismMainnet,
  avalancheMainnet,
  lineaMainnet,
  scrollMainnet,
  zkSyncEraMainnet
  // Other mainnet networks...
];
var evmTestnetNetworks = [
  ethereumSepolia,
  arbitrumSepolia,
  baseSepolia,
  polygonAmoy,
  polygonZkEvmCardona,
  bscTestnet,
  optimismSepolia,
  avalancheFuji,
  lineaSepolia,
  scrollSepolia,
  zksyncSepoliaTestnet,
  monadTestnet
  // Other testnet networks...
];
var evmNetworks = [...evmMainnetNetworks, ...evmTestnetNetworks];

// src/wallet/implementation/wagmi-implementation.ts
var getSupportedChainsFromNetworks2 = () => {
  return evmNetworks.filter((network) => network.viemChain).map((network) => network.viemChain).filter((chain, index, self) => self.findIndex((c) => c.id === chain.id) === index);
};
var defaultSupportedChains = getSupportedChainsFromNetworks2();
function createEvmWalletImplementation(walletConnectProjectId, initialUiKitConfig) {
  const config = {
    chains: defaultSupportedChains,
    networkConfigs: evmNetworks,
    walletConnectProjectId,
    initialUiKitConfig,
    logSystem: "WagmiWalletImplementation"
  };
  const instance = new WagmiWalletImplementation(config);
  instance.setRainbowKitConfigFn(
    async (uiKitConfiguration, chains, chainIdToNetworkIdMap, getRpcOverride) => {
      return getWagmiConfigForRainbowKit(
        uiKitConfiguration,
        chains,
        chainIdToNetworkIdMap,
        getRpcOverride
      );
    }
  );
  return instance;
}

// src/wallet/utils/walletImplementationManager.ts
var walletImplementationInstance;
var walletImplementationPromise;
var LOG_SYSTEM = "EvmWalletImplementationManager";
async function getEvmWalletImplementation() {
  if (walletImplementationInstance) {
    return walletImplementationInstance;
  }
  if (walletImplementationPromise) {
    return walletImplementationPromise;
  }
  walletImplementationPromise = (async () => {
    try {
      import_ui_utils33.logger.info(LOG_SYSTEM, "Initializing WagmiWalletImplementation singleton (async)... ");
      const initialUiKitConfig = import_ui_utils33.appConfigService.getTypedNestedConfig(
        "walletui",
        "config"
      );
      const wcProjectId = import_ui_utils33.appConfigService.getGlobalServiceParam("walletconnect", "projectId");
      const instance = createEvmWalletImplementation(wcProjectId, initialUiKitConfig);
      import_ui_utils33.logger.info(LOG_SYSTEM, "WagmiWalletImplementation singleton created (async).");
      walletImplementationInstance = instance;
      return instance;
    } catch (error) {
      import_ui_utils33.logger.error(LOG_SYSTEM, "Failed to initialize WagmiWalletImplementation (async):", error);
      const fallbackInstance = createEvmWalletImplementation();
      walletImplementationInstance = fallbackInstance;
      return fallbackInstance;
    }
  })();
  return walletImplementationPromise;
}
function getInitializedEvmWalletImplementation() {
  if (!walletImplementationInstance) {
    import_ui_utils33.logger.warn(
      LOG_SYSTEM,
      "getInitializedEvmWalletImplementation called before instance was ready."
    );
  }
  return walletImplementationInstance;
}

// src/wallet/evmUiKitManager.ts
var evmUiKitManager = createUiKitManager({
  getWalletImplementation: getEvmWalletImplementation,
  loadRainbowKitAssets: ensureRainbowKitAssetsLoaded,
  logPrefix: "EvmUiKitManager"
});

// src/wallet/components/EvmWalletUiRoot.tsx
var import_jsx_runtime7 = require("react/jsx-runtime");
var stableQueryClient = new import_react_query.QueryClient();
var minimalDefaultWagmiConfig = (0, import_core3.createConfig)({
  chains: [import_chains3.mainnet],
  // At least one chain is required in wagmi v2.20+
  connectors: [],
  // Empty connectors array
  transports: {
    [import_chains3.mainnet.id]: (0, import_core3.http)()
    // Basic HTTP transport for the default chain
  }
});
var EvmWalletUiRoot = ({ children }) => {
  const [managerState, setManagerState] = (0, import_react9.useState)(
    evmUiKitManager.getState()
  );
  (0, import_react9.useEffect)(() => {
    const handleStateChange = () => {
      setManagerState(evmUiKitManager.getState());
    };
    const unsubscribe = evmUiKitManager.subscribe(handleStateChange);
    handleStateChange();
    return unsubscribe;
  }, []);
  const queryClient = (0, import_react9.useMemo)(() => stableQueryClient, []);
  const {
    wagmiConfig,
    kitProviderComponent,
    isKitAssetsLoaded,
    currentFullUiKitConfig,
    isInitializing,
    error
  } = managerState;
  const configForWagmiProvider = wagmiConfig || minimalDefaultWagmiConfig;
  const isWagmiContextEffectivelyReady = !!wagmiConfig && !error;
  let finalChildren = children;
  if (isWagmiContextEffectivelyReady && currentFullUiKitConfig?.kitName === "rainbowkit" && kitProviderComponent && isKitAssetsLoaded) {
    const DynKitProvider = kitProviderComponent;
    const kitConfig = currentFullUiKitConfig.kitConfig || {};
    const providerProps = kitConfig.providerProps || {};
    import_ui_utils34.logger.info(
      "EvmWalletUiRoot",
      "Wrapping children with dynamically loaded KitProvider (RainbowKit)."
    );
    finalChildren = /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(DynKitProvider, { ...providerProps, children });
  } else if (currentFullUiKitConfig?.kitName === "rainbowkit" && !isWagmiContextEffectivelyReady) {
    import_ui_utils34.logger.info(
      "EvmWalletUiRoot",
      "RainbowKit configured, but context or assets not ready. Button may show its loading/error state."
    );
  }
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(import_wagmi.WagmiProvider, { config: configForWagmiProvider, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(import_react_query.QueryClientProvider, { client: queryClient, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(WagmiProviderInitializedContext.Provider, { value: isWagmiContextEffectivelyReady, children: [
    finalChildren,
    isInitializing && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      "div",
      {
        style: {
          position: "fixed",
          top: "10px",
          right: "10px",
          background: "rgba(0,0,0,0.1)",
          padding: "5px",
          borderRadius: "3px",
          fontSize: "0.8em"
        },
        children: "Updating network..."
      }
    ),
    error && !wagmiConfig && /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(
      "div",
      {
        style: {
          position: "fixed",
          bottom: "10px",
          left: "10px",
          background: "red",
          color: "white",
          padding: "10px"
        },
        children: [
          "Error initializing wallet provider: ",
          error.message
        ]
      }
    )
  ] }) }) });
};

// src/wallet/hooks/facade-hooks.ts
var import_wagmi2 = require("wagmi");
var evmFacadeHooks = {
  useAccount: import_wagmi2.useAccount,
  useConnect: import_wagmi2.useConnect,
  useDisconnect: import_wagmi2.useDisconnect,
  useSwitchChain: import_wagmi2.useSwitchChain,
  useChainId: import_wagmi2.useChainId,
  useChains: import_wagmi2.useChains,
  useBalance: import_wagmi2.useBalance,
  useSendTransaction: import_wagmi2.useSendTransaction,
  useWaitForTransactionReceipt: import_wagmi2.useWaitForTransactionReceipt,
  useSignMessage: import_wagmi2.useSignMessage,
  useSignTypedData: import_wagmi2.useSignTypedData
};

// src/wallet/hooks/useUiKitConfig.ts
var import_ui_utils35 = require("@openzeppelin/ui-utils");
var defaultConfig = {
  kitName: "custom",
  // Default to using our custom implementation for EVM
  kitConfig: {
    showInjectedConnector: false
    // Default to hiding the injected connector
  }
};
var uiKitConfig = { ...defaultConfig };
function loadInitialConfigFromAppService() {
  import_ui_utils35.logger.debug("useUiKitConfig", "Attempting to load initial config from AppConfigService...");
  const configObj = import_ui_utils35.appConfigService.getWalletUIConfig("evm");
  if (configObj && configObj.kitName) {
    import_ui_utils35.logger.info(
      "useUiKitConfig",
      `Loaded initial config from AppConfigService: kitName=${configObj.kitName}`,
      configObj.kitConfig
    );
    return {
      kitName: configObj.kitName,
      kitConfig: { ...defaultConfig.kitConfig, ...configObj.kitConfig || {} }
    };
  }
  import_ui_utils35.logger.debug(
    "useUiKitConfig",
    "No initial config found in AppConfigService, using module default."
  );
  return { ...defaultConfig };
}

// src/configuration/execution.ts
var import_ui_utils36 = require("@openzeppelin/ui-utils");
async function getEvmSupportedExecutionMethods() {
  import_ui_utils36.logger.warn(
    "adapter-evm-execution-config",
    "getEvmSupportedExecutionMethods is using placeholder implementation."
  );
  return Promise.resolve([
    {
      type: "eoa",
      name: "EOA (External Account)",
      description: "Execute using a standard wallet address."
    },
    {
      type: "relayer",
      name: "OpenZeppelin Relayer",
      description: "Execute via a OpenZeppelin open source transaction relayer service.",
      disabled: false
    },
    {
      type: "multisig",
      name: "Safe Multisig",
      // Example for future
      description: "Execute via a Safe multisignature wallet.",
      disabled: true
    }
  ]);
}

// src/configuration/network-services.ts
var import_ui_utils37 = require("@openzeppelin/ui-utils");
function getEvmDefaultServiceConfig(networkConfig, serviceId) {
  switch (serviceId) {
    case "rpc":
      if (networkConfig.rpcUrl) {
        return { rpcUrl: networkConfig.rpcUrl };
      }
      break;
    case "explorer": {
      const typedConfig = networkConfig;
      const apiKey = resolveExplorerApiKeyFromAppConfig(typedConfig);
      if (networkConfig.explorerUrl || apiKey) {
        return {
          explorerUrl: networkConfig.explorerUrl,
          apiUrl: networkConfig.apiUrl,
          ...apiKey ? { apiKey } : {}
        };
      }
      break;
    }
    case "contract-definitions":
      return null;
  }
  return null;
}
function getEvmNetworkServiceForms(networkConfig) {
  const globalV2ApiKey = import_ui_utils37.appConfigService.getGlobalServiceConfig("etherscanv2")?.apiKey;
  const v2DefaultEnabled = Boolean(globalV2ApiKey);
  const savedContractDefCfg = import_ui_utils37.userNetworkServiceConfigService.get(
    networkConfig.id,
    "contract-definitions"
  );
  const savedDefaultProvider = savedContractDefCfg && typeof savedContractDefCfg.defaultProvider === "string" ? savedContractDefCfg.defaultProvider : void 0;
  return [
    {
      id: "rpc",
      label: "RPC Provider",
      description: "Setting your own RPC endpoint ensures better reliability, faster response times, and higher rate limits. Public endpoints may be rate-limited or experience congestion during high traffic periods.",
      fields: [
        {
          id: "evm-rpc-url",
          name: "rpcUrl",
          type: "text",
          label: "RPC URL",
          placeholder: "https://mainnet.infura.io/v3/your-key",
          validation: { required: true, pattern: "^https?://.+" },
          width: "full"
        }
      ]
    },
    {
      id: "explorer",
      label: "Block Explorer",
      description: "Public API keys are rate-limited and may be exhausted quickly. Using your own key ensures reliable access to explorer services.",
      fields: [
        // Adapter-led informational notes (rendered generically by the panel)
        {
          id: "evm-explorer-note-etherscan",
          name: "_note_etherscan",
          type: "hidden",
          label: "",
          validation: {},
          isHidden: true,
          metadata: {
            note: {
              variant: "warning",
              title: "Etherscan API Support",
              html: true,
              lines: [
                "<strong>V2 API (Recommended):</strong> Supports all Etherscan-compatible explorers across multiple chains with a single API key.",
                "<strong>V1 API (Legacy):</strong> Requires chain-specific API endpoints. Some explorers may not be supported.",
                "<strong>Note:</strong> Non-Etherscan explorers (Blockscout, Routescan, etc.) are not supported."
              ]
            }
          }
        },
        {
          id: "evm-explorer-api-key",
          name: "apiKey",
          type: "password",
          label: "API Key",
          placeholder: "Your explorer API key",
          helperText: "Required for fetching contract ABIs and other API operations",
          validation: {},
          width: "full"
        },
        {
          id: "evm-explorer-use-v2",
          name: "useV2Api",
          type: "checkbox",
          label: "Use Etherscan V2 API",
          helperText: "Enable the new V2 API for all Etherscan-compatible networks. V2 provides unified access across all chains.",
          validation: {},
          defaultValue: v2DefaultEnabled,
          metadata: {
            section: "api-config",
            sectionLabel: "API Configuration",
            sectionHelp: "Configure API version and network application settings."
          }
        },
        {
          id: "evm-explorer-apply-all",
          name: "applyToAllNetworks",
          type: "checkbox",
          label: "Apply to all compatible networks",
          helperText: "Apply these settings to all Etherscan-compatible networks in your project.",
          validation: {},
          defaultValue: v2DefaultEnabled,
          // UI hinting for generic renderer to indent under and disable when V2 is off
          metadata: {
            section: "api-config",
            nestUnder: "useV2Api",
            disabledWhen: { field: "useV2Api", equals: false }
          }
        },
        {
          id: "evm-explorer-url",
          name: "explorerUrl",
          type: "text",
          label: "Explorer Base URL (optional)",
          placeholder: "https://etherscan.io",
          validation: {},
          helperText: "Base URL for viewing transactions and addresses. If not provided, defaults from the network will be used.",
          width: "full",
          metadata: {
            section: "custom-endpoints",
            sectionLabel: "Custom Endpoints",
            sectionHelp: "Override default URLs for explorer and API endpoints."
          }
        },
        {
          id: "evm-explorer-api-url",
          name: "apiUrl",
          type: "text",
          label: "Explorer API URL (legacy / V1)",
          placeholder: "https://api.etherscan.io/api",
          validation: {},
          helperText: "API endpoint for fetching contract data. If not provided, defaults from the network will be used.",
          width: "full",
          metadata: { section: "custom-endpoints" }
        }
      ]
    },
    {
      id: "contract-definitions",
      label: "Contract Definitions",
      description: void 0,
      supportsConnectionTest: false,
      fields: [
        // Informational note
        {
          id: "evm-contract-def-note",
          name: "_note_contract_def",
          type: "hidden",
          label: "",
          validation: {},
          isHidden: true,
          metadata: {
            hideTestConnection: true,
            note: {
              variant: "info",
              title: "Contract Definition Provider",
              lines: [
                "Select which provider the builder should try first when loading verified contract definitions. Deep links can override this preference temporarily."
              ]
            }
          }
        },
        // Default provider select
        {
          id: "evm-contract-def-provider",
          name: "defaultProvider",
          type: "select",
          label: "Default Contract Definition Provider",
          placeholder: "Select a provider",
          helperText: "Used as the first provider to query for contract definitions.",
          validation: {},
          options: [
            { label: "Etherscan", value: EvmProviderKeys.Etherscan },
            { label: "Sourcify", value: EvmProviderKeys.Sourcify }
          ],
          // Seed from saved user config or app-config default if present; otherwise empty
          defaultValue: savedDefaultProvider || import_ui_utils37.appConfigService.getGlobalServiceParam("contractdefinition", "defaultProvider") || "",
          width: "full"
        },
        // Apply to all networks
        {
          id: "evm-contract-def-apply-all",
          name: "applyToAllNetworks",
          type: "checkbox",
          label: "Apply to all compatible networks",
          helperText: "Apply this default provider setting to all compatible networks in your project.",
          validation: {},
          defaultValue: false,
          metadata: {
            nestUnder: "defaultProvider",
            disabledWhen: { field: "defaultProvider", equals: "" }
          }
        }
      ]
    }
  ];
}

// src/query/adapter-query.ts
var import_ui_utils38 = require("@openzeppelin/ui-utils");
async function queryEvmViewFunction2(contractAddress, functionId, networkConfig, params = [], contractSchema, _walletImplementation, loadContractCallback) {
  let schema = contractSchema;
  if (!schema) {
    if (loadContractCallback) {
      import_ui_utils38.logger.debug("adapter-query", `Loading contract schema for ${contractAddress} via callback`);
      schema = await loadContractCallback(contractAddress);
    } else {
      throw new Error(
        "Contract schema is required for view function query. Provide either a contractSchema or a loadContractCallback."
      );
    }
  }
  const rpcUrl = resolveRpcUrl(networkConfig);
  import_ui_utils38.logger.debug("adapter-query", `Using RPC URL for query: ${rpcUrl}`);
  return queryEvmViewFunction(
    contractAddress,
    functionId,
    params,
    schema,
    rpcUrl,
    networkConfig
  );
}

// src/transaction/components/EvmRelayerOptions.tsx
var import_react11 = __toESM(require("react"), 1);
var import_ui_components9 = require("@openzeppelin/ui-components");

// src/transaction/components/AdvancedInfo.tsx
var import_lucide_react5 = require("lucide-react");
var import_ui_components6 = require("@openzeppelin/ui-components");
var import_jsx_runtime8 = require("react/jsx-runtime");
var AdvancedInfo = ({ showAdvancedInfo, onToggle }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "space-y-2", children: [
    /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("label", { className: "text-base font-medium", children: "Gas Pricing Strategy" }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(import_ui_components6.Button, { variant: "ghost", size: "sm", onClick: onToggle, className: "text-xs", type: "button", children: [
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(import_lucide_react5.Info, { className: "h-3 w-3 mr-1" }),
        "API Requirements"
      ] })
    ] }),
    showAdvancedInfo && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "mt-3 rounded-lg bg-muted/30 p-4", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("p", { className: "text-sm text-muted-foreground leading-relaxed", children: [
      "The OpenZeppelin Relayer API requires exactly one pricing strategy: either a",
      " ",
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("strong", { children: "Speed" }),
      " enum value (FASTEST, FAST, AVERAGE, SAFE_LOW) or",
      " ",
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("strong", { children: "custom gas parameters" }),
      " (gasPrice for legacy, or maxFeePerGas + maxPriorityFeePerGas for EIP-1559)."
    ] }) })
  ] });
};

// src/transaction/components/CustomGasParameters.tsx
var import_lucide_react6 = require("lucide-react");
var import_ui_components7 = require("@openzeppelin/ui-components");
var import_ui_utils39 = require("@openzeppelin/ui-utils");
var import_jsx_runtime9 = require("react/jsx-runtime");
var CustomGasParameters = ({
  control,
  configMode,
  gasType,
  showGasLimit,
  onGasTypeSwitch
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "space-y-4", children: [
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "rounded-lg bg-muted/50 p-4", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("p", { className: "text-sm text-muted-foreground leading-relaxed", children: [
      "Manually configure gas parameters. You must provide either ",
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("strong", { children: "Legacy" }),
      " ",
      "(gasPrice) or ",
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("strong", { children: "EIP-1559" }),
      " (maxFeePerGas + maxPriorityFeePerGas) values."
    ] }) }),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "space-y-3", children: [
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("p", { className: "text-xs text-muted-foreground font-medium uppercase tracking-wider", children: "Select Gas Pricing Method" }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(
        import_ui_components7.Accordion,
        {
          type: "single",
          collapsible: true,
          value: gasType,
          onValueChange: (value) => value && onGasTypeSwitch(value),
          className: "w-full space-y-3",
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(
              import_ui_components7.AccordionItem,
              {
                value: "eip1559",
                className: (0, import_ui_utils39.cn)(
                  "rounded-lg border shadow-sm overflow-hidden transition-all",
                  gasType === "eip1559" ? "border-primary bg-primary/5" : "border-border bg-card hover:border-muted-foreground/50"
                ),
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(import_ui_components7.AccordionTrigger, { className: "px-4 py-3 text-sm font-medium hover:no-underline", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex items-center justify-between w-full", children: [
                    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex items-center gap-3", children: [
                      /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "relative", children: [
                        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
                          import_lucide_react6.Circle,
                          {
                            className: `h-4 w-4 ${gasType === "eip1559" ? "text-primary" : "text-muted-foreground"}`
                          }
                        ),
                        gasType === "eip1559" && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(import_lucide_react6.Circle, { className: "h-4 w-4 absolute inset-0 text-primary fill-primary scale-50" })
                      ] }),
                      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { children: "EIP-1559" })
                    ] }),
                    gasType === "eip1559" && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { className: "text-xs text-primary font-medium mr-2", children: "Selected" })
                  ] }) }),
                  /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(import_ui_components7.AccordionContent, { children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "px-4 pb-4 pt-4 grid gap-4 border-t bg-background/50", children: [
                    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
                      import_ui_components7.NumberField,
                      {
                        id: "maxFeePerGas",
                        label: "Max Fee Per Gas",
                        name: "transactionOptions.maxFeePerGas",
                        control,
                        placeholder: "30",
                        helperText: "Maximum total fee per gas unit you're willing to pay (in gwei)",
                        step: 0.1,
                        min: 0,
                        validation: { required: configMode === "custom" && gasType === "eip1559" }
                      }
                    ),
                    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
                      import_ui_components7.NumberField,
                      {
                        id: "maxPriorityFeePerGas",
                        label: "Max Priority Fee Per Gas",
                        name: "transactionOptions.maxPriorityFeePerGas",
                        control,
                        placeholder: "2",
                        helperText: "Priority fee (tip) to incentivize miners (in gwei)",
                        step: 0.1,
                        min: 0,
                        validation: { required: configMode === "custom" && gasType === "eip1559" }
                      }
                    )
                  ] }) })
                ]
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(
              import_ui_components7.AccordionItem,
              {
                value: "legacy",
                className: (0, import_ui_utils39.cn)(
                  "rounded-lg border shadow-sm overflow-hidden transition-all",
                  gasType === "legacy" ? "border-primary bg-primary/5" : "border-border bg-card hover:border-muted-foreground/50"
                ),
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(import_ui_components7.AccordionTrigger, { className: "px-4 py-3 text-sm font-medium hover:no-underline", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex items-center justify-between w-full", children: [
                    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex items-center gap-3", children: [
                      /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "relative", children: [
                        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
                          import_lucide_react6.Circle,
                          {
                            className: `h-4 w-4 ${gasType === "legacy" ? "text-primary" : "text-muted-foreground"}`
                          }
                        ),
                        gasType === "legacy" && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(import_lucide_react6.Circle, { className: "h-4 w-4 absolute inset-0 text-primary fill-primary scale-50" })
                      ] }),
                      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { children: "Legacy Gas Price" })
                    ] }),
                    gasType === "legacy" && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { className: "text-xs text-primary font-medium mr-2", children: "Selected" })
                  ] }) }),
                  /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(import_ui_components7.AccordionContent, { children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "px-4 pb-4 pt-4 border-t bg-background/50", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
                    import_ui_components7.NumberField,
                    {
                      id: "gasPrice",
                      label: "Gas Price",
                      name: "transactionOptions.gasPrice",
                      control,
                      placeholder: "20",
                      helperText: "Fixed gas price for legacy transactions (in gwei)",
                      step: 0.1,
                      min: 0,
                      validation: { required: configMode === "custom" && gasType === "legacy" }
                    }
                  ) }) })
                ]
              }
            )
          ]
        }
      )
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "space-y-2", children: [
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        import_ui_components7.BooleanField,
        {
          id: "showGasLimit",
          label: "Override gas limit",
          name: "transactionOptions.showGasLimit",
          control,
          helperText: "Enable manual gas limit configuration"
        }
      ),
      showGasLimit && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "pl-6", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        import_ui_components7.NumberField,
        {
          id: "gasLimit",
          label: "Gas Limit",
          name: "transactionOptions.gasLimit",
          control,
          placeholder: "Auto-detected by relayer",
          helperText: "Leave empty to let the relayer estimate. Only override if you need a specific limit.",
          step: 1e3,
          min: 21e3
        }
      ) })
    ] })
  ] });
};

// src/transaction/components/SpeedSelection.tsx
var import_relayer_sdk2 = require("@openzeppelin/relayer-sdk");
var import_ui_components8 = require("@openzeppelin/ui-components");
var import_jsx_runtime10 = require("react/jsx-runtime");
var speedOptions = [
  {
    value: import_relayer_sdk2.Speed.FASTEST,
    label: "Fastest",
    description: "Maximum priority, highest gas prices"
  },
  {
    value: import_relayer_sdk2.Speed.FAST,
    label: "Fast",
    description: "High priority, recommended for most transactions",
    recommended: true
  },
  {
    value: import_relayer_sdk2.Speed.AVERAGE,
    label: "Average",
    description: "Standard priority, balanced cost"
  },
  {
    value: import_relayer_sdk2.Speed.SAFE_LOW,
    label: "Safe Low",
    description: "Lower priority, minimal gas cost"
  }
];
var SpeedSelection = ({ selectedSpeed, onSpeedChange }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
    import_ui_components8.RadioGroup,
    {
      value: selectedSpeed || import_relayer_sdk2.Speed.FAST,
      onValueChange: (value) => onSpeedChange(value),
      children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { className: "space-y-3", children: speedOptions.map((option) => /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(
        "label",
        {
          htmlFor: `speed-${option.value}`,
          className: `relative block rounded-lg border p-4 cursor-pointer transition-colors ${selectedSpeed === option.value ? "border-primary bg-primary/5" : "border-border hover:border-muted-foreground/50"}`,
          children: [
            option.recommended && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("span", { className: "absolute -top-2 right-4 bg-primary text-primary-foreground text-xs px-2 py-0.5 rounded", children: "Recommended" }),
            /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("div", { className: "flex items-start space-x-3", children: [
              /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
                import_ui_components8.RadioGroupItem,
                {
                  value: option.value,
                  id: `speed-${option.value}`,
                  className: "mt-0.5"
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("div", { className: "flex-1", children: [
                /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { className: "font-medium", children: option.label }),
                /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("p", { className: "text-sm text-muted-foreground mt-0.5", children: option.description })
              ] })
            ] })
          ]
        },
        option.value
      )) })
    }
  );
};

// src/transaction/components/useEvmRelayerOptions.ts
var import_react10 = require("react");
var import_react_hook_form = require("react-hook-form");
var import_relayer_sdk3 = require("@openzeppelin/relayer-sdk");
var useEvmRelayerOptions = ({ options, onChange }) => {
  const onChangeRef = (0, import_react10.useRef)(onChange);
  onChangeRef.current = onChange;
  const initialOptions = {
    speed: (() => {
      const hasCustomSettings2 = Boolean(
        options.gasPrice || options.maxFeePerGas || options.maxPriorityFeePerGas
      );
      return options.speed || (!hasCustomSettings2 ? import_relayer_sdk3.Speed.FAST : void 0);
    })(),
    gasPrice: weiToGwei(options.gasPrice),
    maxFeePerGas: weiToGwei(options.maxFeePerGas),
    maxPriorityFeePerGas: weiToGwei(options.maxPriorityFeePerGas),
    gasLimit: options.gasLimit,
    showGasLimit: Boolean(options.gasLimit)
  };
  const { control, setValue, watch } = (0, import_react_hook_form.useForm)({
    defaultValues: {
      transactionOptions: initialOptions
    }
  });
  const formValues = watch("transactionOptions");
  const isInitialMount = (0, import_react10.useRef)(true);
  const hasCustomSettings = Boolean(
    formValues.gasPrice || formValues.maxFeePerGas || formValues.maxPriorityFeePerGas
  );
  const configMode = hasCustomSettings ? "custom" : "speed";
  const isEip1559 = Boolean(formValues.maxFeePerGas || formValues.maxPriorityFeePerGas);
  const gasType = isEip1559 ? "eip1559" : "legacy";
  (0, import_react10.useEffect)(() => {
    if (isInitialMount.current) {
      isInitialMount.current = false;
      if (initialOptions.speed && !options.speed) {
        const newOptions = {};
        if (initialOptions.speed) newOptions.speed = initialOptions.speed;
        if (initialOptions.gasLimit) newOptions.gasLimit = initialOptions.gasLimit;
        onChange(newOptions);
      }
      return;
    }
  }, []);
  (0, import_react10.useEffect)(() => {
    if (isInitialMount.current) {
      return;
    }
    const timeoutId = setTimeout(() => {
      const newOptions = {};
      if (formValues.speed) newOptions.speed = formValues.speed;
      if (formValues.gasPrice) newOptions.gasPrice = gweiToWei(formValues.gasPrice);
      if (formValues.maxFeePerGas) newOptions.maxFeePerGas = gweiToWei(formValues.maxFeePerGas);
      if (formValues.maxPriorityFeePerGas) {
        newOptions.maxPriorityFeePerGas = gweiToWei(formValues.maxPriorityFeePerGas);
      }
      if (formValues.gasLimit) newOptions.gasLimit = formValues.gasLimit;
      onChangeRef.current(newOptions);
    }, 100);
    return () => clearTimeout(timeoutId);
  }, [
    formValues.speed,
    formValues.gasPrice,
    formValues.maxFeePerGas,
    formValues.maxPriorityFeePerGas,
    formValues.gasLimit
  ]);
  const handleSpeedChange = (speed) => {
    setValue("transactionOptions", {
      ...formValues,
      speed,
      gasPrice: void 0,
      maxFeePerGas: void 0,
      maxPriorityFeePerGas: void 0
    });
  };
  const handleModeChange = (mode) => {
    if (mode === "speed") {
      setValue("transactionOptions", {
        ...formValues,
        speed: import_relayer_sdk3.Speed.FAST,
        gasPrice: void 0,
        maxFeePerGas: void 0,
        maxPriorityFeePerGas: void 0
      });
    } else {
      setValue("transactionOptions", {
        ...formValues,
        speed: void 0,
        maxFeePerGas: 30,
        maxPriorityFeePerGas: 2
      });
    }
  };
  const handleGasTypeSwitch = (type) => {
    if (type === "eip1559") {
      setValue("transactionOptions", {
        ...formValues,
        gasPrice: void 0,
        maxFeePerGas: 30,
        maxPriorityFeePerGas: 2
      });
    } else {
      setValue("transactionOptions", {
        ...formValues,
        maxFeePerGas: void 0,
        maxPriorityFeePerGas: void 0,
        gasPrice: 20
      });
    }
  };
  return {
    control,
    formValues,
    configMode,
    gasType,
    handleSpeedChange,
    handleModeChange,
    handleGasTypeSwitch
  };
};

// src/transaction/components/EvmRelayerOptions.tsx
var import_jsx_runtime11 = require("react/jsx-runtime");
var EvmRelayerOptions = ({ options, onChange }) => {
  const [showAdvancedInfo, setShowAdvancedInfo] = import_react11.default.useState(false);
  const {
    control,
    formValues,
    configMode,
    gasType,
    handleSpeedChange,
    handleModeChange,
    handleGasTypeSwitch
  } = useEvmRelayerOptions({ options, onChange });
  return /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { className: "space-y-4", children: [
    /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
      AdvancedInfo,
      {
        showAdvancedInfo,
        onToggle: () => setShowAdvancedInfo(!showAdvancedInfo)
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(import_ui_components9.Tabs, { value: configMode, onValueChange: handleModeChange, children: [
      /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(import_ui_components9.TabsList, { className: "grid w-full grid-cols-2", children: [
        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(import_ui_components9.TabsTrigger, { value: "speed", children: "Speed" }),
        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(import_ui_components9.TabsTrigger, { value: "custom", children: "Custom" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(import_ui_components9.TabsContent, { value: "speed", className: "space-y-4", children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(SpeedSelection, { selectedSpeed: formValues.speed, onSpeedChange: handleSpeedChange }) }),
      /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(import_ui_components9.TabsContent, { value: "custom", className: "space-y-4", children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
        CustomGasParameters,
        {
          control,
          configMode,
          gasType,
          showGasLimit: formValues.showGasLimit || false,
          onGasTypeSwitch: handleGasTypeSwitch
        }
      ) })
    ] })
  ] });
};

// src/wallet/utils/connection.ts
var import_ui_utils40 = require("@openzeppelin/ui-utils");
var LOG_SYSTEM2 = "adapter-evm-connection";
function evmSupportsWalletConnection() {
  return true;
}
async function getEvmAvailableConnectors() {
  const impl = await getEvmWalletImplementation();
  if (!impl) {
    import_ui_utils40.logger.warn(LOG_SYSTEM2, "getEvmAvailableConnectors: Wallet implementation not ready.");
    return [];
  }
  return impl.getAvailableConnectors();
}
async function connectAndEnsureCorrectNetwork(connectorId, targetChainId) {
  const impl = await getEvmWalletImplementation();
  if (!impl) {
    import_ui_utils40.logger.error(LOG_SYSTEM2, "connectAndEnsureCorrectNetwork: Wallet implementation not ready.");
    return { connected: false, error: "Wallet system not initialized." };
  }
  return connectAndEnsureCorrectNetworkCore(impl, connectorId, targetChainId, LOG_SYSTEM2);
}
async function disconnectEvmWallet() {
  const impl = await getEvmWalletImplementation();
  if (!impl) {
    import_ui_utils40.logger.warn(LOG_SYSTEM2, "disconnectEvmWallet: Wallet implementation not ready.");
    return { disconnected: false, error: "Wallet system not initialized." };
  }
  return impl.disconnect();
}
function getEvmWalletConnectionStatus() {
  const impl = getInitializedEvmWalletImplementation();
  if (!impl) {
    import_ui_utils40.logger.warn(
      LOG_SYSTEM2,
      "getEvmWalletConnectionStatus: Wallet implementation not ready. Returning default disconnected state."
    );
    return DEFAULT_DISCONNECTED_STATUS;
  }
  return impl.getWalletConnectionStatus();
}

// src/wallet/utils/uiKitService.ts
var import_ui_utils41 = require("@openzeppelin/ui-utils");

// src/wallet/rainbowkit/components.tsx
var RainbowKitConnectButton = createRainbowKitConnectButton(evmUiKitManager);

// src/wallet/rainbowkit/componentFactory.ts
function createRainbowKitComponents2() {
  return createRainbowKitComponents(RainbowKitConnectButton);
}

// src/wallet/utils/uiKitService.ts
function getResolvedWalletComponents(uiKitConfiguration) {
  import_ui_utils41.logger.debug(
    "uiKitService:getResolvedWalletComponents",
    "Received uiKitConfiguration:",
    JSON.stringify(uiKitConfiguration)
  );
  const currentKitName = uiKitConfiguration.kitName || "custom";
  if (currentKitName === "none") {
    import_ui_utils41.logger.info(
      "uiKitService",
      'UI Kit set to "none" for getResolvedWalletComponents, not providing wallet components.'
    );
    return void 0;
  }
  const exclusions = getComponentExclusionsFromConfig(uiKitConfiguration.kitConfig);
  import_ui_utils41.logger.debug(
    "uiKitService",
    `Extracted component exclusions for ${currentKitName}: ${exclusions.join(", ") || "none"}.`
  );
  if (currentKitName === "custom") {
    const allCustomComponents = {
      ConnectButton: CustomConnectButton,
      AccountDisplay: CustomAccountDisplay,
      NetworkSwitcher: CustomNetworkSwitcher
    };
    return filterWalletComponents(allCustomComponents, exclusions, currentKitName);
  }
  if (currentKitName === "rainbowkit") {
    const validation = validateRainbowKitConfig(uiKitConfiguration.kitConfig);
    if (!validation.isValid) {
      import_ui_utils41.logger.warn(
        "uiKitService",
        `Invalid RainbowKit configuration for components: ${validation.error}. No components provided.`
      );
      return void 0;
    }
    const rainbowKitComponents = createRainbowKitComponents2();
    import_ui_utils41.logger.info("uiKitService", "Providing RainbowKit components.");
    return filterWalletComponents(rainbowKitComponents, exclusions, currentKitName);
  }
  import_ui_utils41.logger.warn(
    "uiKitService",
    `UI Kit "${currentKitName}" for getResolvedWalletComponents not explicitly supported. No components provided.`
  );
  return void 0;
}

// src/wallet/utils/wallet-status.ts
function convertWagmiToEvmStatus(wagmiStatus) {
  return {
    isConnected: wagmiStatus.isConnected,
    isConnecting: wagmiStatus.isConnecting,
    isDisconnected: wagmiStatus.isDisconnected,
    isReconnecting: wagmiStatus.isReconnecting,
    status: wagmiStatus.status,
    address: wagmiStatus.address,
    chainId: wagmiStatus.chainId?.toString(),
    addresses: wagmiStatus.addresses,
    connector: wagmiStatus.connector ? {
      id: wagmiStatus.connector.id,
      name: wagmiStatus.connector.name,
      type: wagmiStatus.connector.type
    } : void 0,
    chain: wagmiStatus.chain ? { ...wagmiStatus.chain } : void 0
  };
}

// src/wallet/utils.ts
function getResolvedWalletComponents2(uiKitConfig2) {
  return getResolvedWalletComponents(uiKitConfig2);
}

// src/adapter.ts
var isTypedEvmNetworkConfig = (config) => config.ecosystem === "evm";
var EvmAdapter = class {
  constructor(networkConfig) {
    __publicField(this, "networkConfig");
    __publicField(this, "initialAppServiceKitName");
    if (!isTypedEvmNetworkConfig(networkConfig)) {
      throw new Error("EvmAdapter requires a valid EVM network configuration.");
    }
    this.networkConfig = networkConfig;
    import_ui_utils42.logger.info(
      "EvmAdapter",
      `Adapter initialized for network: ${networkConfig.name} (ID: ${networkConfig.id})`
    );
    const initialGlobalConfig = loadInitialConfigFromAppService();
    this.initialAppServiceKitName = initialGlobalConfig.kitName || "custom";
    import_ui_utils42.logger.info(
      "EvmAdapter:constructor",
      "Initial kitName from AppConfigService noted:",
      this.initialAppServiceKitName
    );
  }
  /**
   * @inheritdoc
   */
  getNetworkServiceForms() {
    return getEvmNetworkServiceForms(this.networkConfig);
  }
  /**
   * @inheritdoc
   */
  async validateNetworkServiceConfig(serviceId, values) {
    return validateEvmNetworkServiceConfig(serviceId, values);
  }
  /**
   * @inheritdoc
   */
  async testNetworkServiceConnection(serviceId, values) {
    return testEvmNetworkServiceConnection(serviceId, values, this.networkConfig);
  }
  /**
   * @inheritdoc
   */
  getDefaultServiceConfig(serviceId) {
    return getEvmDefaultServiceConfig(this.networkConfig, serviceId);
  }
  /**
   * @inheritdoc
   */
  async loadContract(source) {
    return loadContractSchema(source, this.networkConfig);
  }
  /**
   * @inheritdoc
   */
  async loadContractWithMetadata(source) {
    return loadContractWithFullMetadata(source, this.networkConfig);
  }
  /**
   * @inheritdoc
   */
  mapParameterTypeToFieldType(parameterType) {
    return mapEvmParamTypeToFieldType(parameterType);
  }
  /**
   * @inheritdoc
   */
  getCompatibleFieldTypes(parameterType) {
    return getEvmCompatibleFieldTypes(parameterType);
  }
  /**
   * @inheritdoc
   */
  generateDefaultField(parameter) {
    return generateEvmDefaultField(parameter);
  }
  /**
   * @inheritdoc
   */
  formatTransactionData(contractSchema, functionId, submittedInputs, fields) {
    return formatEvmTransactionData(contractSchema, functionId, submittedInputs, fields);
  }
  /**
   * @inheritdoc
   */
  async signAndBroadcast(transactionData, executionConfig, onStatusChange, runtimeApiKey) {
    const walletImplementation = await getEvmWalletImplementation();
    return executeEvmTransaction(
      transactionData,
      executionConfig,
      walletImplementation,
      onStatusChange,
      runtimeApiKey
    );
  }
  /**
   * @inheritdoc
   */
  async getRelayers(serviceUrl, accessToken) {
    const relayerStrategy = new RelayerExecutionStrategy();
    return relayerStrategy.getEvmRelayers(serviceUrl, accessToken, this.networkConfig);
  }
  /**
   * @inheritdoc
   */
  async getRelayer(serviceUrl, accessToken, relayerId) {
    const relayerStrategy = new RelayerExecutionStrategy();
    return relayerStrategy.getEvmRelayer(serviceUrl, accessToken, relayerId, this.networkConfig);
  }
  /**
   * Returns a React component for configuring EVM-specific relayer transaction options.
   * @returns The EVM relayer options component
   */
  getRelayerOptionsComponent() {
    return EvmRelayerOptions;
  }
  /**
   * @inheritdoc
   */
  getWritableFunctions(contractSchema) {
    return contractSchema.functions.filter((fn) => fn.modifiesState);
  }
  /**
   * @inheritdoc
   */
  isValidAddress(address, _addressType) {
    return isValidEvmAddress(address);
  }
  /**
   * @inheritdoc
   */
  async getSupportedExecutionMethods() {
    return getEvmSupportedExecutionMethods();
  }
  /**
   * @inheritdoc
   */
  async validateExecutionConfig(config) {
    const walletStatus = this.getWalletConnectionStatus();
    return validateEvmExecutionConfig(config, walletStatus);
  }
  /**
   * @inheritdoc
   */
  isViewFunction(functionDetails) {
    return isEvmViewFunction(functionDetails);
  }
  /**
   * @inheritdoc
   */
  filterAutoQueryableFunctions(functions) {
    const skipNames = /* @__PURE__ */ new Set([
      "admin",
      "implementation",
      "getImplementation",
      "_implementation",
      "proxyAdmin",
      "changeAdmin",
      "upgradeTo",
      "upgradeToAndCall"
    ]);
    return functions.filter((f) => !skipNames.has(f.name));
  }
  /**
   * @inheritdoc
   */
  async queryViewFunction(contractAddress, functionId, params = [], contractSchema) {
    const walletImplementation = await getEvmWalletImplementation();
    return queryEvmViewFunction2(
      contractAddress,
      functionId,
      this.networkConfig,
      params,
      contractSchema,
      walletImplementation,
      (src) => this.loadContract({ contractAddress: src })
    );
  }
  /**
   * @inheritdoc
   */
  formatFunctionResult(decodedValue, functionDetails) {
    return formatEvmFunctionResult(decodedValue, functionDetails);
  }
  /**
   * @inheritdoc
   */
  supportsWalletConnection() {
    return evmSupportsWalletConnection();
  }
  /**
   * @inheritdoc
   */
  async getAvailableConnectors() {
    return getEvmAvailableConnectors();
  }
  /**
   * @inheritdoc
   */
  async connectWallet(connectorId) {
    const result = await connectAndEnsureCorrectNetwork(connectorId, this.networkConfig.chainId);
    if (result.connected && result.address) {
      return { connected: true, address: result.address };
    } else {
      return {
        connected: false,
        error: result.error || "Connection failed for an unknown reason."
      };
    }
  }
  /**
   * @inheritdoc
   */
  async disconnectWallet() {
    return disconnectEvmWallet();
  }
  /**
   * @inheritdoc
   */
  getWalletConnectionStatus() {
    const status = getEvmWalletConnectionStatus();
    return convertWagmiToEvmStatus(status);
  }
  /**
   * @inheritdoc
   */
  onWalletConnectionChange(callback) {
    const walletImplementation = getInitializedEvmWalletImplementation();
    if (!walletImplementation) {
      import_ui_utils42.logger.warn(
        "EvmAdapter:onWalletConnectionChange",
        "Wallet implementation not ready. Subscription may not work."
      );
      return () => {
      };
    }
    return walletImplementation.onWalletConnectionChange(
      (currentWagmiStatus, previousWagmiStatus) => {
        const current = convertWagmiToEvmStatus(currentWagmiStatus);
        const previous = convertWagmiToEvmStatus(previousWagmiStatus);
        callback(current, previous);
      }
    );
  }
  /**
   * @inheritdoc
   */
  getExplorerUrl(address) {
    return getEvmExplorerAddressUrl(address, this.networkConfig);
  }
  /**
   * @inheritdoc
   */
  getExplorerTxUrl(txHash) {
    if (getEvmExplorerTxUrl) {
      return getEvmExplorerTxUrl(txHash, this.networkConfig);
    }
    return null;
  }
  /**
   * @inheritdoc
   */
  async getCurrentBlock() {
    return getEvmCurrentBlock(this.networkConfig);
  }
  /**
   * @inheritdoc
   */
  async waitForTransactionConfirmation(txHash) {
    const walletImplementation = await getEvmWalletImplementation();
    return waitForEvmTransactionConfirmation(txHash, walletImplementation);
  }
  /**
   * @inheritdoc
   */
  async configureUiKit(programmaticOverrides = {}, options) {
    const currentAppServiceConfig = loadInitialConfigFromAppService();
    const finalFullConfig = await resolveFullUiKitConfiguration(
      programmaticOverrides,
      this.initialAppServiceKitName,
      currentAppServiceConfig,
      options
    );
    await evmUiKitManager.configure(finalFullConfig);
    import_ui_utils42.logger.info(
      "EvmAdapter:configureUiKit",
      "EvmUiKitManager configuration requested with final config:",
      finalFullConfig
    );
  }
  /**
   * @inheritdoc
   */
  getEcosystemReactUiContextProvider() {
    import_ui_utils42.logger.info("EvmAdapter:getEcosystemReactUiContextProvider", "Returning EvmWalletUiRoot.");
    return EvmWalletUiRoot;
  }
  /**
   * @inheritdoc
   */
  getEcosystemReactHooks() {
    return evmFacadeHooks;
  }
  /**
   * @inheritdoc
   */
  getSupportedContractDefinitionProviders() {
    return [
      { key: EvmProviderKeys.Etherscan, label: "Etherscan" },
      { key: EvmProviderKeys.Sourcify, label: "Sourcify" }
    ];
  }
  /**
   * @inheritdoc
   */
  getEcosystemWalletComponents() {
    const currentManagerState = evmUiKitManager.getState();
    if (!currentManagerState.currentFullUiKitConfig) {
      import_ui_utils42.logger.debug(
        // Changed from warn to debug, as this can be normal during init sequence
        "EvmAdapter:getEcosystemWalletComponents",
        "No UI kit configuration available in manager yet. Returning undefined components."
      );
      return void 0;
    }
    return getResolvedWalletComponents2(currentManagerState.currentFullUiKitConfig);
  }
  async getAvailableUiKits() {
    const rainbowkitDefaultCode = generateRainbowKitConfigFile({});
    return [
      {
        id: "custom",
        name: "Wagmi Custom",
        configFields: []
      },
      {
        id: "rainbowkit",
        name: "RainbowKit",
        linkToDocs: "https://www.rainbowkit.com/docs/installation#configure",
        description: `Configure RainbowKit for your exported application. This code will be saved as <code class="bg-muted px-1 py-0.5 rounded text-xs">rainbowkit.config.ts</code>.<br/><br/>
<strong>Export Only:</strong> This configuration is <em>only used in exported apps</em>. The preview always uses the default RainbowKit configuration.<br/><br/>
<strong>Available options:</strong><br/>
\u2022 <code>wagmiParams</code>: Configure app name, projectId, wallets, etc.<br/>
\u2022 <code>providerProps</code>: Set theme, modal size, and other UI options<br/><br/>
Get your WalletConnect projectId from <a href="https://cloud.walletconnect.com" target="_blank" rel="noopener" class="text-primary underline">cloud.walletconnect.com</a>`,
        hasCodeEditor: true,
        defaultCode: rainbowkitDefaultCode,
        configFields: []
      }
    ];
  }
  async getExportableWalletConfigFiles(uiKitConfig2) {
    if (uiKitConfig2?.kitName === "rainbowkit") {
      return generateRainbowKitExportables(uiKitConfig2);
    }
    return {};
  }
  /**
   * @inheritdoc
   */
  getUiLabels() {
    return {
      relayerConfigTitle: "Gas Configuration",
      relayerConfigActiveDesc: "Customize gas pricing strategy for transaction submission",
      relayerConfigInactiveDesc: "Using recommended gas configuration for reliable transactions",
      relayerConfigPresetTitle: "Fast Speed Preset Active",
      relayerConfigPresetDesc: "Transactions will use high priority gas pricing for quick inclusion",
      relayerConfigCustomizeBtn: "Customize Gas Settings",
      detailsTitle: "Relayer Details",
      network: "Network",
      relayerId: "Relayer ID",
      active: "Active",
      paused: "Paused",
      systemDisabled: "System Disabled",
      balance: "Balance",
      nonce: "Nonce",
      pending: "Pending Transactions",
      lastTransaction: "Last Transaction"
    };
  }
  /**
   * @inheritdoc
   */
  getContractDefinitionInputs() {
    return [
      {
        id: "contractAddress",
        name: "contractAddress",
        label: "Contract Address",
        type: "blockchain-address",
        validation: { required: true },
        placeholder: "0x1234...abcd",
        helperText: "Enter the deployed contract address. For verified contracts, the ABI will be fetched automatically from the block explorer."
      },
      {
        id: "contractDefinition",
        name: "contractDefinition",
        label: "Contract ABI (Optional)",
        type: "code-editor",
        validation: { required: false },
        placeholder: '[{"inputs":[],"name":"myFunction","outputs":[],"stateMutability":"nonpayable","type":"function"}]',
        helperText: "If the contract is not verified on the block explorer, paste the contract's ABI JSON here. You can find this in your contract's compilation artifacts or deployment files.",
        codeEditorProps: {
          language: "json",
          placeholder: "Paste your contract ABI JSON here...",
          maxHeight: "500px",
          performanceThreshold: 3e3
          // Disable syntax highlighting for large ABIs
        }
      }
    ];
  }
  /**
   * @inheritdoc
   */
  async validateRpcEndpoint(rpcConfig) {
    return validateEvmRpcEndpoint(rpcConfig);
  }
  /**
   * @inheritdoc
   */
  async testRpcConnection(rpcConfig) {
    return testEvmRpcConnection(rpcConfig);
  }
  /**
   * @inheritdoc
   */
  async validateExplorerConfig(explorerConfig) {
    return validateEvmExplorerConfig(explorerConfig);
  }
  /**
   * @inheritdoc
   */
  async testExplorerConnection(explorerConfig) {
    return testEvmExplorerConnection(explorerConfig, this.networkConfig);
  }
  /**
   * @inheritdoc
   */
  async compareContractDefinitions(storedSchema, freshSchema) {
    return compareContractDefinitions(storedSchema, freshSchema);
  }
  /**
   * @inheritdoc
   */
  validateContractDefinition(definition) {
    return validateContractDefinition(definition);
  }
  /**
   * @inheritdoc
   */
  hashContractDefinition(definition) {
    return hashContractDefinition(definition);
  }
  /**
   * @inheritdoc
   */
  getTypeMappingInfo() {
    return getEvmTypeMappingInfo();
  }
};

// src/config.ts
var evmAdapterConfig = {
  /**
   * Dependencies required by the EVM adapter
   * These will be included in exported projects that use this adapter
   */
  dependencies: {
    // Runtime dependencies
    runtime: {
      // Core EVM libraries
      // Wallet connection libraries
      wagmi: "^2.15.0",
      "@wagmi/core": "^2.20.3",
      viem: "^2.28.0",
      "@tanstack/react-query": "^5.0.0"
      // Utility library
      // lodash: '^4.17.21',
    },
    // Development dependencies
    dev: {
      // '@types/lodash': '^4.17.16',
      "@types/lodash": "^4.17.5"
    }
  },
  overrides: {
    "use-sync-external-store": "^1.2.0",
    valtio: "^1.13.2"
  },
  uiKits: {
    rainbowkit: {
      dependencies: {
        runtime: {
          "@rainbow-me/rainbowkit": "^2.2.8"
        }
      },
      overrides: {
        "@paulmillr/qr": "npm:qr@^0.5.0",
        "@walletconnect/modal": "^2.7.1"
      }
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  EvmAdapter,
  abiComparisonService,
  arbitrumMainnet,
  arbitrumSepolia,
  avalancheFuji,
  avalancheMainnet,
  baseMainnet,
  baseSepolia,
  bscMainnet,
  bscTestnet,
  ethereumMainnet,
  ethereumSepolia,
  evmAdapterConfig,
  evmMainnetNetworks,
  evmNetworks,
  evmTestnetNetworks,
  extractRainbowKitCustomizations,
  isEvmContractArtifacts,
  isRainbowKitCustomizations,
  lineaMainnet,
  lineaSepolia,
  optimismMainnet,
  optimismSepolia,
  polygonAmoy,
  polygonMainnet,
  polygonZkEvmCardona,
  polygonZkEvmMainnet,
  scrollMainnet,
  scrollSepolia,
  zkSyncEraMainnet,
  zksyncSepoliaTestnet
});
//# sourceMappingURL=index.cjs.map