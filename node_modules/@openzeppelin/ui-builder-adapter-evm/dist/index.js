var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// ../adapter-evm-core/dist/index.js
import { isAddress } from "viem";
import { formatGwei, parseGwei } from "viem";
import { logger as logger14 } from "@openzeppelin/ui-utils";
import { logger as logger15 } from "@openzeppelin/ui-utils";
import { encodeFunctionData, formatEther } from "viem";
import {
  Configuration,
  RelayersApi
} from "@openzeppelin/relayer-sdk";
import { logger as logger16 } from "@openzeppelin/ui-utils";
import { logger } from "@openzeppelin/ui-utils";
import { logger as logger4 } from "@openzeppelin/ui-utils";
import { trimEnd } from "lodash";
import { appConfigService, logger as logger3, userNetworkServiceConfigService } from "@openzeppelin/ui-utils";
import { logger as logger2 } from "@openzeppelin/ui-utils";
import { logger as logger5 } from "@openzeppelin/ui-utils";
import { isAddress as isAddress2 } from "viem";
import {
  appConfigService as appConfigService3,
  logger as logger8,
  simpleHash,
  userNetworkServiceConfigService as userNetworkServiceConfigService3,
  withTimeout
} from "@openzeppelin/ui-utils";
import { createPublicClient, http, keccak256, parseAbi, toHex } from "viem";
import { logger as logger7 } from "@openzeppelin/ui-utils";
import {
  appConfigService as appConfigService2,
  isValidUrl,
  logger as logger6,
  userNetworkServiceConfigService as userNetworkServiceConfigService2
} from "@openzeppelin/ui-utils";
import { logger as logger9, simpleHash as simpleHash2 } from "@openzeppelin/ui-utils";
import { startCase } from "lodash";
import {
  enhanceNumericValidation,
  getDefaultValueForType
} from "@openzeppelin/ui-utils";
import { getAddress, isAddress as isAddress3 } from "viem";
import { logger as logger10 } from "@openzeppelin/ui-utils";
import { logger as logger11 } from "@openzeppelin/ui-utils";
import { createPublicClient as createPublicClient2, http as http2, isAddress as isAddress4 } from "viem";
import { logger as logger12 } from "@openzeppelin/ui-utils";
import { isAddress as isAddress5 } from "viem";
import { logger as logger13 } from "@openzeppelin/ui-utils";
import { logger as logger17 } from "@openzeppelin/ui-utils";
import { createContext } from "react";
import { useContext } from "react";
import { useEffect, useState } from "react";
import { logger as logger18 } from "@openzeppelin/ui-utils";
import { Fragment, jsx } from "react/jsx-runtime";
import { Loader2, Wallet } from "lucide-react";
import { useEffect as useEffect3, useState as useState3 } from "react";
import { Button as Button2 } from "@openzeppelin/ui-components";
import { useDerivedAccountStatus as useDerivedAccountStatus2, useDerivedConnectStatus as useDerivedConnectStatus2 } from "@openzeppelin/ui-react";
import { cn, getWalletButtonSizeProps } from "@openzeppelin/ui-utils";
import { useEffect as useEffect2, useState as useState2 } from "react";
import {
  Button,
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle
} from "@openzeppelin/ui-components";
import { useDerivedAccountStatus, useDerivedConnectStatus } from "@openzeppelin/ui-react";
import { jsx as jsx2, jsxs } from "react/jsx-runtime";
import { jsx as jsx3, jsxs as jsxs2 } from "react/jsx-runtime";
import { LogOut } from "lucide-react";
import { Button as Button3 } from "@openzeppelin/ui-components";
import { useDerivedAccountStatus as useDerivedAccountStatus3, useDerivedDisconnect } from "@openzeppelin/ui-react";
import { cn as cn2, getWalletAccountDisplaySizeProps, truncateMiddle } from "@openzeppelin/ui-utils";
import { jsx as jsx4, jsxs as jsxs3 } from "react/jsx-runtime";
import { Loader2 as Loader22 } from "lucide-react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue
} from "@openzeppelin/ui-components";
import {
  useDerivedAccountStatus as useDerivedAccountStatus4,
  useDerivedChainInfo,
  useDerivedSwitchChainStatus
} from "@openzeppelin/ui-react";
import {
  cn as cn3,
  getWalletNetworkSwitcherSizeProps,
  getWalletNetworkSwitcherVariantClassName
} from "@openzeppelin/ui-utils";
import { jsx as jsx5, jsxs as jsxs4 } from "react/jsx-runtime";
import { logger as logger19 } from "@openzeppelin/ui-utils";
import { injected, metaMask, safe, walletConnect } from "@wagmi/connectors";
import {
  connect,
  createConfig,
  disconnect,
  getAccount,
  getPublicClient as getWagmiCorePublicClient,
  getWalletClient as getWagmiWalletClient,
  switchChain,
  watchAccount
} from "@wagmi/core";
import { http as http3 } from "viem";
import { appConfigService as appConfigService4, logger as logger20 } from "@openzeppelin/ui-utils";
import { logger as logger21 } from "@openzeppelin/ui-utils";
import { Loader2 as Loader23 } from "lucide-react";
import { useContext as useContext2, useEffect as useEffect4, useRef, useState as useState4 } from "react";
import { Button as Button4 } from "@openzeppelin/ui-components";
import { cn as cn4, getWalletButtonSizeProps as getWalletButtonSizeProps2, logger as logger22 } from "@openzeppelin/ui-utils";
import { jsx as jsx6, jsxs as jsxs5 } from "react/jsx-runtime";
import { http as http4 } from "@wagmi/core";
import { logger as logger23 } from "@openzeppelin/ui-utils";
import { logger as logger24 } from "@openzeppelin/ui-utils";
import { logger as logger25 } from "@openzeppelin/ui-utils";
import { logger as logger26 } from "@openzeppelin/ui-utils";
import { ECOSYSTEM_WALLET_COMPONENT_KEYS } from "@openzeppelin/ui-types";
import { logger as logger27 } from "@openzeppelin/ui-utils";
import { logger as logger28 } from "@openzeppelin/ui-utils";
var __defProp2 = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
function isEvmContractArtifacts(obj) {
  return typeof obj === "object" && obj !== null && typeof obj.contractAddress === "string";
}
var init_artifacts = __esm({
  "src/types/artifacts.ts"() {
    "use strict";
  }
});
function validateAndConvertEvmArtifacts(source) {
  if (typeof source === "string") {
    return { contractAddress: source };
  }
  if (!isEvmContractArtifacts(source)) {
    throw new Error(
      "Invalid contract artifacts provided. Expected an object with contractAddress property."
    );
  }
  return source;
}
var init_artifacts2 = __esm({
  "src/utils/artifacts.ts"() {
    "use strict";
    init_artifacts();
  }
});
function stringifyWithBigInt(value, space) {
  const replacer = (_key, val) => {
    if (typeof val === "bigint") {
      return val.toString();
    }
    return val;
  };
  return JSON.stringify(value, replacer, space);
}
var init_json = __esm({
  "src/utils/json.ts"() {
    "use strict";
  }
});
function formatMethodName(name) {
  if (!name) return "";
  return name.replace(/([A-Z])/g, " $1").replace(/^./, (str) => str.toUpperCase()).trim();
}
function formatInputName(name, type) {
  if (!name || name === "") {
    return `Parameter (${type})`;
  }
  return name.replace(/([A-Z])/g, " $1").replace(/_/g, " ").replace(/^./, (str) => str.toUpperCase()).trim();
}
var init_formatting = __esm({
  "src/utils/formatting.ts"() {
    "use strict";
  }
});
function isValidEvmAddress(address) {
  return isAddress(address);
}
var init_validation = __esm({
  "src/utils/validation.ts"() {
    "use strict";
  }
});
var weiToGwei;
var gweiToWei;
var init_gas = __esm({
  "src/utils/gas.ts"() {
    "use strict";
    weiToGwei = (wei) => {
      if (!wei) return void 0;
      return parseFloat(formatGwei(BigInt(wei)));
    };
    gweiToWei = (gwei) => {
      if (!gwei) return void 0;
      return Number(parseGwei(gwei.toString()));
    };
  }
});
var utils_exports = {};
__export(utils_exports, {
  formatInputName: () => formatInputName,
  formatMethodName: () => formatMethodName,
  gweiToWei: () => gweiToWei,
  isValidEvmAddress: () => isValidEvmAddress,
  stringifyWithBigInt: () => stringifyWithBigInt,
  validateAndConvertEvmArtifacts: () => validateAndConvertEvmArtifacts,
  weiToGwei: () => weiToGwei
});
var init_utils = __esm({
  "src/utils/index.ts"() {
    "use strict";
    init_artifacts2();
    init_json();
    init_formatting();
    init_validation();
    init_gas();
  }
});
async function validateEoaConfig(config, walletStatus) {
  if (!config.allowAny) {
    if (!config.specificAddress) {
      return "EOA execution selected, but no specific address was provided when 'allowAny' is false.";
    }
    if (!isValidEvmAddress(config.specificAddress)) {
      return `Invalid specific EOA address format: ${config.specificAddress}`;
    }
    if (walletStatus?.isConnected && walletStatus.address) {
      if (walletStatus.address.toLowerCase() !== config.specificAddress.toLowerCase()) {
        return `Connected wallet address (${walletStatus.address}) does not match the required specific EOA address (${config.specificAddress}). Please connect the correct wallet.`;
      }
    } else if (walletStatus?.isConnected && !walletStatus.address) {
      logger14.warn(
        SYSTEM_LOG_TAG,
        "Wallet is connected but address is unavailable for EOA validation."
      );
      return "Connected wallet address is not available for validation against specific EOA.";
    }
  }
  return true;
}
var SYSTEM_LOG_TAG;
var init_eoa = __esm({
  "src/validation/eoa.ts"() {
    "use strict";
    init_validation();
    SYSTEM_LOG_TAG = "EoaValidator";
  }
});
var eoa_exports = {};
__export(eoa_exports, {
  EoaExecutionStrategy: () => EoaExecutionStrategy
});
var SYSTEM_LOG_TAG2;
var EoaExecutionStrategy;
var init_eoa2 = __esm({
  "src/transaction/eoa.ts"() {
    "use strict";
    init_eoa();
    SYSTEM_LOG_TAG2 = "EoaExecutionStrategy";
    EoaExecutionStrategy = class {
      async execute(transactionData, executionConfig, walletImplementation, onStatusChange, _runtimeApiKey) {
        const { walletClient, accountStatus } = await this.getAuthenticatedWalletClient(walletImplementation);
        const eoaConfig = executionConfig;
        const validationResult = await validateEoaConfig(eoaConfig, {
          isConnected: accountStatus.isConnected,
          address: accountStatus.address
        });
        if (validationResult !== true) {
          throw new Error(validationResult);
        }
        logger15.info(SYSTEM_LOG_TAG2, "Using EOA execution strategy.");
        try {
          logger15.debug(SYSTEM_LOG_TAG2, "Calling walletClient.writeContract with:", {
            account: accountStatus.address,
            address: transactionData.address,
            abi: transactionData.abi,
            functionName: transactionData.functionName,
            args: transactionData.args,
            value: transactionData.value,
            chain: walletClient.chain
          });
          onStatusChange("pendingSignature", {});
          const hash = await walletClient.writeContract({
            account: accountStatus.address,
            address: transactionData.address,
            abi: transactionData.abi,
            functionName: transactionData.functionName,
            args: transactionData.args,
            value: transactionData.value,
            chain: walletClient.chain
          });
          logger15.info(SYSTEM_LOG_TAG2, "EOA Transaction initiated. Hash:", hash);
          return { txHash: hash };
        } catch (error) {
          logger15.error(SYSTEM_LOG_TAG2, "Error during EOA writeContract call:", error);
          const errorMessage = error instanceof Error ? error.message : "Unknown EOA transaction error";
          throw new Error(`Transaction failed (EOA): ${errorMessage}`);
        }
      }
      async getAuthenticatedWalletClient(walletImplementation) {
        const walletClient = await walletImplementation.getWalletClient();
        if (!walletClient) {
          logger15.error(SYSTEM_LOG_TAG2, "Wallet client not available. Is wallet connected?");
          throw new Error("Wallet is not connected or client is unavailable.");
        }
        const accountStatus = walletImplementation.getWalletConnectionStatus();
        if (!accountStatus.isConnected || !accountStatus.address) {
          logger15.error(SYSTEM_LOG_TAG2, "Account not available. Is wallet connected?");
          throw new Error("Wallet is not connected or account address is unavailable.");
        }
        return { walletClient, accountStatus };
      }
    };
  }
});
var relayer_exports = {};
__export(relayer_exports, {
  RelayerExecutionStrategy: () => RelayerExecutionStrategy
});
var RelayerExecutionStrategy;
var init_relayer = __esm({
  "src/transaction/relayer.ts"() {
    "use strict";
    RelayerExecutionStrategy = class {
      async execute(transactionData, executionConfig, _walletImplementation, onStatusChange, runtimeApiKey) {
        const relayerConfig = executionConfig;
        if (!runtimeApiKey) {
          throw new Error("API Key is required for Relayer execution.");
        }
        const { transactionId } = await this.sendTransactionViaRelayer(
          transactionData,
          relayerConfig,
          runtimeApiKey
        );
        onStatusChange("pendingRelayer", { transactionId });
        const sdkConfig = new Configuration({
          basePath: relayerConfig.serviceUrl,
          accessToken: runtimeApiKey
        });
        const txHash = await this.pollForTransactionHash(
          relayerConfig.relayer.relayerId,
          transactionId,
          sdkConfig
        );
        return { txHash };
      }
      /**
       * Fetches and filters relayers for a specific EVM network from the OpenZeppelin Relayer service.
       * This function handles pagination to retrieve all available relayers.
       *
       * @param serviceUrl - The base URL of the relayer service.
       * @param accessToken - The session-based API key for authentication.
       * @param networkConfig - EVM-compatible network configuration to filter relayers by (works with any ecosystem).
       * @returns A promise that resolves to an array of compatible relayer details.
       * @throws If the API call fails or returns an unsuccessful response.
       */
      async getEvmRelayers(serviceUrl, accessToken, networkConfig) {
        logger16.info(
          "[Relayer] Getting relayers with access token",
          accessToken.slice(0, 5).padEnd(accessToken.length, "*")
        );
        const sdkConfig = new Configuration({
          basePath: serviceUrl,
          accessToken
        });
        const relayersApi = new RelayersApi(sdkConfig);
        let allRelayers = [];
        let currentPage = 1;
        let totalItems = 0;
        let hasMore = true;
        do {
          const { data } = await relayersApi.listRelayers(currentPage, 100);
          if (!data.success || !data.data) {
            throw new Error(`Failed to fetch relayers on page ${currentPage}.`);
          }
          allRelayers = [...allRelayers, ...data.data];
          totalItems = data.pagination?.total_items || 0;
          if (allRelayers.length >= totalItems) {
            hasMore = false;
          } else {
            currentPage++;
          }
        } while (hasMore);
        return allRelayers.filter(
          (r) => r.network_type === "evm" && networkConfig.id.includes(r.network)
        ).map((r) => ({
          relayerId: r.id,
          name: r.name,
          address: r.address || "",
          network: r.network,
          paused: r.paused || false
        }));
      }
      /**
       * Fetches comprehensive information about a specific relayer including balance and status.
       * This function combines multiple SDK API calls to provide rich relayer details.
       *
       * @param serviceUrl - The base URL of the relayer service.
       * @param accessToken - The session-based API key for authentication.
       * @param relayerId - The unique identifier of the relayer.
       * @param networkConfig - EVM-compatible network configuration to get the native currency symbol (works with any ecosystem).
       * @returns A promise that resolves to enhanced relayer details including balance and status.
       * @throws If any API call fails or returns an unsuccessful response.
       */
      async getEvmRelayer(serviceUrl, accessToken, relayerId, networkConfig) {
        logger16.info("[Relayer] Getting detailed relayer info", relayerId);
        const sdkConfig = new Configuration({
          basePath: serviceUrl,
          accessToken
        });
        const relayersApi = new RelayersApi(sdkConfig);
        try {
          const [relayerResponse, balanceResponse, statusResponse] = await Promise.all([
            relayersApi.getRelayer(relayerId),
            relayersApi.getRelayerBalance(relayerId).catch((err) => {
              logger16.warn("[Relayer] Failed to fetch balance", err);
              return null;
            }),
            relayersApi.getRelayerStatus(relayerId).catch((err) => {
              logger16.warn("[Relayer] Failed to fetch status", err);
              return null;
            })
          ]);
          if (!relayerResponse.data.success || !relayerResponse.data.data) {
            throw new Error(`Failed to fetch relayer details for ID: ${relayerId}`);
          }
          const relayerData = relayerResponse.data.data;
          const enhancedDetails = {
            relayerId: relayerData.id,
            name: relayerData.name,
            address: relayerData.address || "",
            network: relayerData.network,
            paused: relayerData.paused || false,
            systemDisabled: relayerData.system_disabled || false
          };
          if (balanceResponse?.data?.success && balanceResponse.data.data?.balance) {
            try {
              const balanceInWei = BigInt(balanceResponse.data.data.balance);
              const balanceInEth = formatEther(balanceInWei);
              const currencySymbol = networkConfig.nativeCurrency.symbol;
              enhancedDetails.balance = `${balanceInEth} ${currencySymbol}`;
            } catch (error) {
              logger16.warn("[Relayer] Failed to format balance, using raw value", String(error));
              enhancedDetails.balance = String(balanceResponse.data.data.balance);
            }
          }
          if (statusResponse?.data?.success && statusResponse.data.data) {
            const statusData = statusResponse.data.data;
            if (statusData.network_type === "evm") {
              if (statusData.nonce !== void 0 && statusData.nonce !== null) {
                enhancedDetails.nonce = String(statusData.nonce);
              }
              if (statusData.pending_transactions_count !== void 0) {
                enhancedDetails.pendingTransactionsCount = statusData.pending_transactions_count;
              }
              if (statusData.last_confirmed_transaction_timestamp) {
                enhancedDetails.lastConfirmedTransactionTimestamp = statusData.last_confirmed_transaction_timestamp;
              }
            }
          }
          logger16.info("[Relayer] Retrieved enhanced relayer details", JSON.stringify(enhancedDetails));
          return enhancedDetails;
        } catch (error) {
          logger16.error(
            "[Relayer] Failed to get relayer details",
            error instanceof Error ? error.message : String(error)
          );
          throw error;
        }
      }
      /**
       * Submits a transaction to the relayer service for asynchronous processing.
       * @param transactionData The contract write parameters.
       * @param executionConfig The relayer-specific execution configuration.
       * @param runtimeApiKey The user's session-only API key.
       * @returns A promise that resolves to an object containing the transaction ID assigned by the relayer.
       */
      async sendTransactionViaRelayer(transactionData, executionConfig, runtimeApiKey) {
        const data = encodeFunctionData({
          abi: transactionData.abi,
          functionName: transactionData.functionName,
          args: transactionData.args
        });
        const evmOptions = executionConfig.transactionOptions;
        const valueBigint = transactionData.value ?? 0n;
        let valueNumber = 0;
        const MAX_SAFE = BigInt(Number.MAX_SAFE_INTEGER);
        if (valueBigint > MAX_SAFE) {
          logger16.warn(
            "[Relayer] Value exceeds JS safe integer. Truncating for request.",
            valueBigint.toString()
          );
          valueNumber = Number(MAX_SAFE);
        } else {
          valueNumber = Number(valueBigint);
        }
        const relayerTxRequest = {
          to: transactionData.address,
          data,
          value: valueNumber,
          // If no explicit gas limit is provided, keep a conservative default but warn.
          gas_limit: (() => {
            if (typeof evmOptions?.gasLimit === "number") return evmOptions.gasLimit;
            logger16.warn(
              "[Relayer]",
              "No gasLimit provided; using default 210000. Consider setting explicitly."
            );
            return 21e4;
          })(),
          // Note: The OpenZeppelin Relayer API requires exactly one gas pricing strategy to be provided.
          // Valid options are: speed, gas_price, or both max_fee_per_gas + max_priority_fee_per_gas.
          // If none are provided, the API will return a 400 Bad Request error.
          // Only include speed if explicitly set in options
          ...evmOptions?.speed !== void 0 && { speed: evmOptions.speed },
          // Include optional parameters only if provided
          ...evmOptions?.gasPrice !== void 0 && { gas_price: evmOptions.gasPrice },
          ...evmOptions?.maxFeePerGas !== void 0 && { max_fee_per_gas: evmOptions.maxFeePerGas },
          ...evmOptions?.maxPriorityFeePerGas !== void 0 && {
            max_priority_fee_per_gas: evmOptions.maxPriorityFeePerGas
          },
          ...evmOptions?.validUntil !== void 0 && { valid_until: evmOptions.validUntil }
        };
        const sdkConfig = new Configuration({
          basePath: executionConfig.serviceUrl,
          accessToken: runtimeApiKey
        });
        const relayersApi = new RelayersApi(sdkConfig);
        const result = await relayersApi.sendTransaction(
          executionConfig.relayer.relayerId,
          relayerTxRequest
        );
        if (!result.data.success || !result.data.data?.id) {
          throw new Error(`Relayer API failed to return a transaction ID. Error: ${result.data.error}`);
        }
        return { transactionId: result.data.data.id };
      }
      /**
       * Polls the relayer for a transaction's status until it is mined and has a hash, or fails.
       * @param relayerId The ID of the relayer processing the transaction.
       * @param transactionId The ID of the transaction to poll.
       * @param sdkConfig The SDK configuration containing the necessary authentication.
       * @returns A promise that resolves to the final transaction hash.
       * @throws If the transaction fails or polling times out.
       */
      async pollForTransactionHash(relayerId, transactionId, sdkConfig) {
        const relayersApi = new RelayersApi(sdkConfig);
        const POLLING_INTERVAL = 2e3;
        const POLLING_TIMEOUT = 3e5;
        const startTime = Date.now();
        while (Date.now() - startTime < POLLING_TIMEOUT) {
          const { data } = await relayersApi.getTransactionById(relayerId, transactionId);
          if (!data.success || !data.data) {
            throw new Error(`Failed to get transaction status for ID: ${transactionId}`);
          }
          const txResponse = data.data;
          if (txResponse.status === "mined" || txResponse.status === "confirmed") {
            if (!txResponse.hash) {
              throw new Error(
                `Transaction is confirmed but no hash was returned for ID: ${transactionId}`
              );
            }
            return txResponse.hash;
          }
          if (txResponse.status === "failed" || txResponse.status === "canceled" || txResponse.status === "expired") {
            throw new Error(
              `Transaction ${txResponse.status}: ${txResponse.status_reason || "No reason provided."}`
            );
          }
          await new Promise((resolve) => setTimeout(resolve, POLLING_INTERVAL));
        }
        throw new Error(`Polling for transaction hash timed out for ID: ${transactionId}`);
      }
    };
  }
});
init_utils();
function transformAbiToSchema(abi, contractName, address) {
  logger.info("transformAbiToSchema", `Transforming ABI to ContractSchema for: ${contractName}`);
  const functions = [];
  for (const item of abi) {
    if (item.type === "function") {
      const abiFunctionItem = item;
      functions.push({
        // Generate a unique ID for the function within the schema.
        // This often combines name and input types to handle overloads.
        id: `${abiFunctionItem.name}_${abiFunctionItem.inputs?.map((i) => i.type).join("_") || ""}`,
        name: abiFunctionItem.name || "",
        // Fallback for unnamed functions (though rare).
        displayName: formatMethodName(abiFunctionItem.name || ""),
        // Create a more readable name for UI.
        // Recursively map ABI inputs and outputs to our FunctionParameter structure.
        // This ensures that any non-standard properties (like 'internalType') are stripped.
        inputs: mapAbiParametersToSchemaParameters(abiFunctionItem.inputs),
        outputs: mapAbiParametersToSchemaParameters(abiFunctionItem.outputs),
        type: "function",
        // Explicitly set, as we filtered for this type.
        stateMutability: abiFunctionItem.stateMutability,
        // Preserve EVM-specific state mutability.
        // Determine if the function modifies blockchain state based on its `stateMutability`.
        // This is a crucial piece of information for the UI (e.g., to differentiate read vs. write calls).
        modifiesState: !abiFunctionItem.stateMutability || // If undefined, assume it modifies state (safer default)
        !["view", "pure"].includes(abiFunctionItem.stateMutability)
      });
    }
  }
  const contractSchema = {
    ecosystem: "evm",
    // This transformer is specific to EVM.
    name: contractName,
    address,
    functions
  };
  logger.info(
    "transformAbiToSchema",
    `Transformation complete. Found ${contractSchema.functions.length} functions.`
  );
  return contractSchema;
}
function mapAbiParametersToSchemaParameters(abiParams) {
  if (!abiParams) {
    return [];
  }
  return abiParams.map((param) => {
    const schemaParam = {
      name: param.name || "",
      // Ensure name is a string, fallback if undefined in ABI.
      type: param.type,
      // The raw type string from the ABI (e.g., 'uint256', 'address', 'tuple').
      displayName: formatInputName(param.name || "", param.type)
      // Generate a user-friendly name.
      // `description` is not a standard part of an ABI parameter, so it's not mapped here.
      // It can be added later by the user in the builder app UI.
    };
    if (param.type.startsWith("tuple") && "components" in param && // Type guard for discriminated union (AbiParameter)
    param.components && param.components.length > 0) {
      schemaParam.components = mapAbiParametersToSchemaParameters(
        param.components
      );
    }
    return schemaParam;
  });
}
function mapSchemaParameterToAbiParameter(param) {
  if (param.type.startsWith("tuple") && param.components && param.components.length > 0) {
    return {
      name: param.name || void 0,
      // ABI parameter names can be undefined (e.g., for return values).
      type: param.type,
      // Cast to satisfy viem's specific tuple type string.
      // Recursively map nested components back to AbiParameter format.
      components: param.components.map(mapSchemaParameterToAbiParameter)
    };
  }
  return {
    name: param.name || void 0,
    type: param.type
    // `internalType` is not part of our `FunctionParameter` model, so it's not added back here.
    // Other ABI-specific fields like `indexed` (for events) are also not relevant here as
    // this function is focused on function parameters for `AbiFunction`.
  };
}
function createAbiFunctionItem(functionDetails) {
  return {
    name: functionDetails.name,
    type: "function",
    inputs: functionDetails.inputs.map(mapSchemaParameterToAbiParameter),
    outputs: functionDetails.outputs?.map(mapSchemaParameterToAbiParameter) || [],
    stateMutability: functionDetails.stateMutability ?? "view"
  };
}
var ETHERSCAN_V2_BASE_URL = "https://api.etherscan.io/v2/api";
function buildV2ApiUrl(chainId, module, action, params, apiKey) {
  const url = new URL(ETHERSCAN_V2_BASE_URL);
  url.searchParams.append("chainid", chainId.toString());
  url.searchParams.append("module", module);
  url.searchParams.append("action", action);
  Object.entries(params).forEach(([key, value]) => {
    url.searchParams.append(key, value);
  });
  if (apiKey) {
    url.searchParams.append("apikey", apiKey);
  }
  return url.toString();
}
function shouldUseV2Api(networkConfig) {
  if (!networkConfig.supportsEtherscanV2) {
    return false;
  }
  return true;
}
async function loadAbiFromEtherscanV2(address, networkConfig) {
  const explorerConfig = resolveExplorerConfig(networkConfig);
  const url = buildV2ApiUrl(
    networkConfig.chainId,
    "contract",
    "getabi",
    { address },
    explorerConfig.apiKey
  );
  let response;
  try {
    logger2.info(
      "loadAbiFromEtherscanV2",
      `Fetching ABI from Etherscan V2 API for address: ${address} on chain ${networkConfig.chainId}`
    );
    response = await fetch(url);
  } catch (networkError) {
    logger2.error(
      "loadAbiFromEtherscanV2",
      `Network error fetching ABI from Explorer V2 API: ${networkError}`
    );
    throw new Error(`Network error fetching ABI: ${networkError.message}`);
  }
  if (!response.ok) {
    logger2.error(
      "loadAbiFromEtherscanV2",
      `Explorer V2 API request failed with status: ${response.status}`
    );
    throw new Error(`Explorer V2 API request failed: ${response.status} ${response.statusText}`);
  }
  let apiResult;
  try {
    apiResult = await response.json();
  } catch (jsonError) {
    logger2.error(
      "loadAbiFromEtherscanV2",
      `Failed to parse Explorer V2 API response as JSON: ${jsonError}`
    );
    throw new Error("Invalid JSON response received from Explorer V2 API.");
  }
  if (apiResult.status !== "1") {
    logger2.warn(
      "loadAbiFromEtherscanV2",
      `Explorer V2 API error: Status ${apiResult.status}, Message: ${apiResult.message}, Result: ${apiResult.result}`
    );
    if (apiResult.message?.includes("NOTOK")) {
      if (apiResult.result?.includes("Invalid API Key")) {
        throw new Error(
          `Invalid API key for Etherscan V2. Please check your API key configuration.`
        );
      }
      if (apiResult.result?.includes("Contract source code not verified")) {
        throw new Error(
          `Contract not verified on ${networkConfig.name} explorer (address: ${address}). ABI not available. You can provide the contract's ABI manually.`
        );
      }
      if (apiResult.result?.includes("Invalid chain")) {
        throw new Error(
          `Chain ID ${networkConfig.chainId} is not supported by Etherscan V2 API. Please check if this chain is available.`
        );
      }
    }
    throw new Error(`Explorer V2 API Error: ${apiResult.result || apiResult.message}`);
  }
  const originalAbiString = apiResult.result;
  let abi;
  try {
    abi = JSON.parse(originalAbiString);
    if (!Array.isArray(abi)) {
      throw new Error("Parsed ABI from Explorer V2 API is not an array.");
    }
  } catch (error) {
    logger2.error(
      "loadAbiFromEtherscanV2",
      `Failed to parse ABI JSON string from Explorer V2 API result: ${error}`
    );
    throw new Error(`Invalid ABI JSON received from Explorer V2 API: ${error.message}`);
  }
  logger2.info(
    "loadAbiFromEtherscanV2",
    `Successfully parsed ABI for ${networkConfig.name} with ${abi.length} items using V2 API.`
  );
  const contractName = `Contract_${address.substring(0, 6)}`;
  const schema = transformAbiToSchema(abi, contractName, address);
  return {
    schema,
    originalAbi: originalAbiString
  };
}
async function testEtherscanV2Connection(networkConfig, apiKey) {
  const startTime = Date.now();
  const requiresApiKey = networkConfig.requiresExplorerApiKey ?? true;
  if (requiresApiKey && !apiKey) {
    return {
      success: false,
      error: "API key is required for testing connection to this explorer"
    };
  }
  try {
    const url = buildV2ApiUrl(networkConfig.chainId, "proxy", "eth_blockNumber", {}, apiKey);
    const response = await fetch(url);
    const latency = Date.now() - startTime;
    if (!response.ok) {
      return {
        success: false,
        error: `HTTP ${response.status}: ${response.statusText}`,
        latency
      };
    }
    const data = await response.json();
    if (data.status === "0" && data.message) {
      if (data.result?.includes("Invalid API Key")) {
        return {
          success: false,
          error: "Invalid API key. Please check your Etherscan API key.",
          latency
        };
      }
      if (data.result?.includes("Invalid chain")) {
        return {
          success: false,
          error: `Chain ID ${networkConfig.chainId} is not supported by Etherscan V2 API.`,
          latency
        };
      }
      return {
        success: false,
        error: data.result || data.message,
        latency
      };
    }
    return {
      success: true,
      latency
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Connection test failed",
      latency: Date.now() - startTime
    };
  }
}
init_utils();
function resolveExplorerApiKeyFromAppConfig(networkConfig) {
  const isV2 = networkConfig.supportsEtherscanV2 && networkConfig.primaryExplorerApiIdentifier === "etherscan-v2";
  if (isV2) {
    const globalV2ApiKey = appConfigService.getGlobalServiceConfig("etherscanv2")?.apiKey;
    if (globalV2ApiKey) {
      return globalV2ApiKey;
    }
  }
  if (networkConfig.primaryExplorerApiIdentifier) {
    const globalServiceConfig = appConfigService.getGlobalServiceConfig(
      networkConfig.primaryExplorerApiIdentifier
    );
    const apiKey = globalServiceConfig?.apiKey ?? appConfigService.getExplorerApiKey(networkConfig.primaryExplorerApiIdentifier);
    if (apiKey) {
      return apiKey;
    }
  }
  return void 0;
}
function resolveExplorerConfig(networkConfig) {
  const isV2 = networkConfig.supportsEtherscanV2 && networkConfig.primaryExplorerApiIdentifier === "etherscan-v2";
  const globalV2ApiKey = isV2 ? appConfigService.getGlobalServiceConfig("etherscanv2")?.apiKey : void 0;
  let appApiKey;
  if (networkConfig.primaryExplorerApiIdentifier) {
    const globalServiceConfig = appConfigService.getGlobalServiceConfig(
      networkConfig.primaryExplorerApiIdentifier
    );
    appApiKey = globalServiceConfig?.apiKey ?? appConfigService.getExplorerApiKey(networkConfig.primaryExplorerApiIdentifier);
  }
  const rawCfg = userNetworkServiceConfigService.get(networkConfig.id, "explorer");
  if (rawCfg && typeof rawCfg === "object") {
    const userCfg = rawCfg;
    logger3.info("ExplorerConfig", `Using user-configured explorer for ${networkConfig.name}`);
    return {
      explorerUrl: userCfg.explorerUrl ?? networkConfig.explorerUrl,
      apiUrl: userCfg.apiUrl ?? networkConfig.apiUrl,
      apiKey: userCfg.apiKey ?? globalV2ApiKey ?? appApiKey,
      name: `${networkConfig.name} Explorer`,
      isCustom: true
    };
  }
  if (isV2 && globalV2ApiKey) {
    logger3.info("ExplorerConfig", `Using global Etherscan V2 API key for ${networkConfig.name}`);
    return {
      explorerUrl: networkConfig.explorerUrl,
      apiUrl: networkConfig.apiUrl,
      apiKey: globalV2ApiKey,
      name: `${networkConfig.name} Explorer (V2 API)`,
      isCustom: false
    };
  }
  if (appApiKey) {
    logger3.info("ExplorerConfig", `Using app-configured API key for ${networkConfig.name}`);
    return {
      explorerUrl: networkConfig.explorerUrl,
      apiUrl: networkConfig.apiUrl,
      apiKey: appApiKey,
      name: `${networkConfig.name} Explorer`,
      isCustom: false
    };
  }
  logger3.info(
    "ExplorerConfig",
    `Using default explorer for ${networkConfig.name} (no API key configured)`
  );
  return {
    explorerUrl: networkConfig.explorerUrl,
    apiUrl: networkConfig.apiUrl,
    name: `${networkConfig.name} Explorer`,
    isCustom: false
  };
}
function getEvmExplorerAddressUrl(address, networkConfig) {
  if (!isValidEvmAddress(address)) {
    return null;
  }
  const explorerConfig = resolveExplorerConfig(networkConfig);
  if (!explorerConfig.explorerUrl) {
    return null;
  }
  const baseUrl = trimEnd(explorerConfig.explorerUrl, "/");
  return `${baseUrl}/address/${address}`;
}
function getEvmExplorerTxUrl(txHash, networkConfig) {
  if (!txHash) {
    return null;
  }
  const explorerConfig = resolveExplorerConfig(networkConfig);
  if (!explorerConfig.explorerUrl) {
    return null;
  }
  const baseUrl = trimEnd(explorerConfig.explorerUrl, "/");
  return `${baseUrl}/tx/${txHash}`;
}
function validateEvmExplorerConfig(explorerConfig) {
  if (explorerConfig.explorerUrl) {
    try {
      new URL(explorerConfig.explorerUrl);
    } catch {
      return false;
    }
  }
  if (explorerConfig.apiUrl) {
    try {
      new URL(explorerConfig.apiUrl);
    } catch {
      return false;
    }
  }
  if (explorerConfig.apiKey !== void 0 && explorerConfig.apiKey.trim().length === 0) {
    return false;
  }
  return true;
}
async function testEvmExplorerConnection(explorerConfig, networkConfig) {
  if (networkConfig && shouldUseV2Api(networkConfig)) {
    logger3.info(
      "testEvmExplorerConnection",
      `Using V2 API connection test for ${networkConfig.name}`
    );
    return testEtherscanV2Connection(networkConfig, explorerConfig.apiKey);
  }
  const requiresApiKey = networkConfig && "requiresExplorerApiKey" in networkConfig ? networkConfig.requiresExplorerApiKey !== false : true;
  if (requiresApiKey && !explorerConfig.apiKey) {
    return {
      success: false,
      error: "API key is required for testing connection to this explorer"
    };
  }
  let apiUrl = explorerConfig.apiUrl;
  if (!apiUrl && networkConfig?.apiUrl) {
    apiUrl = networkConfig.apiUrl;
  }
  if (!apiUrl) {
    return {
      success: false,
      error: "API URL is required for testing connection. Please provide an API URL or ensure the network has a default API URL configured."
    };
  }
  const startTime = Date.now();
  try {
    const url = new URL(apiUrl);
    url.searchParams.append("module", "proxy");
    url.searchParams.append("action", "eth_blockNumber");
    if (explorerConfig.apiKey) {
      url.searchParams.append("apikey", explorerConfig.apiKey);
    }
    const response = await fetch(url.toString());
    const latency = Date.now() - startTime;
    if (!response.ok) {
      return {
        success: false,
        error: `HTTP ${response.status}: ${response.statusText}`,
        latency
      };
    }
    const data = await response.json();
    if (data.status === "0" && data.message) {
      return {
        success: false,
        error: data.message,
        latency
      };
    }
    return {
      success: true,
      latency
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Connection test failed",
      latency: Date.now() - startTime
    };
  }
}
async function loadAbiFromEtherscan(address, networkConfig) {
  if (shouldUseV2Api(networkConfig)) {
    logger4.info("loadAbiFromEtherscan", "Using V2 API for fetching ABI");
    return loadAbiFromEtherscanV2(address, networkConfig);
  }
  logger4.info("loadAbiFromEtherscan", "Using V1 API for fetching ABI");
  return loadAbiFromEtherscanV1(address, networkConfig);
}
async function loadAbiFromEtherscanV1(address, networkConfig) {
  const explorerConfig = resolveExplorerConfig(networkConfig);
  if (!explorerConfig.apiUrl) {
    logger4.error(
      "loadAbiFromEtherscanV1",
      `API URL is missing for ${networkConfig.name} explorer.`
    );
    throw new Error(`Explorer API URL for ${networkConfig.name} is not configured.`);
  }
  const url = new URL(explorerConfig.apiUrl);
  url.searchParams.append("module", "contract");
  url.searchParams.append("action", "getabi");
  url.searchParams.append("address", address);
  if (explorerConfig.apiKey) {
    url.searchParams.append("apikey", explorerConfig.apiKey);
  }
  let response;
  try {
    logger4.info(
      "loadAbiFromEtherscanV1",
      `Fetching ABI from ${explorerConfig.apiUrl} for address: ${address}`
    );
    response = await fetch(url);
  } catch (networkError) {
    logger4.error(
      "loadAbiFromEtherscanV1",
      `Network error fetching ABI from Explorer API: ${networkError}`
    );
    throw new Error(`Network error fetching ABI: ${networkError.message}`);
  }
  if (!response.ok) {
    logger4.error(
      "loadAbiFromEtherscanV1",
      `Explorer API request failed with status: ${response.status}`
    );
    throw new Error(`Explorer API request failed: ${response.status} ${response.statusText}`);
  }
  let apiResult;
  try {
    apiResult = await response.json();
  } catch (jsonError) {
    logger4.error(
      "loadAbiFromEtherscanV1",
      `Failed to parse Explorer API response as JSON: ${jsonError}`
    );
    throw new Error("Invalid JSON response received from Explorer API.");
  }
  if (apiResult.status !== "1") {
    logger4.warn(
      "loadAbiFromEtherscanV1",
      `Explorer API error: Status ${apiResult.status}, Message: ${apiResult.message}, Result: ${apiResult.result}`
    );
    if (apiResult.result?.includes("Contract source code not verified")) {
      throw new Error(
        `Contract not verified on ${networkConfig.name} explorer (address: ${address}). ABI not available. You can provide the contract's ABI manually.`
      );
    }
    throw new Error(`Explorer API Error: ${apiResult.result || apiResult.message}`);
  }
  const originalAbiString = apiResult.result;
  let abi;
  try {
    abi = JSON.parse(originalAbiString);
    if (!Array.isArray(abi)) {
      throw new Error("Parsed ABI from Explorer API is not an array.");
    }
  } catch (error) {
    logger4.error(
      "loadAbiFromEtherscanV1",
      `Failed to parse ABI JSON string from Explorer API result: ${error}`
    );
    throw new Error(`Invalid ABI JSON received from Explorer API: ${error.message}`);
  }
  logger4.info(
    "loadAbiFromEtherscanV1",
    `Successfully parsed ABI for ${networkConfig.name} with ${abi.length} items.`
  );
  const contractName = `Contract_${address.substring(0, 6)}`;
  const schema = transformAbiToSchema(abi, contractName, address);
  return {
    schema,
    originalAbi: originalAbiString
  };
}
var SOURCIFY_APP_BASE = "https://repo.sourcify.dev";
function getSourcifyContractAppUrl(chainId, address) {
  return `${SOURCIFY_APP_BASE}/${chainId}/${address}`;
}
var SOURCIFY_API_BASE = "https://sourcify.dev/server/v2";
function buildSourcifyApiUrl(chainId, address) {
  const normalizedAddress = address.toLowerCase();
  const url = new URL(
    `${SOURCIFY_API_BASE}/contract/${chainId}/${normalizedAddress}?fields=abi,metadata`
  );
  return url.toString();
}
async function loadAbiFromSourcify(address, networkConfig, timeoutMs = 4e3) {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const url = buildSourcifyApiUrl(networkConfig.chainId, address);
    logger5.info("loadAbiFromSourcify", `Fetching contract from ${url}`);
    const response = await fetch(url, { signal: controller.signal });
    if (!response.ok) {
      throw new Error(`Sourcify request failed: ${response.status} ${response.statusText}`);
    }
    const payload = await response.json();
    const abi = payload.abi ?? payload.metadata?.output?.abi;
    if (!abi || !Array.isArray(abi)) {
      throw new Error("Sourcify metadata did not include a valid ABI array");
    }
    const normalizedAddress = address.toLowerCase();
    const contractName = payload.metadata?.contractName || `Contract_${normalizedAddress.substring(0, 6).toUpperCase()}`;
    const schema = transformAbiToSchema(abi, contractName, address);
    return { schema, originalAbi: JSON.stringify(abi) };
  } catch (error) {
    logger5.warn("loadAbiFromSourcify", `Failed to fetch ABI from Sourcify: ${String(error)}`);
    throw error;
  } finally {
    clearTimeout(timeout);
  }
}
function buildRpcUrl(config) {
  return config.url;
}
function getUserRpcUrl(networkId) {
  const svcCfg = userNetworkServiceConfigService2.get(networkId, "rpc");
  if (svcCfg && typeof svcCfg === "object" && "rpcUrl" in svcCfg) {
    return svcCfg.rpcUrl;
  }
  return void 0;
}
function resolveRpcUrl(networkConfig) {
  const logSystem = "RpcResolver";
  const networkId = networkConfig.id;
  const userRpcUrl = getUserRpcUrl(networkId);
  if (userRpcUrl) {
    const userRpcUrlString = String(userRpcUrl);
    if (isValidUrl(userRpcUrlString)) {
      logger6.info(logSystem, `Using user-configured RPC URL for network ${networkId}`);
      return userRpcUrlString;
    } else {
      logger6.warn(
        logSystem,
        `User-configured RPC URL for ${networkId} is invalid: ${userRpcUrlString}. Falling back.`
      );
    }
  }
  const rpcOverrideSetting = appConfigService2.getRpcEndpointOverride(networkId);
  let rpcUrlFromOverride;
  if (typeof rpcOverrideSetting === "string") {
    rpcUrlFromOverride = rpcOverrideSetting;
  } else if (typeof rpcOverrideSetting === "object" && rpcOverrideSetting) {
    if ("url" in rpcOverrideSetting && "isCustom" in rpcOverrideSetting) {
      const userConfig = rpcOverrideSetting;
      rpcUrlFromOverride = buildRpcUrl(userConfig);
    } else if ("http" in rpcOverrideSetting) {
      rpcUrlFromOverride = rpcOverrideSetting.http;
    }
  }
  if (rpcUrlFromOverride) {
    logger6.info(
      logSystem,
      `Using overridden RPC URL for network ${networkId}: ${rpcUrlFromOverride}`
    );
    if (isValidUrl(rpcUrlFromOverride)) {
      return rpcUrlFromOverride;
    } else {
      logger6.warn(
        logSystem,
        `Overridden RPC URL for ${networkId} is invalid: ${rpcUrlFromOverride}. Falling back.`
      );
    }
  }
  if (networkConfig.rpcUrl && isValidUrl(networkConfig.rpcUrl)) {
    logger6.debug(
      logSystem,
      `Using default RPC URL for network ${networkId}: ${networkConfig.rpcUrl}`
    );
    return networkConfig.rpcUrl;
  }
  logger6.error(
    logSystem,
    `No valid RPC URL could be resolved for network ${networkId}. Checked user config, override, and networkConfig.rpcUrl.`
  );
  throw new Error(
    `No valid RPC URL configured for network ${networkConfig.name} (ID: ${networkId}).`
  );
}
function validateEvmRpcEndpoint(rpcConfig) {
  try {
    if (!isValidUrl(rpcConfig.url)) {
      logger6.error("validateEvmRpcEndpoint", `Invalid RPC URL format: ${rpcConfig.url}`);
      return false;
    }
    return true;
  } catch (error) {
    logger6.error("validateEvmRpcEndpoint", "Error validating RPC endpoint:", error);
    return false;
  }
}
async function testEvmRpcConnection(rpcConfig, timeoutMs = 5e3) {
  if (!rpcConfig.url) {
    return { success: false, error: "RPC URL is required" };
  }
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const startTime = Date.now();
    const response = await fetch(rpcConfig.url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "eth_blockNumber",
        params: [],
        id: 1
      }),
      signal: controller.signal
    });
    if (!response.ok) {
      return { success: false, error: `HTTP error: ${response.status}` };
    }
    const data = await response.json();
    const latency = Date.now() - startTime;
    if (data.error) {
      return { success: false, error: data.error.message || "RPC error" };
    }
    return { success: true, latency };
  } catch (error) {
    logger6.error("testEvmRpcConnection", "Connection test failed:", error);
    if (error instanceof Error && error.name === "AbortError") {
      return {
        success: false,
        error: `Connection timeout after ${timeoutMs}ms`
      };
    }
    return {
      success: false,
      error: error instanceof Error ? error.message : "Connection failed"
    };
  } finally {
    clearTimeout(timeoutId);
  }
}
async function getEvmCurrentBlock(networkConfig) {
  const rpcUrl = resolveRpcUrl(networkConfig);
  try {
    const response = await fetch(rpcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "eth_blockNumber",
        params: [],
        id: 1
      })
    });
    if (!response.ok) {
      throw new Error(`RPC request failed with status ${response.status}`);
    }
    const data = await response.json();
    if (data.error) {
      throw new Error(data.error.message || "RPC error");
    }
    if (data.result === void 0 || data.result === null) {
      throw new Error("RPC response missing result field");
    }
    const blockNumber = parseInt(data.result, 16);
    if (isNaN(blockNumber)) {
      throw new Error(`Invalid block number returned: ${data.result}`);
    }
    return blockNumber;
  } catch (error) {
    logger6.error("getEvmCurrentBlock", "Failed to get current block:", error);
    throw new Error(
      `Failed to get current block: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}
function detectProxyFromAbi(abi) {
  const functions = abi.filter((item) => item.type === "function");
  const events = abi.filter((item) => item.type === "event");
  const errors = abi.filter((item) => item.type === "error");
  const indicators = [];
  let proxyType = null;
  let confidence = "low";
  const hasUpgradeEvent = events.some((e) => e.name === "Upgraded");
  const hasImplementationFunction = functions.some((f) => f.name === "implementation");
  const hasUUPSErrors = errors.some((e) => e.name?.includes("ERC1967"));
  const hasUpgradeToFunction = functions.some(
    (f) => f.name === "upgradeToAndCall" || f.name === "upgradeTo"
  );
  if (hasUpgradeEvent || hasUUPSErrors) {
    indicators.push("ERC1967 upgrade pattern detected");
    proxyType = "uups";
    confidence = "high";
  }
  if (hasImplementationFunction) {
    indicators.push("implementation() function found");
    if (proxyType === "uups") {
      confidence = "high";
    } else {
      proxyType = "transparent";
      confidence = "medium";
    }
  }
  if (hasUpgradeToFunction && proxyType === "uups") {
    indicators.push("UUPS upgrade functions found");
    confidence = "high";
  }
  const hasAdminFunction = functions.some((f) => f.name === "admin");
  const hasProxyAdminErrors = errors.some((e) => e.name?.includes("ProxyDenied"));
  const hasChangeAdminFunction = functions.some((f) => f.name === "changeAdmin");
  if (hasAdminFunction || hasProxyAdminErrors || hasChangeAdminFunction) {
    indicators.push("Transparent proxy admin pattern detected");
    if (proxyType === null) {
      proxyType = "transparent";
      confidence = "medium";
    }
  }
  const hasBeaconFunction = functions.some((f) => f.name === "beacon");
  const hasBeaconUpgrade = events.some((e) => e.name === "BeaconUpgraded");
  if (hasBeaconFunction || hasBeaconUpgrade) {
    indicators.push("Beacon proxy pattern detected");
    proxyType = "beacon";
    confidence = "high";
  }
  const hasDiamondCut = functions.some((f) => f.name === "diamondCut");
  const hasFacets = functions.some((f) => f.name === "facets");
  const hasFacetFunctionSelectors = functions.some((f) => f.name === "facetFunctionSelectors");
  if (hasDiamondCut || hasFacets && hasFacetFunctionSelectors) {
    indicators.push("Diamond (EIP-2535) proxy pattern detected");
    proxyType = "diamond";
    confidence = "high";
  }
  const hasFallback = abi.some((item) => item.type === "fallback");
  const hasProxyConstructor = abi.some(
    (item) => item.type === "constructor" && item.inputs?.some(
      (input) => input.name === "implementation" || input.name === "_logic" || input.name === "_data"
    )
  );
  if (hasFallback) {
    indicators.push("Fallback function present");
  }
  if (hasProxyConstructor) {
    indicators.push("Proxy-style constructor detected");
  }
  const hasMinimalFunctions = functions.length <= 1;
  const hasNoEvents = events.length === 0;
  if (hasMinimalFunctions && hasNoEvents && hasFallback && proxyType === null) {
    indicators.push("Minimal proxy pattern detected");
    proxyType = "minimal";
    confidence = "medium";
  }
  const isProxy = proxyType !== null || hasFallback && hasMinimalFunctions && (hasProxyConstructor || functions.length === 0);
  if (isProxy && proxyType === null) {
    proxyType = "unknown";
    indicators.push("Generic proxy pattern detected");
    confidence = "low";
  }
  return {
    isProxy,
    proxyType,
    confidence,
    indicators
  };
}
async function getImplementationAddress(proxyAddress, networkConfig, proxyType) {
  logger7.info(
    "getImplementationAddress",
    `Resolving implementation for ${proxyType} proxy: ${proxyAddress}`
  );
  try {
    switch (proxyType) {
      case "uups":
      case "transparent": {
        const eip1967Impl = await getEIP1967Implementation(proxyAddress, networkConfig);
        if (eip1967Impl) return eip1967Impl;
        const legacyImpl = await getLegacyOZImplementation(proxyAddress, networkConfig);
        if (legacyImpl) return legacyImpl;
        return null;
      }
      case "beacon":
        return await getBeaconImplementation(proxyAddress, networkConfig);
      case "diamond":
        logger7.info("getImplementationAddress", "Diamond proxies not fully supported yet");
        return null;
      case "minimal":
        return await getMinimalProxyImplementation(proxyAddress, networkConfig);
      default:
        return await tryCommonImplementationMethods(proxyAddress, networkConfig);
    }
  } catch (error) {
    logger7.warn("getImplementationAddress", `Failed to resolve implementation: ${error}`);
    return null;
  }
}
async function getAdminAddress(proxyAddress, networkConfig) {
  try {
    const eip1967Admin = await getEIP1967Admin(proxyAddress, networkConfig);
    if (eip1967Admin) return eip1967Admin;
    const legacyAdmin = await getLegacyOZAdmin(proxyAddress, networkConfig);
    if (legacyAdmin) return legacyAdmin;
    return null;
  } catch (error) {
    logger7.warn("getAdminAddress", `Failed to resolve admin: ${error}`);
    return null;
  }
}
async function getEIP1967Implementation(proxyAddress, networkConfig) {
  const implementationSlot = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";
  return await readStorageSlot(proxyAddress, implementationSlot, networkConfig);
}
async function getEIP1967Admin(proxyAddress, networkConfig) {
  const adminSlot = "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103";
  return await readStorageSlot(proxyAddress, adminSlot, networkConfig);
}
async function getLegacyOZAdmin(proxyAddress, networkConfig) {
  try {
    const slot = keccak256(toHex("org.zeppelinos.proxy.admin"));
    logger7.info("getLegacyOZAdmin", `Trying legacy OZ admin slot: ${slot}`);
    return await readStorageSlot(proxyAddress, slot, networkConfig);
  } catch (error) {
    logger7.warn("getLegacyOZAdmin", `Failed computing or reading legacy admin slot: ${error}`);
    return null;
  }
}
async function getLegacyOZImplementation(proxyAddress, networkConfig) {
  try {
    const slot = keccak256(toHex("org.zeppelinos.proxy.implementation"));
    logger7.info("getLegacyOZImplementation", `Trying legacy OZ slot: ${slot}`);
    return await readStorageSlot(proxyAddress, slot, networkConfig);
  } catch (error) {
    logger7.warn("getLegacyOZImplementation", `Failed computing or reading legacy slot: ${error}`);
    return null;
  }
}
async function getBeaconImplementation(proxyAddress, networkConfig) {
  const beaconSlot = "0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50";
  const beaconAddress = await readStorageSlot(proxyAddress, beaconSlot, networkConfig);
  if (!beaconAddress) {
    return null;
  }
  return await callContractFunction(beaconAddress, "implementation()", [], networkConfig);
}
async function getMinimalProxyImplementation(proxyAddress, networkConfig) {
  try {
    const bytecode = await getContractBytecode(proxyAddress, networkConfig);
    if (!bytecode || bytecode.length < 42) {
      return null;
    }
    if (bytecode.startsWith("0x363d3d373d3d3d363d73") && bytecode.includes("5af43d82803e903d91602b57fd5bf3")) {
      const implementationHex = bytecode.slice(22, 62);
      return "0x" + implementationHex;
    }
    return null;
  } catch (error) {
    logger7.warn("getMinimalProxyImplementation", `Error reading bytecode: ${error}`);
    return null;
  }
}
async function tryCommonImplementationMethods(proxyAddress, networkConfig) {
  const commonMethods = [
    "implementation()",
    "getImplementation()",
    "_implementation()",
    "target()"
  ];
  for (const method of commonMethods) {
    try {
      const result = await callContractFunction(proxyAddress, method, [], networkConfig);
      if (result && result !== "0x0000000000000000000000000000000000000000") {
        logger7.info(
          "tryCommonImplementationMethods",
          `Found implementation via ${method}: ${result}`
        );
        return result;
      }
    } catch {
      continue;
    }
  }
  return await getEIP1967Implementation(proxyAddress, networkConfig);
}
function createViemClient(networkConfig) {
  const rpcUrl = resolveRpcUrl(networkConfig);
  return createPublicClient({
    transport: http(rpcUrl)
  });
}
async function readStorageSlot(address, slot, networkConfig) {
  try {
    const client = createViemClient(networkConfig);
    const storageValue = await client.getStorageAt({
      address,
      slot
    });
    if (storageValue && storageValue !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
      logger7.info("readStorageSlot", `Found non-zero value at slot ${slot}: ${storageValue}`);
      const implAddress = "0x" + storageValue.slice(-40);
      return implAddress;
    }
    return null;
  } catch (error) {
    logger7.warn("readStorageSlot", `Failed to read storage slot ${slot}: ${error}`);
    return null;
  }
}
async function callContractFunction(address, signature, params, networkConfig) {
  try {
    const client = createViemClient(networkConfig);
    const abi = parseAbi([signature]);
    const func = abi[0];
    const result = await client.readContract({
      address,
      abi,
      functionName: func.name,
      args: params
    });
    const addressResult = result;
    if (addressResult && addressResult !== "0x0000000000000000000000000000000000000000") {
      return addressResult;
    }
    return null;
  } catch (error) {
    logger7.warn("callContractFunction", `Failed to call ${signature}: ${error}`);
    return null;
  }
}
async function getContractBytecode(address, networkConfig) {
  try {
    const client = createViemClient(networkConfig);
    const bytecode = await client.getCode({
      address
    });
    return bytecode || null;
  } catch (error) {
    logger7.warn("getContractBytecode", `Failed to get bytecode: ${error}`);
    return null;
  }
}
var EvmProviderKeys = {
  Etherscan: "etherscan",
  Sourcify: "sourcify"
};
var EVM_PROVIDER_ORDER_DEFAULT = [
  EvmProviderKeys.Etherscan,
  EvmProviderKeys.Sourcify
];
function isEvmProviderKey(value) {
  return value === EvmProviderKeys.Etherscan || value === EvmProviderKeys.Sourcify;
}
async function loadAbiFromJson(abiJsonString) {
  let abi;
  try {
    abi = JSON.parse(abiJsonString);
    if (!Array.isArray(abi)) {
      throw new Error("Parsed JSON is not an array.");
    }
  } catch (error) {
    logger8.error("loadAbiFromJson", "Failed to parse source string as JSON ABI:", error);
    throw new Error(`Invalid JSON ABI provided: ${error.message}`);
  }
  logger8.info("loadAbiFromJson", `Successfully parsed JSON ABI with ${abi.length} items.`);
  const contractName = "ContractFromABI";
  return transformAbiToSchema(abi, contractName, void 0);
}
var PER_PROVIDER_TIMEOUT_MS = 4e3;
var OVERALL_BUDGET_MS = 1e4;
async function loadEvmContract(artifacts, networkConfig, options = {}) {
  const { contractAddress, contractDefinition, __proxyDetectionOptions } = artifacts;
  const proxyOptions = __proxyDetectionOptions;
  if (proxyOptions?.skipProxyDetection) {
    options.skipProxyDetection = true;
  }
  if (!contractAddress || typeof contractAddress !== "string" || !isAddress2(contractAddress)) {
    throw new Error("A valid contract address is required.");
  }
  if (contractDefinition && typeof contractDefinition === "string" && contractDefinition.trim().length > 0) {
    const trimmed = contractDefinition.trim();
    const hasJsonContent = trimmed.includes("[") && trimmed.includes("]") && trimmed.includes("{");
    if (hasJsonContent) {
      logger8.info("loadEvmContract", "Manual contract definition provided. Attempting to parse...");
      try {
        const schema = await loadAbiFromJson(contractDefinition);
        return {
          schema: { ...schema, address: contractAddress },
          source: "manual",
          contractDefinitionOriginal: contractDefinition,
          metadata: {
            contractName: schema.name,
            fetchTimestamp: /* @__PURE__ */ new Date(),
            verificationStatus: "unknown"
            // Manual ABI - verification status unknown
          }
          // Note: No proxy detection for manual ABIs - user provides what they want
        };
      } catch (error) {
        logger8.error("loadEvmContract", "Failed to parse manually provided ABI:", error);
        throw new Error(`The provided ABI JSON is invalid: ${error.message}`);
      }
    }
  }
  const forcedRaw = artifacts.__forcedProvider || artifacts.service;
  const forcedProvider = isEvmProviderKey(forcedRaw) ? forcedRaw : null;
  logger8.info(
    "loadEvmContract",
    `No manual ABI detected. Attempting Etherscan fetch for address: ${contractAddress}...`
  );
  return await loadContractWithProxyDetection(
    contractAddress,
    networkConfig,
    options,
    forcedProvider
  );
}
function buildContractResult(contractAddress, abiResult, networkConfig, sourceProvider, proxyInfo) {
  let fetchedFrom = void 0;
  if (sourceProvider === EvmProviderKeys.Etherscan) {
    fetchedFrom = getEvmExplorerAddressUrl(contractAddress, networkConfig) || void 0;
  } else if (sourceProvider === EvmProviderKeys.Sourcify) {
    fetchedFrom = getSourcifyContractAppUrl(networkConfig.chainId, contractAddress);
  } else {
    fetchedFrom = getEvmExplorerAddressUrl(contractAddress, networkConfig) || void 0;
  }
  return {
    schema: { ...abiResult.schema, address: contractAddress },
    source: "fetched",
    contractDefinitionOriginal: abiResult.originalAbi,
    metadata: {
      fetchedFrom,
      contractName: abiResult.schema.name,
      verificationStatus: "verified",
      fetchTimestamp: /* @__PURE__ */ new Date(),
      definitionHash: simpleHash(abiResult.originalAbi)
    },
    proxyInfo
  };
}
async function loadImplementationAbi(_contractAddress, implementationAddress, networkConfig, _proxyType) {
  try {
    const implementationResult = await loadAbiFromEtherscan(implementationAddress, networkConfig);
    logger8.info(
      "loadImplementationAbi",
      `Successfully fetched implementation ABI with ${implementationResult.schema.functions.length} functions`
    );
    return implementationResult;
  } catch (implementationError) {
    logger8.warn(
      "loadImplementationAbi",
      `Failed to load implementation ABI: ${implementationError}`
    );
    return null;
  }
}
async function handleProxyDetection(contractAddress, initialResult, networkConfig, initialProvider) {
  const abi = JSON.parse(initialResult.originalAbi);
  const proxyDetection = detectProxyFromAbi(abi);
  if (!proxyDetection.isProxy) {
    return null;
  }
  logger8.info(
    "handleProxyDetection",
    `Proxy detected: ${proxyDetection.proxyType} (confidence: ${proxyDetection.confidence})`
  );
  const proxyType = proxyDetection.proxyType || "unknown";
  const implementationAddress = await getImplementationAddress(
    contractAddress,
    networkConfig,
    proxyType
  );
  const adminAddress = await getAdminAddress(contractAddress, networkConfig);
  if (!implementationAddress) {
    logger8.info("handleProxyDetection", "Proxy detected but implementation address not found");
    return buildContractResult(contractAddress, initialResult, networkConfig, initialProvider, {
      isProxy: true,
      proxyType,
      proxyAddress: contractAddress,
      detectionMethod: "automatic"
    });
  }
  logger8.info("handleProxyDetection", `Found implementation at: ${implementationAddress}`);
  const implementationResult = await loadImplementationAbi(
    contractAddress,
    implementationAddress,
    networkConfig,
    proxyType
  );
  const baseProxyInfo = {
    isProxy: true,
    proxyType,
    implementationAddress,
    proxyAddress: contractAddress,
    detectionMethod: "automatic",
    ...adminAddress ? { adminAddress } : {}
  };
  if (implementationResult) {
    return buildContractResult(
      contractAddress,
      implementationResult,
      networkConfig,
      EvmProviderKeys.Etherscan,
      baseProxyInfo
    );
  } else {
    return buildContractResult(
      contractAddress,
      initialResult,
      networkConfig,
      initialProvider,
      baseProxyInfo
    );
  }
}
async function loadContractWithProxyDetection(contractAddress, networkConfig, options = {}, forcedProvider = null) {
  try {
    let uiDefault = null;
    const svcCfg = userNetworkServiceConfigService3.get(networkConfig.id, "contract-definitions");
    if (svcCfg && typeof svcCfg === "object" && "defaultProvider" in svcCfg) {
      const raw = svcCfg.defaultProvider;
      if (isEvmProviderKey(raw)) uiDefault = raw;
    }
    const appDefaultRaw = appConfigService3.getGlobalServiceParam(
      "contractdefinition",
      "defaultProvider"
    );
    const appDefault = typeof appDefaultRaw === "string" && isEvmProviderKey(appDefaultRaw) ? appDefaultRaw : null;
    const buildProviderArray = (primary) => [
      primary,
      primary === EvmProviderKeys.Etherscan ? EvmProviderKeys.Sourcify : EvmProviderKeys.Etherscan
    ];
    const providers = forcedProvider ? [forcedProvider] : uiDefault ? buildProviderArray(uiDefault) : appDefault ? buildProviderArray(appDefault) : [EvmProviderKeys.Etherscan, EvmProviderKeys.Sourcify];
    const overallDeadline = Date.now() + OVERALL_BUDGET_MS;
    let initialResult = null;
    let lastError = null;
    let usedProvider = null;
    for (const provider of providers) {
      try {
        const remainingOverall = Math.max(100, overallDeadline - Date.now());
        const attemptTimeout = Math.min(PER_PROVIDER_TIMEOUT_MS, remainingOverall);
        if (provider === EvmProviderKeys.Etherscan) {
          initialResult = await withTimeout(
            loadAbiFromEtherscan(contractAddress, networkConfig),
            attemptTimeout,
            "etherscan"
          );
        } else if (provider === EvmProviderKeys.Sourcify) {
          initialResult = await withTimeout(
            loadAbiFromSourcify(contractAddress, networkConfig, attemptTimeout),
            attemptTimeout,
            "sourcify"
          );
        }
        if (initialResult) {
          usedProvider = provider;
          break;
        }
      } catch (err) {
        lastError = err;
        continue;
      }
    }
    if (!initialResult) throw lastError ?? new Error("No provider succeeded");
    logger8.info(
      "loadContractWithProxyDetection",
      `Successfully fetched initial ABI for ${contractAddress} with ${initialResult.schema.functions.length} functions`
    );
    if (!options.skipProxyDetection && !options.treatAsImplementation) {
      const proxyResult = await handleProxyDetection(
        contractAddress,
        initialResult,
        networkConfig,
        usedProvider
      );
      if (proxyResult) {
        return proxyResult;
      }
    }
    return buildContractResult(contractAddress, initialResult, networkConfig, usedProvider);
  } catch (error) {
    logger8.warn("loadContractWithProxyDetection", `Contract loading failed: ${error}`);
    if (forcedProvider) {
      throw error;
    }
    const errorMessage = error.message || "";
    if (errorMessage.includes("Contract not verified")) {
      throw new Error(
        `Contract at ${contractAddress} is not verified on the block explorer. Verification status: unverified. Please provide the contract ABI manually.`
      );
    }
    throw error;
  }
}
async function loadContractSchema(source, networkConfig, options) {
  const { validateAndConvertEvmArtifacts: validateAndConvertEvmArtifacts2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
  const artifacts = validateAndConvertEvmArtifacts2(source);
  const result = await loadEvmContract(artifacts, networkConfig, options);
  return result.schema;
}
async function loadContractWithFullMetadata(source, networkConfig) {
  const { validateAndConvertEvmArtifacts: validateAndConvertEvmArtifacts2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
  const artifacts = validateAndConvertEvmArtifacts2(source);
  return loadEvmContract(artifacts, networkConfig);
}
function isValidAbiArray(value) {
  return Array.isArray(value) && value.every(isValidAbiItem);
}
function isValidAbiItem(item) {
  if (typeof item !== "object" || item === null) {
    return false;
  }
  const abiItem = item;
  if (typeof abiItem.type !== "string") {
    return false;
  }
  const validTypes = ["function", "event", "constructor", "error", "fallback", "receive"];
  if (!validTypes.includes(abiItem.type)) {
    return false;
  }
  if ((abiItem.type === "function" || abiItem.type === "event") && typeof abiItem.name !== "string") {
    return false;
  }
  if ((abiItem.type === "function" || abiItem.type === "event" || abiItem.type === "constructor") && abiItem.inputs !== void 0 && !Array.isArray(abiItem.inputs)) {
    return false;
  }
  return true;
}
var AbiComparisonService = class {
  /**
   * Compares two ABIs and returns detailed difference analysis
   */
  compareAbis(abi1, abi2) {
    try {
      const validation1 = this.validateAbi(abi1);
      const validation2 = this.validateAbi(abi2);
      if (!validation1.valid || !validation2.valid) {
        return {
          identical: false,
          differences: [],
          severity: "breaking",
          summary: "One or both ABIs are invalid and cannot be compared"
        };
      }
      const normalized1 = this.normalizeAbi(validation1.normalizedAbi);
      const normalized2 = this.normalizeAbi(validation2.normalizedAbi);
      const hash1 = simpleHash2(JSON.stringify(normalized1));
      const hash2 = simpleHash2(JSON.stringify(normalized2));
      if (hash1 === hash2) {
        return {
          identical: true,
          differences: [],
          severity: "none",
          summary: "ABIs are identical"
        };
      }
      const differences = this.findDifferences(normalized1, normalized2);
      const severity = this.calculateSeverity(differences);
      return {
        identical: false,
        differences,
        severity,
        summary: this.generateSummary(differences)
      };
    } catch (error) {
      logger9.error("ABI comparison failed:", error.message);
      return {
        identical: false,
        differences: [],
        severity: "breaking",
        summary: `Comparison failed: ${error.message}`
      };
    }
  }
  /**
   * Validates ABI structure and format
   */
  validateAbi(abiString) {
    const errors = [];
    const warnings = [];
    try {
      const abi = JSON.parse(abiString);
      if (!Array.isArray(abi)) {
        errors.push("ABI must be an array");
        return { valid: false, errors, warnings };
      }
      if (abi.length === 0) {
        errors.push(
          "ABI array cannot be empty - contract must have at least one function, event, or constructor"
        );
        return { valid: false, errors, warnings };
      }
      for (let i = 0; i < abi.length; i++) {
        const item = abi[i];
        if (!item.type) {
          errors.push(`Item ${i}: Missing 'type' field`);
          continue;
        }
        if (!["function", "event", "constructor", "error", "fallback", "receive"].includes(item.type)) {
          errors.push(`Item ${i}: Invalid type '${item.type}'`);
        }
        if (item.type === "function" && !item.name) {
          errors.push(`Item ${i}: Function missing 'name' field`);
        }
        if ((item.type === "function" || item.type === "event") && !Array.isArray(item.inputs)) {
          errors.push(`Item ${i}: Missing or invalid 'inputs' array`);
        }
        if (item.type === "function" && !Array.isArray(item.outputs)) {
          warnings.push(`Item ${i}: Function missing 'outputs' array`);
        }
      }
      if (errors.length === 0 && !isValidAbiArray(abi)) {
        errors.push("ABI does not conform to expected format");
      }
      return {
        valid: errors.length === 0,
        errors,
        warnings,
        normalizedAbi: errors.length === 0 ? abi : void 0
      };
    } catch (parseError) {
      errors.push(`Invalid JSON: ${parseError.message}`);
      return { valid: false, errors, warnings };
    }
  }
  /**
   * Creates deterministic hash of ABI for quick comparison
   */
  hashAbi(abiString) {
    try {
      const validation = this.validateAbi(abiString);
      if (!validation.valid || !validation.normalizedAbi) {
        throw new Error("Cannot hash invalid ABI");
      }
      const normalized = this.normalizeAbi(validation.normalizedAbi);
      const normalizedString = JSON.stringify(normalized);
      return simpleHash2(normalizedString);
    } catch (error) {
      logger9.error("ABI hashing failed:", error.message);
      throw new Error(`Failed to hash ABI: ${error.message}`);
    }
  }
  /**
   * Normalizes ABI for consistent comparison
   */
  normalizeAbi(abi) {
    return abi.map((item) => {
      const normalized = { ...item };
      if (normalized.inputs) {
        normalized.inputs = [...normalized.inputs].sort(
          (a, b) => (a.name || "").localeCompare(b.name || "")
        );
      }
      if (normalized.outputs) {
        normalized.outputs = [...normalized.outputs].sort(
          (a, b) => (a.name || "").localeCompare(b.name || "")
        );
      }
      return normalized;
    }).sort((a, b) => {
      const typeOrder = {
        constructor: 0,
        fallback: 1,
        receive: 2,
        function: 3,
        event: 4,
        error: 5
      };
      const aOrder = typeOrder[a.type] ?? 99;
      const bOrder = typeOrder[b.type] ?? 99;
      if (aOrder !== bOrder) return aOrder - bOrder;
      const aName = a.name || "";
      const bName = b.name || "";
      return aName.localeCompare(bName);
    });
  }
  /**
   * Finds detailed differences between two normalized ABIs
   */
  findDifferences(abi1, abi2) {
    const differences = [];
    const map1 = this.createAbiMap(abi1);
    const map2 = this.createAbiMap(abi2);
    for (const [key, item] of map1) {
      if (!map2.has(key)) {
        differences.push({
          type: "removed",
          section: item.type,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          name: item.name || item.type,
          details: `${item.type} was removed`,
          impact: this.calculateImpact(item.type, "removed"),
          oldSignature: this.generateSignature(item)
        });
      }
    }
    for (const [key, item] of map2) {
      if (!map1.has(key)) {
        differences.push({
          type: "added",
          section: item.type,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          name: item.name || item.type,
          details: `${item.type} was added`,
          impact: this.calculateImpact(item.type, "added"),
          newSignature: this.generateSignature(item)
        });
      }
    }
    for (const [key, item1] of map1) {
      const item2 = map2.get(key);
      if (item2 && !this.itemsEqual(item1, item2)) {
        differences.push({
          type: "modified",
          section: item1.type,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          name: item1.name || item1.type,
          details: `${item1.type} signature changed`,
          impact: this.calculateImpact(item1.type, "modified"),
          oldSignature: this.generateSignature(item1),
          newSignature: this.generateSignature(item2)
        });
      }
    }
    return differences;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  createAbiMap(abi) {
    const map = /* @__PURE__ */ new Map();
    for (const item of abi) {
      const key = this.generateItemKey(item);
      map.set(key, item);
    }
    return map;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  generateItemKey(item) {
    if (item.type === "constructor" || item.type === "fallback" || item.type === "receive") {
      return item.type;
    }
    const name = item.name || "";
    const inputs = item.inputs?.map((input) => input.type).join(",") || "";
    return `${item.type}:${name}(${inputs})`;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  generateSignature(item) {
    if (item.type === "constructor") {
      const inputs = (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        item.inputs?.map((input) => `${input.type} ${input.name || ""}`).join(", ") || ""
      );
      return `constructor(${inputs})`;
    }
    if (item.type === "fallback" || item.type === "receive") {
      return item.type + "()";
    }
    if (item.type === "function") {
      const inputs = (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        item.inputs?.map((input) => `${input.type} ${input.name || ""}`).join(", ") || ""
      );
      const outputs = item.outputs?.map((output) => output.type).join(", ") || "";
      const mutability = item.stateMutability ? ` ${item.stateMutability}` : "";
      return `function ${item.name}(${inputs})${mutability}${outputs ? ` returns (${outputs})` : ""}`;
    }
    if (item.type === "event") {
      const inputs = item.inputs?.map((input) => {
        const indexed = input.indexed ? " indexed" : "";
        return `${input.type}${indexed} ${input.name || ""}`;
      }).join(", ") || "";
      return `event ${item.name}(${inputs})`;
    }
    return JSON.stringify(item);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  itemsEqual(item1, item2) {
    return JSON.stringify(item1) === JSON.stringify(item2);
  }
  calculateImpact(type, changeType) {
    if (type === "constructor" || type === "fallback" || type === "receive") {
      return changeType === "modified" ? "high" : "medium";
    }
    if (type === "function") {
      if (changeType === "removed") return "high";
      if (changeType === "modified") return "medium";
      if (changeType === "added") return "low";
    }
    if (type === "event") {
      return "low";
    }
    if (type === "error") {
      return "low";
    }
    return "medium";
  }
  calculateSeverity(differences) {
    if (differences.length === 0) return "none";
    const hasHighImpact = differences.some((d) => d.impact === "high");
    const hasMediumImpact = differences.some((d) => d.impact === "medium");
    const hasRemovedFunctions = differences.some(
      (d) => d.type === "removed" && d.section === "function"
    );
    if (hasRemovedFunctions || hasHighImpact) return "breaking";
    if (hasMediumImpact) return "major";
    return "minor";
  }
  generateSummary(differences) {
    const counts = {
      added: differences.filter((d) => d.type === "added").length,
      removed: differences.filter((d) => d.type === "removed").length,
      modified: differences.filter((d) => d.type === "modified").length
    };
    const parts = [];
    if (counts.added > 0) parts.push(`${counts.added} added`);
    if (counts.removed > 0) parts.push(`${counts.removed} removed`);
    if (counts.modified > 0) parts.push(`${counts.modified} modified`);
    const summary = parts.join(", ");
    return `${summary}`;
  }
};
var abiComparisonService = new AbiComparisonService();
async function compareContractDefinitions(storedSchema, freshSchema) {
  return abiComparisonService.compareAbis(storedSchema, freshSchema);
}
function validateContractDefinition(definition) {
  return abiComparisonService.validateAbi(definition);
}
function hashContractDefinition(definition) {
  return abiComparisonService.hashAbi(definition);
}
var EVM_TYPE_TO_FIELD_TYPE = {
  address: "blockchain-address",
  string: "text",
  uint: "number",
  uint8: "number",
  uint16: "number",
  uint32: "number",
  uint64: "bigint",
  uint128: "bigint",
  uint256: "bigint",
  int: "number",
  int8: "number",
  int16: "number",
  int32: "number",
  int64: "bigint",
  int128: "bigint",
  int256: "bigint",
  bool: "checkbox",
  bytes: "bytes",
  bytes32: "bytes"
};
var EVM_DYNAMIC_PATTERNS = [
  { name: "array", syntax: "T[]", mapsTo: "array", description: "Dynamic array of primitives" },
  { name: "fixed-array", syntax: "T[N]", mapsTo: "array", description: "Fixed-size array" },
  {
    name: "tuple-array",
    syntax: "tuple[]",
    mapsTo: "array-object",
    description: "Array of structs"
  },
  { name: "tuple", syntax: "tuple", mapsTo: "object", description: "Struct/tuple type" }
];
function getEvmTypeMappingInfo() {
  return {
    primitives: { ...EVM_TYPE_TO_FIELD_TYPE },
    dynamicPatterns: EVM_DYNAMIC_PATTERNS
  };
}
function mapEvmParamTypeToFieldType(parameterType) {
  if (parameterType.match(/^tuple\[\d*\]$/)) {
    return "array-object";
  }
  if (parameterType.match(/\[\d*\]$/)) {
    return "array";
  }
  const baseType = parameterType.replace(/\[\d*\]/g, "");
  if (baseType.startsWith("tuple")) {
    return "object";
  }
  if (baseType.match(/^bytes\d+$/)) {
    return "bytes";
  }
  return EVM_TYPE_TO_FIELD_TYPE[baseType] || "text";
}
function getEvmCompatibleFieldTypes(parameterType) {
  if (parameterType.match(/^tuple\[\d*\]$/)) {
    return ["array-object", "textarea", "text"];
  }
  if (parameterType.match(/\[\d*\]$/)) {
    return ["array", "textarea", "text"];
  }
  const baseType = parameterType.replace(/\[\d*\]/g, "");
  if (baseType.startsWith("tuple")) {
    return ["object", "textarea", "text"];
  }
  const compatibilityMap = {
    address: ["blockchain-address", "text"],
    uint: ["number", "amount", "text"],
    uint8: ["number", "amount", "text"],
    uint16: ["number", "amount", "text"],
    uint32: ["number", "amount", "text"],
    uint64: ["bigint", "number", "amount", "text"],
    uint128: ["bigint", "number", "amount", "text"],
    uint256: ["bigint", "number", "amount", "text"],
    int: ["number", "text"],
    int8: ["number", "text"],
    int16: ["number", "text"],
    int32: ["number", "text"],
    int64: ["bigint", "number", "text"],
    int128: ["bigint", "number", "text"],
    int256: ["bigint", "number", "text"],
    bool: ["checkbox", "select", "radio", "text"],
    string: ["text", "textarea", "email", "password"],
    bytes: ["bytes", "textarea", "text"],
    bytes32: ["bytes", "textarea", "text"]
  };
  if (baseType.match(/^bytes\d+$/)) {
    return ["bytes", "textarea", "text"];
  }
  return compatibilityMap[baseType] || ["text"];
}
function extractBytesSize(parameterType) {
  const match = parameterType.match(/^bytes(\d+)$/);
  if (match) {
    return Number.parseInt(match[1], 10);
  }
  return void 0;
}
function extractArrayElementType(parameterType) {
  const arrayMatch = parameterType.match(/^(.+)\[\d*\]$/);
  if (arrayMatch) {
    return arrayMatch[1];
  }
  return null;
}
function getDefaultValidation() {
  return { required: true };
}
var EVM_NUMERIC_BOUNDS = {
  uint: { min: 0 },
  uint8: { min: 0, max: 255 },
  uint16: { min: 0, max: 65535 },
  uint32: { min: 0, max: 4294967295 },
  int: {},
  int8: { min: -128, max: 127 },
  int16: { min: -32768, max: 32767 },
  int32: { min: -2147483648, max: 2147483647 }
};
function generateEvmDefaultField(parameter) {
  const fieldType = mapEvmParamTypeToFieldType(parameter.type);
  const baseField = {
    id: `field-${Math.random().toString(36).substring(2, 9)}`,
    name: parameter.name || parameter.type,
    // Use type if name missing
    label: startCase(parameter.displayName || parameter.name || parameter.type),
    type: fieldType,
    placeholder: `Enter ${parameter.displayName || parameter.name || parameter.type}`,
    helperText: parameter.description || "",
    defaultValue: getDefaultValueForType(fieldType),
    validation: enhanceNumericValidation(
      getDefaultValidation(),
      parameter.type,
      EVM_NUMERIC_BOUNDS
    ),
    width: "full"
  };
  const bytesSize = extractBytesSize(parameter.type);
  if (bytesSize !== void 0) {
    baseField.metadata = {
      ...baseField.metadata ?? {},
      exactBytes: bytesSize
    };
  }
  if (fieldType === "array") {
    const elementType = extractArrayElementType(parameter.type);
    if (elementType) {
      const elementFieldType = mapEvmParamTypeToFieldType(elementType);
      const elementBytesSize = extractBytesSize(elementType);
      const arrayField = {
        ...baseField,
        elementType: elementFieldType,
        elementFieldConfig: {
          type: elementFieldType,
          validation: enhanceNumericValidation(
            getDefaultValidation(),
            elementType,
            EVM_NUMERIC_BOUNDS
          ),
          placeholder: `Enter ${elementType}`,
          // Include exactBytes metadata for fixed-size bytes array elements (e.g., bytes32[])
          ...elementBytesSize !== void 0 && {
            metadata: { exactBytes: elementBytesSize }
          }
        }
      };
      return arrayField;
    }
  }
  if (parameter.components && (fieldType === "object" || fieldType === "array-object")) {
    const result = {
      ...baseField,
      components: parameter.components
    };
    return result;
  }
  return baseField;
}
function parseEvmInput(param, rawValue, isRecursive = false) {
  const { type, name } = param;
  const baseType = type.replace(/\[\d*\]$/, "");
  const isArray = type.endsWith("]");
  try {
    if (isArray) {
      let parsedArray;
      if (!isRecursive) {
        if (typeof rawValue !== "string") {
          throw new Error("Array input must be a JSON string representation.");
        }
        try {
          parsedArray = JSON.parse(rawValue);
        } catch (e) {
          throw new Error(`Invalid JSON for array: ${e.message}`);
        }
      } else {
        if (!Array.isArray(rawValue)) {
          throw new Error("Internal error: Expected array in recursive call.");
        }
        parsedArray = rawValue;
      }
      if (!Array.isArray(parsedArray)) {
        throw new Error("Parsed JSON is not an array.");
      }
      const itemAbiParam = { ...param, type: baseType };
      return parsedArray.map((item) => parseEvmInput(itemAbiParam, item, true));
    }
    if (baseType === "tuple") {
      if (!param.components) {
        throw new Error(`ABI definition missing 'components' for tuple parameter '${name}'.`);
      }
      let parsedObject;
      if (!isRecursive) {
        if (typeof rawValue !== "string") {
          throw new Error("Tuple input must be a JSON string representation of an object.");
        }
        try {
          parsedObject = JSON.parse(rawValue);
        } catch (e) {
          throw new Error(`Invalid JSON for tuple: ${e.message}`);
        }
      } else {
        if (typeof rawValue !== "object" || rawValue === null || Array.isArray(rawValue)) {
          throw new Error("Internal error: Expected object in recursive tuple call.");
        }
        parsedObject = rawValue;
      }
      if (typeof parsedObject !== "object" || parsedObject === null || Array.isArray(parsedObject)) {
        throw new Error("Parsed JSON is not an object for tuple.");
      }
      const resultObject = {};
      for (const component of param.components) {
        if (!(component.name in parsedObject)) {
          throw new Error(`Missing component '${component.name}' in tuple JSON.`);
        }
        resultObject[component.name] = parseEvmInput(
          component,
          parsedObject[component.name],
          true
          // Pass isRecursive=true
        );
      }
      if (Object.keys(parsedObject).length !== param.components.length) {
        const expectedKeys = param.components.map((c) => c.name).join(", ");
        const actualKeys = Object.keys(parsedObject).join(", ");
        throw new Error(
          `Tuple object has incorrect number of keys. Expected ${param.components.length} (${expectedKeys}), but got ${Object.keys(parsedObject).length} (${actualKeys}).`
        );
      }
      return resultObject;
    }
    if (baseType.startsWith("bytes")) {
      if (typeof rawValue !== "string") {
        throw new Error("Bytes input must be a string.");
      }
      if (!/^0x([0-9a-fA-F]{2})*$/.test(rawValue)) {
        throw new Error(
          `Invalid hex string format for ${type}: must start with 0x and contain only hex characters.`
        );
      }
      const fixedSizeMatch = baseType.match(/^bytes(\d+)$/);
      if (fixedSizeMatch) {
        const expectedBytes = parseInt(fixedSizeMatch[1], 10);
        const actualBytes = (rawValue.length - 2) / 2;
        if (actualBytes !== expectedBytes) {
          throw new Error(
            `Invalid length for ${type}: expected ${expectedBytes} bytes (${expectedBytes * 2} hex chars), got ${actualBytes} bytes.`
          );
        }
      }
      return rawValue;
    }
    if (baseType.startsWith("uint") || baseType.startsWith("int")) {
      if (rawValue === "" || rawValue === null || rawValue === void 0)
        throw new Error("Numeric value cannot be empty.");
      try {
        return BigInt(rawValue);
      } catch {
        throw new Error(`Invalid numeric value: '${rawValue}'.`);
      }
    } else if (baseType === "address") {
      if (typeof rawValue !== "string" || !rawValue)
        throw new Error("Address value must be a non-empty string.");
      if (!isAddress3(rawValue)) throw new Error(`Invalid address format: '${rawValue}'.`);
      return getAddress(rawValue);
    } else if (baseType === "bool") {
      if (typeof rawValue === "boolean") return rawValue;
      if (typeof rawValue === "string") {
        const lowerVal = rawValue.toLowerCase().trim();
        if (lowerVal === "true") return true;
        if (lowerVal === "false") return false;
      }
      return Boolean(rawValue);
    } else if (baseType === "string") {
      return String(rawValue);
    }
    logger10.warn(
      "parseEvmInput",
      `Unknown EVM parameter type encountered: '${type}'. Using raw value.`
    );
    return rawValue;
  } catch (error) {
    throw new Error(
      `Failed to parse value for parameter '${name || "(unnamed)"}' (type '${type}'): ${error.message}`
    );
  }
}
init_utils();
function formatEvmFunctionResult(decodedValue, functionDetails) {
  if (!functionDetails.outputs || !Array.isArray(functionDetails.outputs)) {
    logger11.warn(
      "formatEvmFunctionResult",
      `Output ABI definition missing or invalid for function ${functionDetails.name}.`
    );
    return "[Error: Output ABI definition missing]";
  }
  try {
    let valueToFormat;
    if (Array.isArray(decodedValue)) {
      if (decodedValue.length === 1) {
        valueToFormat = decodedValue[0];
      } else {
        valueToFormat = decodedValue;
      }
    } else {
      valueToFormat = decodedValue;
    }
    if (typeof valueToFormat === "bigint") {
      return valueToFormat.toString();
    } else if (typeof valueToFormat === "string" || typeof valueToFormat === "number" || typeof valueToFormat === "boolean") {
      return String(valueToFormat);
    } else if (valueToFormat === null || valueToFormat === void 0) {
      return "(null)";
    } else {
      return stringifyWithBigInt(valueToFormat, 2);
    }
  } catch (error) {
    const errorMessage = `Error formatting result for ${functionDetails.name}: ${error.message}`;
    logger11.error("formatEvmFunctionResult", errorMessage, {
      functionName: functionDetails.name,
      decodedValue,
      error
    });
    return `[${errorMessage}]`;
  }
}
function isEvmViewFunction(functionDetails) {
  return functionDetails.stateMutability === "view" || functionDetails.stateMutability === "pure";
}
function createPublicClientWithRpc(networkConfig, rpcUrl) {
  let chainForViem;
  if (networkConfig.viemChain) {
    chainForViem = networkConfig.viemChain;
  } else {
    logger12.warn(
      "createPublicClientWithRpc",
      `Viem chain object (viemChain) not provided in EvmNetworkConfig for ${networkConfig.name} (query). Creating a minimal one.`
    );
    if (!networkConfig.rpcUrl) {
      throw new Error(
        `RPC URL is missing in networkConfig for ${networkConfig.name} and viemChain is not set for query client.`
      );
    }
    chainForViem = {
      id: networkConfig.chainId,
      name: networkConfig.name,
      nativeCurrency: networkConfig.nativeCurrency,
      rpcUrls: {
        default: { http: [networkConfig.rpcUrl] },
        public: { http: [networkConfig.rpcUrl] }
      },
      blockExplorers: networkConfig.explorerUrl ? { default: { name: `${networkConfig.name} Explorer`, url: networkConfig.explorerUrl } } : void 0
    };
  }
  try {
    const publicClient = createPublicClient2({
      chain: chainForViem,
      transport: http2(rpcUrl)
    });
    return publicClient;
  } catch (error) {
    logger12.error(
      "createPublicClientWithRpc",
      "Failed to create network-specific public client for query:",
      error
    );
    throw new Error(
      `Failed to create network-specific public client for query: ${error.message}`
    );
  }
}
async function queryEvmViewFunction(contractAddress, functionId, params, schema, rpcUrl, networkConfig) {
  logger12.info(
    "queryEvmViewFunction",
    `Querying view function: ${functionId} on ${contractAddress}`,
    { params }
  );
  try {
    if (!contractAddress || !isAddress4(contractAddress)) {
      throw new Error(`Invalid contract address provided: ${contractAddress}`);
    }
    const functionDetails = schema.functions.find((fn) => fn.id === functionId);
    if (!functionDetails) {
      throw new Error(`Function with ID ${functionId} not found in contract schema.`);
    }
    if (!isEvmViewFunction(functionDetails)) {
      throw new Error(`Function ${functionDetails.name} is not a view function.`);
    }
    const expectedInputs = functionDetails.inputs;
    if (params.length !== expectedInputs.length) {
      throw new Error(
        `Incorrect number of parameters provided for ${functionDetails.name}. Expected ${expectedInputs.length}, got ${params.length}.`
      );
    }
    const args = expectedInputs.map((inputParam, index) => {
      let rawValue = params[index];
      if (typeof inputParam.type === "string" && inputParam.type.endsWith("[]") && Array.isArray(rawValue)) {
        rawValue = JSON.stringify(rawValue);
      }
      return parseEvmInput(inputParam, rawValue, false);
    });
    logger12.debug("queryEvmViewFunction", "Parsed Args for readContract:", args);
    const minimalConfig = networkConfig || {
      id: "query-network",
      name: "Query Network",
      ecosystem: "evm",
      network: "unknown",
      type: "mainnet",
      isTestnet: false,
      chainId: 1,
      // Default to mainnet chain ID
      rpcUrl,
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      exportConstName: "queryNetwork"
    };
    const publicClient = createPublicClientWithRpc(minimalConfig, rpcUrl);
    const functionAbiItem = createAbiFunctionItem(functionDetails);
    logger12.debug(
      "queryEvmViewFunction",
      `[Query ${functionDetails.name}] Calling readContract with ABI:`,
      functionAbiItem,
      "Args:",
      args
    );
    let decodedResult;
    try {
      decodedResult = await publicClient.readContract({
        address: contractAddress,
        abi: [functionAbiItem],
        functionName: functionDetails.name,
        args
      });
    } catch (readError) {
      logger12.error(
        "queryEvmViewFunction",
        `[Query ${functionDetails.name}] publicClient.readContract specific error:`,
        readError
      );
      throw new Error(
        `Viem readContract failed for ${functionDetails.name}: ${readError.message}`
      );
    }
    logger12.debug(
      "queryEvmViewFunction",
      `[Query ${functionDetails.name}] Raw decoded result:`,
      decodedResult
    );
    return decodedResult;
  } catch (error) {
    const errorMessage = `Failed to query view function ${functionId}: ${error.message}`;
    logger12.error("queryEvmViewFunction", errorMessage, {
      contractAddress,
      functionId,
      params,
      error
    });
    throw new Error(errorMessage);
  }
}
function formatEvmTransactionData(contractSchema, functionId, submittedInputs, fields) {
  logger13.info(
    "formatEvmTransactionData",
    `Formatting EVM transaction data for function: ${functionId}`
  );
  const functionDetails = contractSchema.functions.find((fn) => fn.id === functionId);
  if (!functionDetails) {
    throw new Error(`Function definition for ${functionId} not found in provided contract schema.`);
  }
  const expectedArgs = functionDetails.inputs;
  const orderedRawValues = [];
  for (const expectedArg of expectedArgs) {
    const fieldConfig = fields.find((field) => field.name === expectedArg.name);
    if (!fieldConfig) {
      throw new Error(`Configuration missing for argument: ${expectedArg.name} in provided fields`);
    }
    let value;
    if (fieldConfig.isHardcoded) {
      value = fieldConfig.hardcodedValue;
    } else if (fieldConfig.isHidden) {
      throw new Error(`Field '${fieldConfig.name}' cannot be hidden without being hardcoded.`);
    } else {
      if (!(fieldConfig.name in submittedInputs)) {
        throw new Error(`Missing submitted input for required field: ${fieldConfig.name}`);
      }
      value = submittedInputs[fieldConfig.name];
    }
    orderedRawValues.push(value);
  }
  const transformedArgs = expectedArgs.map((param, index) => {
    let valueToParse = orderedRawValues[index];
    if (typeof param.type === "string" && param.type.endsWith("[]") && Array.isArray(valueToParse)) {
      valueToParse = JSON.stringify(valueToParse);
    }
    return parseEvmInput(param, valueToParse, false);
  });
  const isPayable = functionDetails.stateMutability === "payable";
  let transactionValue = 0n;
  if (isPayable) {
    logger13.warn(
      "formatEvmTransactionData",
      "Payable function detected, but sending 0 ETH. Implement value input."
    );
  }
  const functionAbiItem = createAbiFunctionItem(functionDetails);
  if (!contractSchema.address || !isAddress5(contractSchema.address)) {
    throw new Error("Contract address is missing or invalid in the provided schema.");
  }
  const paramsForSignAndBroadcast = {
    address: contractSchema.address,
    abi: [functionAbiItem],
    functionName: functionDetails.name,
    args: transformedArgs,
    value: transactionValue
    // Pass BigInt value
  };
  return paramsForSignAndBroadcast;
}
init_eoa2();
init_relayer();
var SYSTEM_LOG_TAG3 = "evm-core-sender";
async function executeEvmTransaction(transactionData, executionConfig, walletImplementation, onStatusChange, runtimeApiKey) {
  const method = executionConfig.method || "eoa";
  logger17.info(SYSTEM_LOG_TAG3, "executeEvmTransaction: Starting transaction execution", { method });
  const { EoaExecutionStrategy: EoaExecutionStrategy2 } = await Promise.resolve().then(() => (init_eoa2(), eoa_exports));
  const { RelayerExecutionStrategy: RelayerExecutionStrategy2 } = await Promise.resolve().then(() => (init_relayer(), relayer_exports));
  let strategy;
  switch (method) {
    case "eoa":
      strategy = new EoaExecutionStrategy2();
      break;
    case "relayer":
      strategy = new RelayerExecutionStrategy2();
      break;
    case "multisig":
      logger17.warn(SYSTEM_LOG_TAG3, "Multisig execution not yet implemented");
      throw new Error("Multisig execution is not yet supported.");
    default: {
      const exhaustiveCheck = method;
      throw new Error(`Unsupported execution method: ${exhaustiveCheck}`);
    }
  }
  return strategy.execute(
    transactionData,
    executionConfig,
    walletImplementation,
    onStatusChange,
    runtimeApiKey
  );
}
async function waitForEvmTransactionConfirmation(txHash, walletImplementation) {
  logger17.info(SYSTEM_LOG_TAG3, `Waiting for tx: ${txHash}`);
  try {
    const resolvedPublicClient = await walletImplementation.getPublicClient();
    if (!resolvedPublicClient) {
      throw new Error("Public client not available to wait for transaction.");
    }
    const receipt = await resolvedPublicClient.waitForTransactionReceipt({
      hash: txHash
    });
    logger17.info(SYSTEM_LOG_TAG3, "Received receipt:", receipt);
    if (receipt.status === "success") {
      return { status: "success", receipt };
    } else {
      logger17.error(SYSTEM_LOG_TAG3, "Transaction reverted:", receipt);
      return { status: "error", receipt, error: new Error("Transaction reverted.") };
    }
  } catch (error) {
    logger17.error(SYSTEM_LOG_TAG3, "Error waiting for transaction confirmation:", error);
    return {
      status: "error",
      error: error instanceof Error ? error : new Error(String(error))
    };
  }
}
var WagmiProviderInitializedContext = createContext(false);
var useIsWagmiProviderInitialized = () => {
  return useContext(WagmiProviderInitializedContext);
};
var SafeWagmiComponent = ({
  children,
  fallback = null
}) => {
  const isProviderInitialized = useIsWagmiProviderInitialized();
  const [hasError, setHasError] = useState(false);
  useEffect(() => {
    if (isProviderInitialized) {
      setHasError(false);
    }
  }, [isProviderInitialized]);
  useEffect(() => {
    const handleError = (event) => {
      if (event.error?.message?.includes("useConfig") || event.error?.message?.includes("WagmiProvider")) {
        logger18.debug(
          "SafeWagmiComponent",
          "Caught wagmi error via window error event:",
          event.error
        );
        setHasError(true);
        event.preventDefault();
      }
    };
    window.addEventListener("error", handleError);
    return () => {
      window.removeEventListener("error", handleError);
    };
  }, []);
  if (!isProviderInitialized || hasError) {
    return /* @__PURE__ */ jsx(Fragment, { children: fallback });
  }
  try {
    return /* @__PURE__ */ jsx(Fragment, { children });
  } catch (error) {
    if (error instanceof Error && (error.message.includes("useConfig") || error.message.includes("WagmiProvider"))) {
      logger18.debug("SafeWagmiComponent", "Caught wagmi error:", error);
      setHasError(true);
      return /* @__PURE__ */ jsx(Fragment, { children: fallback });
    }
    throw error;
  }
};
var ConnectorDialog = ({
  open,
  onOpenChange,
  showInjectedConnector = false
}) => {
  const unavailableContent = /* @__PURE__ */ jsx2(Dialog, { open, onOpenChange, children: /* @__PURE__ */ jsx2(DialogContent, { className: "sm:max-w-[425px]", children: /* @__PURE__ */ jsxs(DialogHeader, { children: [
    /* @__PURE__ */ jsx2(DialogTitle, { children: "Wallet Connection Unavailable" }),
    /* @__PURE__ */ jsx2(DialogDescription, { children: "The wallet connection system is not properly initialized." })
  ] }) }) });
  return /* @__PURE__ */ jsx2(SafeWagmiComponent, { fallback: unavailableContent, children: /* @__PURE__ */ jsx2(
    ConnectorDialogContent,
    {
      open,
      onOpenChange,
      showInjectedConnector
    }
  ) });
};
var ConnectorDialogContent = ({
  open,
  onOpenChange,
  showInjectedConnector = false
}) => {
  const { connect: connect2, connectors, error: connectError, isConnecting } = useDerivedConnectStatus();
  const { isConnected } = useDerivedAccountStatus();
  const [connectingId, setConnectingId] = useState2(null);
  useEffect2(() => {
    if (isConnected && connectingId) {
      onOpenChange(false);
      setConnectingId(null);
    }
  }, [isConnected, connectingId, onOpenChange]);
  if (!connect2) {
    return /* @__PURE__ */ jsx2(Dialog, { open, onOpenChange, children: /* @__PURE__ */ jsxs(DialogContent, { className: "sm:max-w-[425px]", children: [
      /* @__PURE__ */ jsx2(DialogHeader, { children: /* @__PURE__ */ jsx2(DialogTitle, { children: "Error" }) }),
      /* @__PURE__ */ jsx2("p", { children: "Wallet connection function is not available." })
    ] }) });
  }
  const handleConnectorSelect = (selectedConnector) => {
    setConnectingId(selectedConnector.id);
    connect2({ connector: selectedConnector });
  };
  const filteredConnectors = connectors.filter((connector) => {
    const isInjected = connector.id === "injected";
    return !(isInjected && !showInjectedConnector);
  });
  return /* @__PURE__ */ jsx2(Dialog, { open, onOpenChange, children: /* @__PURE__ */ jsxs(DialogContent, { className: "sm:max-w-[425px]", children: [
    /* @__PURE__ */ jsxs(DialogHeader, { children: [
      /* @__PURE__ */ jsx2(DialogTitle, { children: "Connect Wallet" }),
      /* @__PURE__ */ jsx2(DialogDescription, { children: "Select a wallet provider to connect with this application." })
    ] }),
    /* @__PURE__ */ jsx2("div", { className: "grid gap-4 py-4", children: filteredConnectors.length === 0 ? /* @__PURE__ */ jsx2("p", { className: "text-center text-muted-foreground", children: "No wallet connectors available." }) : filteredConnectors.map((connector) => /* @__PURE__ */ jsxs(
      Button,
      {
        onClick: () => handleConnectorSelect(connector),
        disabled: isConnecting && connectingId === connector.id,
        variant: "outline",
        className: "flex justify-between items-center w-full py-6",
        children: [
          /* @__PURE__ */ jsx2("span", { children: connector.name }),
          isConnecting && connectingId === connector.id && /* @__PURE__ */ jsx2("span", { className: "ml-2 text-xs", children: "Connecting..." })
        ]
      },
      connector.id
    )) }),
    connectError && /* @__PURE__ */ jsx2("p", { className: "text-sm text-red-500 mt-1", children: connectError.message || "Error connecting wallet" })
  ] }) });
};
var CustomConnectButton = ({
  className,
  size,
  variant,
  fullWidth,
  hideWhenConnected = true,
  showInjectedConnector = false
}) => {
  const [dialogOpen, setDialogOpen] = useState3(false);
  const sizeProps = getWalletButtonSizeProps(size);
  const unavailableButton = /* @__PURE__ */ jsx3("div", { className: cn("flex items-center", fullWidth && "w-full", className), children: /* @__PURE__ */ jsxs2(
    Button2,
    {
      disabled: true,
      variant: variant || "outline",
      size: sizeProps.size,
      className: cn(sizeProps.className, fullWidth && "w-full"),
      children: [
        /* @__PURE__ */ jsx3(Wallet, { className: cn(sizeProps.iconSize, "mr-1") }),
        "Wallet Unavailable"
      ]
    }
  ) });
  return /* @__PURE__ */ jsx3(SafeWagmiComponent, { fallback: unavailableButton, children: /* @__PURE__ */ jsx3(
    ConnectButtonContent,
    {
      className,
      size,
      variant,
      fullWidth,
      dialogOpen,
      setDialogOpen,
      hideWhenConnected,
      showInjectedConnector
    }
  ) });
};
var ConnectButtonContent = ({
  className,
  size,
  variant,
  fullWidth,
  dialogOpen,
  setDialogOpen,
  hideWhenConnected,
  showInjectedConnector
}) => {
  const { isConnected } = useDerivedAccountStatus2();
  const { isConnecting: isHookConnecting, error: connectError } = useDerivedConnectStatus2();
  const [isManuallyInitiated, setIsManuallyInitiated] = useState3(false);
  const sizeProps = getWalletButtonSizeProps(size);
  useEffect3(() => {
    if (isConnected && hideWhenConnected) {
      setDialogOpen(false);
      setIsManuallyInitiated(false);
    }
  }, [isConnected, hideWhenConnected, setDialogOpen]);
  useEffect3(() => {
    if (!dialogOpen) {
      setIsManuallyInitiated(false);
    }
  }, [dialogOpen]);
  useEffect3(() => {
    if (isHookConnecting) {
      setIsManuallyInitiated(false);
    }
  }, [isHookConnecting]);
  const handleConnectClick = () => {
    if (!isConnected) {
      setIsManuallyInitiated(true);
      setDialogOpen(true);
    }
  };
  if (isConnected && hideWhenConnected) {
    return null;
  }
  const showButtonLoading = isHookConnecting || isManuallyInitiated;
  return /* @__PURE__ */ jsxs2("div", { className: cn("flex items-center", fullWidth && "w-full", className), children: [
    /* @__PURE__ */ jsxs2(
      Button2,
      {
        onClick: handleConnectClick,
        disabled: showButtonLoading || isConnected,
        variant: variant || "outline",
        size: sizeProps.size,
        className: cn(sizeProps.className, fullWidth && "w-full"),
        title: isConnected ? "Connected" : connectError?.message || "Connect Wallet",
        children: [
          showButtonLoading ? /* @__PURE__ */ jsx3(Loader2, { className: cn(sizeProps.iconSize, "animate-spin mr-1") }) : /* @__PURE__ */ jsx3(Wallet, { className: cn(sizeProps.iconSize, "mr-1") }),
          showButtonLoading ? "Connecting..." : "Connect Wallet"
        ]
      }
    ),
    /* @__PURE__ */ jsx3(
      ConnectorDialog,
      {
        open: dialogOpen,
        onOpenChange: (open) => {
          setDialogOpen(open);
          if (!open) {
            setIsManuallyInitiated(false);
          }
        },
        showInjectedConnector
      }
    )
  ] });
};
var CustomAccountDisplay = ({
  className,
  size,
  variant,
  fullWidth
}) => {
  return /* @__PURE__ */ jsx4(SafeWagmiComponent, { fallback: null, children: /* @__PURE__ */ jsx4(
    AccountDisplayContent,
    {
      className,
      size,
      variant,
      fullWidth
    }
  ) });
};
var AccountDisplayContent = ({
  className,
  size,
  variant,
  fullWidth
}) => {
  const { isConnected, address, chainId } = useDerivedAccountStatus3();
  const { disconnect: disconnect2 } = useDerivedDisconnect();
  const sizeProps = getWalletAccountDisplaySizeProps(size);
  if (!isConnected || !address || !disconnect2) {
    return null;
  }
  return /* @__PURE__ */ jsxs3("div", { className: cn2("flex items-center gap-2", fullWidth && "w-full", className), children: [
    /* @__PURE__ */ jsxs3("div", { className: cn2("flex flex-col", fullWidth && "flex-1"), children: [
      /* @__PURE__ */ jsx4("span", { className: cn2(sizeProps.textSize, "font-medium"), children: truncateMiddle(address, 4, 4) }),
      /* @__PURE__ */ jsx4("span", { className: cn2(sizeProps.subTextSize, "text-muted-foreground -mt-0.5"), children: chainId ? `Chain ID: ${chainId}` : "Chain ID: N/A" })
    ] }),
    /* @__PURE__ */ jsx4(
      Button3,
      {
        onClick: () => disconnect2(),
        variant: variant || "ghost",
        size: "icon",
        className: cn2(sizeProps.iconButtonSize, "p-0"),
        title: "Disconnect wallet",
        children: /* @__PURE__ */ jsx4(LogOut, { className: sizeProps.iconSize })
      }
    )
  ] });
};
var CustomNetworkSwitcher = ({
  className,
  size,
  variant,
  fullWidth
}) => {
  return /* @__PURE__ */ jsx5(SafeWagmiComponent, { fallback: null, children: /* @__PURE__ */ jsx5(
    NetworkSwitcherContent,
    {
      className,
      size,
      variant,
      fullWidth
    }
  ) });
};
var NetworkSwitcherContent = ({
  className,
  size,
  variant,
  fullWidth
}) => {
  const { isConnected } = useDerivedAccountStatus4();
  const { currentChainId, availableChains: unknownChains } = useDerivedChainInfo();
  const { switchChain: switchChain2, isSwitching: isPending, error } = useDerivedSwitchChainStatus();
  const sizeProps = getWalletNetworkSwitcherSizeProps(size);
  const variantClassName = getWalletNetworkSwitcherVariantClassName(variant);
  const typedAvailableChains = unknownChains;
  if (!isConnected || !switchChain2 || typedAvailableChains.length === 0) {
    return null;
  }
  const handleNetworkChange = (chainId) => {
    if (chainId !== currentChainId) {
      switchChain2({ chainId });
    }
  };
  const currentChain = typedAvailableChains.find((chain) => chain.id === currentChainId);
  const currentChainName = currentChain?.name || "Network";
  return /* @__PURE__ */ jsxs4("div", { className: cn3("flex items-center", fullWidth && "w-full", className), children: [
    /* @__PURE__ */ jsxs4(
      Select,
      {
        value: currentChainId?.toString() ?? "",
        onValueChange: (value) => handleNetworkChange(Number(value)),
        disabled: isPending || typedAvailableChains.length === 0,
        children: [
          /* @__PURE__ */ jsx5(
            SelectTrigger,
            {
              className: cn3(
                sizeProps.triggerClassName,
                variantClassName,
                fullWidth && "w-full max-w-none"
              ),
              children: /* @__PURE__ */ jsx5(SelectValue, { placeholder: "Network", children: currentChainName })
            }
          ),
          /* @__PURE__ */ jsx5(
            SelectContent,
            {
              position: "popper",
              sideOffset: 5,
              align: "start",
              className: "w-auto min-w-[160px] max-h-[300px]",
              children: typedAvailableChains.map((chain) => /* @__PURE__ */ jsx5(
                SelectItem,
                {
                  value: chain.id.toString(),
                  className: sizeProps.itemClassName,
                  children: chain.name
                },
                chain.id
              ))
            }
          )
        ]
      }
    ),
    isPending && /* @__PURE__ */ jsx5("span", { className: "text-muted-foreground ml-2", children: /* @__PURE__ */ jsx5(Loader22, { className: cn3(sizeProps.loaderSize, "animate-spin") }) }),
    error && /* @__PURE__ */ jsx5("span", { className: "text-xs text-red-500 ml-2", children: "!" })
  ] });
};
var DEFAULT_DISCONNECTED_STATUS = {
  isConnected: false,
  isConnecting: false,
  isDisconnected: true,
  isReconnecting: false,
  status: "disconnected",
  address: void 0,
  addresses: void 0,
  chainId: void 0,
  chain: void 0,
  connector: void 0
};
async function connectAndEnsureCorrectNetworkCore(impl, connectorId, targetChainId, logSystem) {
  const connectionResult = await impl.connect(connectorId);
  if (!connectionResult.connected || !connectionResult.address || !connectionResult.chainId) {
    return { connected: false, error: connectionResult.error || "Connection failed" };
  }
  if (connectionResult.chainId !== targetChainId) {
    logger19.info(
      logSystem,
      `Connected to chain ${connectionResult.chainId}, but target is ${targetChainId}. Attempting switch.`
    );
    try {
      await impl.switchNetwork(targetChainId);
      const postSwitchStatus = impl.getWalletConnectionStatus();
      if (postSwitchStatus.chainId !== targetChainId) {
        const switchError = `Failed to switch to target network ${targetChainId}. Current: ${postSwitchStatus.chainId}`;
        logger19.error(logSystem, switchError);
        try {
          await impl.disconnect();
        } catch (e) {
          logger19.warn(logSystem, "Failed to disconnect after network switch failure.", e);
        }
        return { connected: false, error: switchError };
      }
      logger19.info(logSystem, `Successfully switched to target chain ${targetChainId}.`);
      return { ...connectionResult, chainId: postSwitchStatus.chainId };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger19.error(logSystem, "Network switch failed:", errorMessage);
      try {
        await impl.disconnect();
      } catch (e) {
        logger19.warn(logSystem, "Failed to disconnect after network switch failure.", e);
      }
      return { connected: false, error: `Network switch failed: ${errorMessage}` };
    }
  }
  return connectionResult;
}
init_artifacts();
async function validateEvmNetworkServiceConfig(serviceId, values) {
  if (serviceId === "rpc") {
    const cfg = { url: String(values.rpcUrl || ""), isCustom: true };
    return validateEvmRpcEndpoint(cfg);
  }
  if (serviceId === "explorer") {
    const cfg = {
      explorerUrl: values.explorerUrl ? String(values.explorerUrl) : void 0,
      apiUrl: values.apiUrl ? String(values.apiUrl) : void 0,
      apiKey: values.apiKey ? String(values.apiKey) : void 0,
      isCustom: true,
      applyToAllNetworks: Boolean(values.applyToAllNetworks)
    };
    return validateEvmExplorerConfig(cfg);
  }
  if (serviceId === "contract-definitions") {
    const raw = values.defaultProvider;
    if (raw === void 0 || raw === null || raw === "") return true;
    return isEvmProviderKey(raw);
  }
  return true;
}
async function testEvmNetworkServiceConnection(serviceId, values, networkConfig) {
  if (serviceId === "rpc") {
    const cfg = { url: String(values.rpcUrl || ""), isCustom: true };
    return testEvmRpcConnection(cfg);
  }
  if (serviceId === "explorer") {
    const cfg = {
      explorerUrl: values.explorerUrl ? String(values.explorerUrl) : void 0,
      apiUrl: values.apiUrl ? String(values.apiUrl) : void 0,
      apiKey: values.apiKey ? String(values.apiKey) : void 0,
      isCustom: true,
      applyToAllNetworks: Boolean(values.applyToAllNetworks)
    };
    return testEvmExplorerConnection(cfg, networkConfig);
  }
  return { success: true };
}
function getSupportedChainsFromNetworks(networkConfigs, logSystem) {
  const chains = networkConfigs.filter((network) => network.viemChain).map((network) => network.viemChain).filter((chain, index, self) => self.findIndex((c) => c.id === chain.id) === index);
  logger20.info(
    logSystem,
    `Generated supported chains from network configurations: ${chains.length} chains`,
    chains.map((c) => ({ id: c.id, name: c.name }))
  );
  return chains;
}
function getChainIdToNetworkIdMapping(networkConfigs, logSystem) {
  const mapping = networkConfigs.filter((network) => network.viemChain).reduce(
    (acc, network) => {
      acc[network.chainId] = network.id;
      return acc;
    },
    {}
  );
  logger20.info(
    logSystem,
    "Generated chain ID to network ID mapping from network configurations:",
    mapping
  );
  return mapping;
}
var WagmiWalletImplementation = class {
  /**
   * Constructs the WagmiWalletImplementation.
   * Configuration for Wagmi is deferred until actually needed or set externally.
   *
   * @param config - Configuration options for the wallet implementation
   */
  constructor(config) {
    __publicField2(this, "defaultInstanceConfig", null);
    __publicField2(this, "activeWagmiConfig", null);
    __publicField2(this, "unsubscribe");
    __publicField2(this, "initialized", false);
    __publicField2(this, "walletConnectProjectId");
    __publicField2(this, "rpcConfigUnsubscribe");
    __publicField2(this, "supportedChains");
    __publicField2(this, "chainIdToNetworkId");
    __publicField2(this, "logSystem");
    __publicField2(this, "rainbowKitConfigFn");
    this.logSystem = config.logSystem ?? "WagmiWalletImplementation";
    this.walletConnectProjectId = config.walletConnectProjectId;
    this.supportedChains = config.chains.length > 0 ? config.chains : getSupportedChainsFromNetworks(config.networkConfigs, this.logSystem);
    this.chainIdToNetworkId = getChainIdToNetworkIdMapping(config.networkConfigs, this.logSystem);
    logger20.info(
      this.logSystem,
      "Constructor called. Initial anticipated kitName:",
      config.initialUiKitConfig?.kitName
    );
    this.initialized = true;
    logger20.info(
      this.logSystem,
      "WagmiWalletImplementation instance initialized (Wagmi config creation deferred)."
    );
    this.setupRpcConfigListener();
  }
  /**
   * Sets the RainbowKit config retrieval function.
   * This allows adapters to inject their own RainbowKit integration.
   *
   * @param fn - Function to get RainbowKit wagmi config
   */
  setRainbowKitConfigFn(fn) {
    this.rainbowKitConfigFn = fn;
  }
  /**
   * Gets the supported chains for this implementation.
   */
  getSupportedChains() {
    return this.supportedChains;
  }
  /**
   * Gets the chain ID to network ID mapping.
   */
  getChainIdToNetworkIdMapping() {
    return this.chainIdToNetworkId;
  }
  /**
   * Sets up a listener for RPC configuration changes to invalidate the cached Wagmi config
   * when user changes RPC settings.
   */
  setupRpcConfigListener() {
    import("@openzeppelin/ui-utils").then(({ userRpcConfigService }) => {
      this.rpcConfigUnsubscribe = userRpcConfigService.subscribe("*", (event) => {
        if (event.type === "rpc-config-changed" || event.type === "rpc-config-cleared") {
          logger20.info(
            this.logSystem,
            `RPC config changed for network ${event.networkId}. Invalidating cached Wagmi config.`
          );
          this.defaultInstanceConfig = null;
        }
      });
    }).catch((error) => {
      logger20.error(this.logSystem, "Failed to setup RPC config listener:", error);
    });
  }
  /**
   * Cleanup method to unsubscribe from RPC config changes
   */
  cleanup() {
    if (this.rpcConfigUnsubscribe) {
      this.rpcConfigUnsubscribe();
      this.rpcConfigUnsubscribe = void 0;
    }
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = void 0;
    }
  }
  /**
   * Sets the externally determined, currently active WagmiConfig instance.
   * This is typically called by UiKitManager after it has resolved the appropriate
   * config for the selected UI kit (e.g., RainbowKit's config or a default custom config).
   *
   * @param config - The Wagmi Config object to set as active, or null to clear it.
   */
  setActiveWagmiConfig(config) {
    logger20.info(
      this.logSystem,
      "setActiveWagmiConfig called with config:",
      config ? "Valid Config" : "Null"
    );
    this.activeWagmiConfig = config;
    if (this.unsubscribe) {
      logger20.warn(
        this.logSystem,
        "setActiveWagmiConfig: Active WagmiConfig instance has changed. Existing direct watchAccount subscription (via onWalletConnectionChange) may be stale and operating on an old config instance."
      );
    }
  }
  /**
   * Checks if an active wagmi config has been set.
   * Subclasses can use this to determine if the wallet is ready for operations.
   *
   * @returns true if an active wagmi config is set
   */
  hasActiveConfig() {
    return this.activeWagmiConfig !== null;
  }
  /**
   * Creates a default WagmiConfig instance on demand.
   * This configuration includes standard connectors (injected, MetaMask, Safe)
   * and WalletConnect if a project ID is available.
   * Used as a fallback or for 'custom' UI kit mode.
   *
   * @returns A Wagmi Config object.
   */
  createDefaultConfig() {
    const baseConnectors = [injected(), metaMask(), safe()];
    if (this.walletConnectProjectId?.trim()) {
      baseConnectors.push(walletConnect({ projectId: this.walletConnectProjectId }));
      logger20.info(this.logSystem, "WalletConnect connector added to DEFAULT config.");
    } else {
      logger20.warn(
        this.logSystem,
        "WalletConnect Project ID not provided; WC connector unavailable for DEFAULT config."
      );
    }
    const transportsConfig = this.supportedChains.reduce(
      (acc, chainDefinition) => {
        let rpcUrlToUse = chainDefinition.rpcUrls.default?.http?.[0];
        const appNetworkIdString = this.chainIdToNetworkId[chainDefinition.id];
        if (appNetworkIdString) {
          let httpRpcOverride = getUserRpcUrl(appNetworkIdString);
          if (!httpRpcOverride) {
            const rpcOverrideSetting = appConfigService4.getRpcEndpointOverride(appNetworkIdString);
            if (typeof rpcOverrideSetting === "string") {
              httpRpcOverride = rpcOverrideSetting;
            } else if (typeof rpcOverrideSetting === "object") {
              if ("http" in rpcOverrideSetting && rpcOverrideSetting.http) {
                httpRpcOverride = rpcOverrideSetting.http;
              } else if ("url" in rpcOverrideSetting && rpcOverrideSetting.url) {
                httpRpcOverride = rpcOverrideSetting.url;
              }
            }
          }
          if (httpRpcOverride) {
            logger20.info(
              this.logSystem,
              `Using overridden RPC for chain ${chainDefinition.name} (default config): ${httpRpcOverride}`
            );
            rpcUrlToUse = httpRpcOverride;
          }
        }
        acc[chainDefinition.id] = http3(rpcUrlToUse);
        return acc;
      },
      {}
    );
    try {
      const defaultConfig2 = createConfig({
        chains: this.supportedChains,
        connectors: baseConnectors,
        transports: transportsConfig
      });
      logger20.info(this.logSystem, "Default Wagmi config created successfully on demand.");
      return defaultConfig2;
    } catch (error) {
      logger20.error(this.logSystem, "Error creating default Wagmi config on demand:", error);
      return createConfig({
        chains: [this.supportedChains[0]],
        connectors: [injected()],
        transports: { [this.supportedChains[0].id]: http3() }
      });
    }
  }
  /**
   * Wrapper function to convert AppConfigService RPC overrides to the format expected by RainbowKit.
   *
   * @param networkId - The network ID to get RPC override for
   * @returns RPC configuration in the format expected by RainbowKit
   */
  getRpcOverrideForRainbowKit(networkId) {
    const userRpcUrl = getUserRpcUrl(networkId);
    if (userRpcUrl) {
      return { http: userRpcUrl };
    }
    const rpcOverrideSetting = appConfigService4.getRpcEndpointOverride(networkId);
    if (typeof rpcOverrideSetting === "string") {
      return rpcOverrideSetting;
    } else if (typeof rpcOverrideSetting === "object" && rpcOverrideSetting !== null) {
      if ("url" in rpcOverrideSetting && typeof rpcOverrideSetting.url === "string") {
        return {
          http: rpcOverrideSetting.url
        };
      } else if ("http" in rpcOverrideSetting || "ws" in rpcOverrideSetting) {
        const config = rpcOverrideSetting;
        return {
          http: config.http,
          ws: config.ws
        };
      }
    }
    return void 0;
  }
  /**
   * Retrieves or creates the WagmiConfig specifically for RainbowKit.
   * This delegates to the injected RainbowKit config function if available.
   *
   * @param currentAdapterUiKitConfig - The fully resolved UI kit configuration for the adapter.
   * @returns A Promise resolving to the RainbowKit-specific Wagmi Config object, or null if creation fails or not RainbowKit.
   */
  async getConfigForRainbowKit(currentAdapterUiKitConfig) {
    if (!this.initialized) {
      logger20.error(
        this.logSystem,
        "getConfigForRainbowKit called before implementation initialization."
      );
      return null;
    }
    if (currentAdapterUiKitConfig?.kitName !== "rainbowkit") {
      logger20.warn(
        this.logSystem,
        "getConfigForRainbowKit called, but kitName is not rainbowkit. Returning null."
      );
      return null;
    }
    logger20.info(
      this.logSystem,
      "getConfigForRainbowKit: Kit is RainbowKit. Proceeding to create/get config. CurrentAdapterUiKitConfig:",
      currentAdapterUiKitConfig
    );
    if (this.rainbowKitConfigFn) {
      const rainbowKitWagmiConfig = await this.rainbowKitConfigFn(
        currentAdapterUiKitConfig,
        this.supportedChains,
        this.chainIdToNetworkId,
        this.getRpcOverrideForRainbowKit.bind(this)
      );
      if (rainbowKitWagmiConfig) {
        logger20.info(this.logSystem, "Returning RainbowKit-specific Wagmi config for provider.");
        return rainbowKitWagmiConfig;
      }
    }
    logger20.warn(this.logSystem, "RainbowKit specific Wagmi config creation failed.");
    return null;
  }
  /**
   * Determines and returns the WagmiConfig to be used by UiKitManager during its configuration process.
   * If RainbowKit is specified in the passed uiKitConfig, it attempts to get its specific config.
   * Otherwise, it falls back to creating/returning a default instance config.
   *
   * @param uiKitConfig - The fully resolved UiKitConfiguration that the manager is currently processing.
   * @returns A Promise resolving to the determined Wagmi Config object.
   */
  async getActiveConfigForManager(uiKitConfig2) {
    if (!this.initialized) {
      logger20.error(
        this.logSystem,
        "getActiveConfigForManager called before initialization! Creating fallback."
      );
      return createConfig({
        chains: [this.supportedChains[0]],
        transports: { [this.supportedChains[0].id]: http3() }
      });
    }
    if (uiKitConfig2?.kitName === "rainbowkit") {
      const rkConfig = await this.getConfigForRainbowKit(uiKitConfig2);
      if (rkConfig) return rkConfig;
      logger20.warn(
        this.logSystem,
        "getActiveConfigForManager: RainbowKit config failed, falling back to default."
      );
    }
    if (!this.defaultInstanceConfig) {
      this.defaultInstanceConfig = this.createDefaultConfig();
    }
    return this.defaultInstanceConfig;
  }
  /**
   * @deprecated Prefer using methods that rely on the externally set `activeWagmiConfig`
   * or methods that determine contextually appropriate config like `getActiveConfigForManager` (for manager use)
   * or ensure `activeWagmiConfig` is set before calling wagmi actions.
   * This method returns the internally cached default config or the active one if set.
   *
   * @returns The current default or active Wagmi Config object.
   */
  getConfig() {
    logger20.warn(
      this.logSystem,
      "getConfig() is deprecated. Internal calls should use activeWagmiConfig if set, or ensure default is created."
    );
    if (this.activeWagmiConfig) return this.activeWagmiConfig;
    if (!this.defaultInstanceConfig) {
      this.defaultInstanceConfig = this.createDefaultConfig();
    }
    return this.defaultInstanceConfig;
  }
  /**
   * Gets the current wallet connection status (isConnected, address, chainId, etc.).
   * This is a synchronous operation and uses the `activeWagmiConfig` if set by `UiKitManager`,
   * otherwise falls back to the default instance config (created on demand).
   *
   * @returns The current account status from Wagmi.
   */
  getWalletConnectionStatus() {
    logger20.debug(this.logSystem, "getWalletConnectionStatus called.");
    const configToUse = this.activeWagmiConfig || this.defaultInstanceConfig || (this.defaultInstanceConfig = this.createDefaultConfig());
    if (!configToUse) {
      logger20.error(this.logSystem, "No config available for getWalletConnectionStatus!");
      return {
        isConnected: false,
        isConnecting: false,
        isDisconnected: true,
        isReconnecting: false,
        status: "disconnected",
        address: void 0,
        addresses: void 0,
        chainId: void 0,
        chain: void 0,
        connector: void 0
      };
    }
    return getAccount(configToUse);
  }
  /**
   * Subscribes to account and connection status changes from Wagmi.
   * The subscription is bound to the `activeWagmiConfig` if available at the time of call,
   * otherwise to the default instance config.
   *
   * @param callback - Function to call when connection status changes.
   * @returns A function to unsubscribe from the changes.
   */
  onWalletConnectionChange(callback) {
    if (!this.initialized) {
      logger20.warn(this.logSystem, "onWalletConnectionChange called before initialization. No-op.");
      return () => {
      };
    }
    if (this.unsubscribe) {
      this.unsubscribe();
      logger20.debug(this.logSystem, "Previous watchAccount unsubscribed.");
    }
    const configToUse = this.activeWagmiConfig || this.defaultInstanceConfig || (this.defaultInstanceConfig = this.createDefaultConfig());
    if (!configToUse) {
      logger20.error(
        this.logSystem,
        "No config available for onWalletConnectionChange! Subscription not set."
      );
      return () => {
      };
    }
    this.unsubscribe = watchAccount(configToUse, { onChange: callback });
    logger20.info(
      this.logSystem,
      "watchAccount subscription established/re-established using config:",
      configToUse === this.activeWagmiConfig ? "activeExternal" : "defaultInstance"
    );
    return this.unsubscribe;
  }
  /**
   * Gets the Viem Wallet Client for the currently connected account and chain.
   *
   * @returns A Promise resolving to the Viem WalletClient or null if not connected.
   */
  async getWalletClient() {
    if (!this.initialized || !this.activeWagmiConfig) {
      logger20.warn(
        this.logSystem,
        "getWalletClient: Not initialized or no activeWagmiConfig. Returning null."
      );
      return null;
    }
    const accountStatus = getAccount(this.activeWagmiConfig);
    if (!accountStatus.isConnected || !accountStatus.chainId || !accountStatus.address) {
      return null;
    }
    return getWagmiWalletClient(this.activeWagmiConfig, {
      chainId: accountStatus.chainId,
      account: accountStatus.address
    });
  }
  /**
   * Gets the Viem Public Client for the currently connected chain.
   *
   * @returns A Promise resolving to the Viem PublicClient or null.
   */
  async getPublicClient() {
    if (!this.initialized || !this.activeWagmiConfig) {
      logger20.warn(
        this.logSystem,
        "getPublicClient: Not initialized or no activeWagmiConfig. Returning null."
      );
      return null;
    }
    const accountStatus = getAccount(this.activeWagmiConfig);
    const currentChainId = accountStatus.chainId;
    if (!currentChainId) {
      logger20.warn(
        this.logSystem,
        "getPublicClient: No connected chainId available from accountStatus. Returning null."
      );
      return null;
    }
    try {
      const publicClient = getWagmiCorePublicClient(this.activeWagmiConfig, {
        chainId: currentChainId
      });
      if (publicClient) {
        logger20.info(
          this.logSystem,
          `getPublicClient: Successfully retrieved public client for chainId ${currentChainId}.`
        );
        return publicClient;
      }
      logger20.warn(
        this.logSystem,
        `getPublicClient: getWagmiCorePublicClient returned undefined/null for chainId ${currentChainId}.`
      );
      return null;
    } catch (error) {
      logger20.error(this.logSystem, "Error getting public client from wagmi/core:", error);
      return null;
    }
  }
  /**
   * Gets the list of available wallet connectors from the active Wagmi config.
   *
   * @returns A Promise resolving to an array of available connectors.
   */
  async getAvailableConnectors() {
    if (!this.initialized || !this.activeWagmiConfig) return [];
    return this.activeWagmiConfig.connectors.map((co) => ({ id: co.uid, name: co.name }));
  }
  /**
   * Initiates the connection process for a specific connector.
   *
   * @param connectorId - The ID of the connector to use.
   * @returns A Promise with connection result including address and chainId if successful.
   */
  async connect(connectorId) {
    if (!this.initialized || !this.activeWagmiConfig) {
      throw new Error("Wallet not initialized or no active config");
    }
    const connectorToUse = this.activeWagmiConfig.connectors.find(
      (cn52) => cn52.id === connectorId || cn52.uid === connectorId
    );
    if (!connectorToUse) {
      throw new Error(`Connector ${connectorId} not found`);
    }
    const res = await connect(this.activeWagmiConfig, { connector: connectorToUse });
    return { connected: true, address: res.accounts[0], chainId: res.chainId };
  }
  /**
   * Disconnects the currently connected wallet.
   *
   * @returns A Promise with disconnection result.
   */
  async disconnect() {
    if (!this.initialized || !this.activeWagmiConfig) {
      return { disconnected: false, error: "Wallet not initialized or no active config" };
    }
    await disconnect(this.activeWagmiConfig);
    return { disconnected: true };
  }
  /**
   * Prompts the user to switch to the specified network.
   *
   * @param chainId - The target chain ID to switch to.
   * @returns A Promise that resolves if the switch is successful, or rejects with an error.
   */
  async switchNetwork(chainId) {
    if (!this.initialized || !this.activeWagmiConfig) {
      throw new Error("Wallet not initialized or no active config");
    }
    await switchChain(this.activeWagmiConfig, { chainId });
  }
};
var DEFAULT_OPTIONS = {
  defaultAppName: "My RainbowKit App",
  headerComment: `// RainbowKit configuration for your exported application
// This file is used ONLY in the exported app, not in the builder app preview`
};
function generateRainbowKitConfigFile(userConfig, options = {}) {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const config = userConfig || {};
  const appName = config.appName || opts.defaultAppName;
  const learnMoreUrl = config.learnMoreUrl || "https://openzeppelin.com";
  const projectId = config.projectId || "YOUR_PROJECT_ID";
  const appInfoLines = [`appName: '${appName}'`];
  if (learnMoreUrl) {
    appInfoLines.push(`learnMoreUrl: '${learnMoreUrl}'`);
  }
  const appInfoContent = appInfoLines.join(",\n      ");
  const fileContent = `${opts.headerComment}

// Uncomment imports as needed:
// import { darkTheme, lightTheme } from '@rainbow-me/rainbowkit';

const rainbowKitAppConfig = {
  wagmiParams: {
    appName: '${appName}',
    projectId: '${projectId}', // Get yours at https://cloud.walletconnect.com
    
    // Additional options:
    // ssr: true,
    // wallets: [...],
  },
  providerProps: {
    appInfo: {
      ${appInfoContent}
    },
    
    // UI customization - all features work in exported apps:
    // theme: darkTheme(),
    // modalSize: 'compact',
    // showRecentTransactions: true,
    // coolMode: true,
  },
};

export default rainbowKitAppConfig;`;
  return fileContent;
}
function generateRainbowKitExportables(uiKitConfig2, options = {}) {
  const filePath = "src/config/wallet/rainbowkit.config.ts";
  const content = uiKitConfig2.customCode || generateRainbowKitConfigFile(uiKitConfig2.kitConfig, options);
  return { [filePath]: content };
}
function isRainbowKitCustomizations(obj) {
  return typeof obj === "object" && obj !== null && "connectButton" in obj;
}
function extractRainbowKitCustomizations(kitConfig) {
  if (!kitConfig || !kitConfig.customizations) {
    return void 0;
  }
  const customizations = kitConfig.customizations;
  return isRainbowKitCustomizations(customizations) ? customizations : void 0;
}
function validateRainbowKitConfig(kitConfig) {
  logger21.debug(
    "validateRainbowKitConfig",
    "Received kitConfig for validation:",
    JSON.stringify(kitConfig)
  );
  if (!kitConfig) {
    logger21.warn("validateRainbowKitConfig", "Validation failed: No kitConfig provided.");
    return { isValid: false, error: "No kitConfig provided for RainbowKit" };
  }
  const wagmiParamsFromKitConfig = kitConfig.wagmiParams;
  if (!wagmiParamsFromKitConfig || typeof wagmiParamsFromKitConfig !== "object" || wagmiParamsFromKitConfig === null) {
    logger21.warn(
      "validateRainbowKitConfig",
      "Validation failed: kitConfig.wagmiParams is missing or invalid.",
      { wagmiParamsFromKitConfig }
    );
    return { isValid: false, error: "kitConfig.wagmiParams is missing or not a valid object" };
  }
  const missingFields = [];
  if (!("appName" in wagmiParamsFromKitConfig) || typeof wagmiParamsFromKitConfig.appName !== "string") {
    missingFields.push("wagmiParams.appName");
  }
  if (!("projectId" in wagmiParamsFromKitConfig) || typeof wagmiParamsFromKitConfig.projectId !== "string") {
    missingFields.push("wagmiParams.projectId");
  }
  if (missingFields.length > 0) {
    const errorMsg = `Missing or invalid required fields in wagmiParams: ${missingFields.join(", ")}`;
    logger21.warn("validateRainbowKitConfig", "Validation failed:", errorMsg, { missingFields });
    return {
      isValid: false,
      missingFields,
      error: errorMsg
    };
  }
  logger21.debug("validateRainbowKitConfig", "Validation successful.");
  return { isValid: true };
}
var MIN_COMPONENT_LOADING_DISPLAY_MS = 1e3;
function createRainbowKitConnectButton(uiKitManager) {
  const RainbowKitConnectButtonComponent = (props) => {
    const [Component, setComponent] = useState4(null);
    const [error, setError] = useState4(null);
    const [isLoadingComponent, setIsLoadingComponent] = useState4(true);
    const [showComponentLoadingOverride, setShowComponentLoadingOverride] = useState4(false);
    const componentLoadingTimerRef = useRef(null);
    const [managerState, setManagerState] = useState4(uiKitManager.getState());
    const isWagmiProviderReady = useContext2(WagmiProviderInitializedContext);
    useEffect4(() => {
      const unsubscribe = uiKitManager.subscribe(() => {
        setManagerState(uiKitManager.getState());
      });
      return unsubscribe;
    }, []);
    useEffect4(() => {
      let isMounted = true;
      setIsLoadingComponent(true);
      setShowComponentLoadingOverride(true);
      if (componentLoadingTimerRef.current) {
        clearTimeout(componentLoadingTimerRef.current);
      }
      componentLoadingTimerRef.current = setTimeout(() => {
        if (isMounted) {
          setShowComponentLoadingOverride(false);
        }
        componentLoadingTimerRef.current = null;
      }, MIN_COMPONENT_LOADING_DISPLAY_MS);
      const loadComponent = async () => {
        try {
          const rainbowKit = await import("@rainbow-me/rainbowkit");
          if (isMounted) {
            setComponent(() => rainbowKit.ConnectButton);
            setIsLoadingComponent(false);
          }
        } catch (err) {
          if (isMounted) {
            setError(err instanceof Error ? err : new Error(String(err)));
            setIsLoadingComponent(false);
            logger22.error(
              "RainbowKitConnectButton",
              "Failed to load RainbowKit ConnectButton:",
              err
            );
          }
        }
      };
      loadComponent();
      return () => {
        isMounted = false;
        if (componentLoadingTimerRef.current) {
          clearTimeout(componentLoadingTimerRef.current);
        }
      };
    }, []);
    const sizeProps = getWalletButtonSizeProps2(props.size);
    const renderLoadingPlaceholder = (message) => /* @__PURE__ */ jsxs5(
      Button4,
      {
        disabled: true,
        variant: props.variant || "outline",
        size: sizeProps.size,
        className: cn4(sizeProps.className, props.fullWidth && "w-full", props.className),
        children: [
          /* @__PURE__ */ jsx6(Loader23, { className: cn4(sizeProps.iconSize, "animate-spin mr-1.5") }),
          message
        ]
      }
    );
    if (error) {
      logger22.warn(
        "RainbowKitConnectButton",
        "Error loading RainbowKit ConnectButton. Displaying fallback CustomConnectButton."
      );
      return /* @__PURE__ */ jsx6(CustomConnectButton, { ...props });
    }
    if (isLoadingComponent || showComponentLoadingOverride) {
      return renderLoadingPlaceholder("Loading Wallet...");
    }
    if (!isWagmiProviderReady) {
      return renderLoadingPlaceholder("Initializing Provider...");
    }
    if (!Component) {
      logger22.warn(
        "RainbowKitConnectButton",
        "Component is null after loading phase, falling back."
      );
      return /* @__PURE__ */ jsx6(CustomConnectButton, { ...props });
    }
    const kitConfig = managerState.currentFullUiKitConfig?.kitConfig;
    const customizations = extractRainbowKitCustomizations(kitConfig);
    const connectButtonConfig = customizations?.connectButton;
    const finalProps = {
      ...connectButtonConfig,
      // Apply custom configuration from config
      ...props
      // Allow props to override configuration
    };
    logger22.debug("RainbowKitConnectButton", "Rendering with configuration:", {
      configFromFile: connectButtonConfig,
      finalProps
    });
    return /* @__PURE__ */ jsx6(Component, { ...finalProps });
  };
  RainbowKitConnectButtonComponent.displayName = "RainbowKitConnectButton";
  return RainbowKitConnectButtonComponent;
}
function createRainbowKitComponents(RainbowKitConnectButton2) {
  return {
    ConnectButton: RainbowKitConnectButton2
    // RainbowKit's ConnectButton is comprehensive and typically includes account display
    // So we don't provide separate AccountDisplay or NetworkSwitcher components
  };
}
var LOG_PREFIX = "rainbowkit/config-service";
async function createRainbowKitWagmiConfig(userFullNativeConfig, chains, chainIdToNetworkIdMap, getRpcEndpointOverride) {
  try {
    const { getDefaultConfig } = await import("@rainbow-me/rainbowkit");
    if (!getDefaultConfig) {
      logger23.error(LOG_PREFIX, "Failed to import getDefaultConfig from RainbowKit");
      return null;
    }
    const wagmiParams = userFullNativeConfig?.wagmiParams;
    if (!wagmiParams) {
      logger23.warn(
        LOG_PREFIX,
        "Resolved kitConfig does not contain a `wagmiParams` object. Cannot create RainbowKit Wagmi config."
      );
      return null;
    }
    if (typeof wagmiParams.appName !== "string" || !wagmiParams.appName) {
      logger23.warn(LOG_PREFIX, "kitConfig.wagmiParams is missing or has invalid `appName`.");
      return null;
    }
    if (typeof wagmiParams.projectId !== "string" || !wagmiParams.projectId) {
      logger23.warn(LOG_PREFIX, "kitConfig.wagmiParams is missing or has invalid `projectId`.");
      return null;
    }
    const transportsConfig = chains.reduce(
      (acc, chainDefinition) => {
        let rpcUrlToUse = chainDefinition.rpcUrls.default?.http?.[0];
        const appNetworkIdString = chainIdToNetworkIdMap[chainDefinition.id];
        if (appNetworkIdString) {
          const rpcOverrideSetting = getRpcEndpointOverride(appNetworkIdString);
          let httpRpcOverride;
          if (typeof rpcOverrideSetting === "string") {
            httpRpcOverride = rpcOverrideSetting;
          } else if (typeof rpcOverrideSetting === "object" && rpcOverrideSetting) {
            if ("http" in rpcOverrideSetting && rpcOverrideSetting.http) {
              httpRpcOverride = rpcOverrideSetting.http;
            } else if ("url" in rpcOverrideSetting && rpcOverrideSetting.url) {
              httpRpcOverride = rpcOverrideSetting.url;
            }
          }
          if (httpRpcOverride) {
            logger23.info(
              LOG_PREFIX,
              `Using overridden RPC for chain ${chainDefinition.name}: ${httpRpcOverride}`
            );
            rpcUrlToUse = httpRpcOverride;
          }
        }
        acc[chainDefinition.id] = http4(rpcUrlToUse);
        return acc;
      },
      {}
    );
    const finalConfigOptions = {
      ...wagmiParams,
      // User's native params (appName, projectId, wallets, ssr, etc.)
      chains,
      // Adapter controls this
      transports: transportsConfig
      // Adapter controls this
    };
    const config = getDefaultConfig(finalConfigOptions);
    logger23.info(LOG_PREFIX, "Successfully created RainbowKit Wagmi config object.", config);
    return config;
  } catch (error) {
    logger23.error(LOG_PREFIX, "Error creating RainbowKit Wagmi config:", error);
    return null;
  }
}
async function getWagmiConfigForRainbowKit(uiKitConfiguration, chains, chainIdToNetworkIdMap, getRpcEndpointOverride) {
  if (!uiKitConfiguration || uiKitConfiguration.kitName !== "rainbowkit" || !uiKitConfiguration.kitConfig) {
    logger23.debug(
      LOG_PREFIX,
      "Not configured for RainbowKit or kitConfig (resolved native + programmatic) is missing."
    );
    return null;
  }
  const resolvedKitConfig = uiKitConfiguration.kitConfig;
  return createRainbowKitWagmiConfig(
    resolvedKitConfig,
    // Pass the resolved kitConfig
    chains,
    chainIdToNetworkIdMap,
    getRpcEndpointOverride
  );
}
function createUiKitManager(deps) {
  const { getWalletImplementation, loadRainbowKitAssets, logPrefix } = deps;
  const initialState = {
    currentFullUiKitConfig: null,
    wagmiConfig: null,
    kitProviderComponent: null,
    isKitAssetsLoaded: false,
    isInitializing: false,
    error: null
  };
  let state = { ...initialState };
  const listeners = /* @__PURE__ */ new Set();
  function notifyListeners() {
    listeners.forEach((listener) => {
      try {
        listener();
      } catch (error) {
        logger24.error(logPrefix, "Error in listener:", error);
      }
    });
  }
  function subscribe(listener) {
    listeners.add(listener);
    return () => {
      listeners.delete(listener);
    };
  }
  function getState() {
    return { ...state };
  }
  async function configure(newFullUiKitConfig) {
    logger24.info(`${logPrefix}:configure`, "Configuring UI kit. New config:", newFullUiKitConfig);
    const oldKitName = state.currentFullUiKitConfig?.kitName;
    const newKitName = newFullUiKitConfig.kitName;
    const kitChanged = oldKitName !== newKitName;
    state = {
      ...state,
      isInitializing: true,
      error: null,
      currentFullUiKitConfig: newFullUiKitConfig,
      kitProviderComponent: kitChanged ? null : state.kitProviderComponent,
      isKitAssetsLoaded: kitChanged ? false : state.isKitAssetsLoaded
    };
    notifyListeners();
    let newWagmiConfigAttempt = null;
    const walletImpl = await Promise.resolve(getWalletImplementation());
    try {
      if (newKitName === "rainbowkit") {
        if (kitChanged || !state.kitProviderComponent || !state.isKitAssetsLoaded) {
          logger24.info(`${logPrefix}:configure`, "Ensuring RainbowKit assets are loaded...");
          const rkAssets = await loadRainbowKitAssets();
          state.kitProviderComponent = rkAssets.ProviderComponent;
          state.isKitAssetsLoaded = rkAssets.cssLoaded && !!rkAssets.ProviderComponent;
          if (!state.isKitAssetsLoaded) {
            throw new Error("Failed to load critical RainbowKit assets.");
          }
        }
        newWagmiConfigAttempt = await walletImpl.getConfigForRainbowKit(newFullUiKitConfig);
        logger24.info(`${logPrefix}:configure`, "WagmiConfig for RainbowKit obtained.");
      } else if (newKitName === "custom" || !newKitName) {
        newWagmiConfigAttempt = await walletImpl.getActiveConfigForManager(newFullUiKitConfig);
        logger24.info(`${logPrefix}:configure`, "ActiveConfig for custom/default obtained.");
        if (kitChanged) {
          state.kitProviderComponent = null;
          state.isKitAssetsLoaded = false;
        }
      } else {
        logger24.warn(`${logPrefix}:configure`, `Unsupported kitName: ${newKitName}.`);
        state.kitProviderComponent = null;
        state.isKitAssetsLoaded = false;
      }
      state.wagmiConfig = newWagmiConfigAttempt;
      walletImpl.setActiveWagmiConfig(state.wagmiConfig);
      state.error = null;
      if (!newWagmiConfigAttempt && newKitName && newKitName !== "none" && newKitName !== "custom") {
        state.error = new Error(`Failed to obtain WagmiConfig for ${newKitName}`);
        logger24.error(`${logPrefix}:configure`, state.error.message);
      }
    } catch (err) {
      logger24.error(`${logPrefix}:configure`, "Error during UI kit configuration process:", err);
      state.error = err instanceof Error ? err : new Error(String(err));
      state.wagmiConfig = null;
      walletImpl.setActiveWagmiConfig(null);
    } finally {
      state.isInitializing = false;
      logger24.info(
        `${logPrefix}:configure`,
        "Configuration attempt finished. Final wagmiConfig:",
        state.wagmiConfig ? "Set" : "Null",
        "Kit Provider Component:",
        state.kitProviderComponent ? "Set" : "Null",
        "Kit Assets Loaded:",
        state.isKitAssetsLoaded,
        "Error state:",
        state.error ? state.error.message : "None"
      );
      notifyListeners();
    }
  }
  return {
    getState,
    subscribe,
    configure
  };
}
var loadedAssets = null;
var providerPromise = null;
var cssPromise = null;
var LOG_PREFIX2 = "RainbowKitAssetManager";
async function ensureRainbowKitAssetsLoaded() {
  if (loadedAssets) {
    logger25.debug(LOG_PREFIX2, "Assets already loaded, returning cached.");
    return loadedAssets;
  }
  if (!providerPromise) {
    providerPromise = import("@rainbow-me/rainbowkit").then((module) => {
      const component = module.RainbowKitProvider;
      logger25.info(LOG_PREFIX2, "RainbowKitProvider module loaded.");
      return component;
    }).catch((err) => {
      logger25.error(LOG_PREFIX2, "Failed to load RainbowKitProvider module:", err);
      return null;
    });
  }
  if (!cssPromise) {
    cssPromise = import("@rainbow-me/rainbowkit/styles.css").then(() => {
      logger25.info(LOG_PREFIX2, "RainbowKit CSS loaded successfully.");
      return true;
    }).catch((err) => {
      logger25.error(LOG_PREFIX2, "Failed to load RainbowKit CSS:", err);
      return false;
    });
  }
  try {
    const [ProviderComponent, cssLoadedSuccess] = await Promise.all([providerPromise, cssPromise]);
    loadedAssets = { ProviderComponent, cssLoaded: cssLoadedSuccess };
    if (!ProviderComponent || !cssLoadedSuccess) {
      logger25.warn(LOG_PREFIX2, "One or more RainbowKit assets failed to load.", loadedAssets);
    }
    return loadedAssets;
  } catch (error) {
    logger25.error(LOG_PREFIX2, "Error in Promise.all for asset loading:", error);
    loadedAssets = { ProviderComponent: null, cssLoaded: false };
    return loadedAssets;
  }
}
var LOG_PREFIX3 = "ConfigResolutionService";
async function resolveAndInitializeKitConfig(kitName, programmaticKitConfig, loadConfigModule) {
  logger26.debug(
    `${LOG_PREFIX3}:resolveAndInitializeKitConfig`,
    `Resolving native config for kit: ${kitName || "none"}`,
    {
      hasProgrammaticKitConfig: !!programmaticKitConfig,
      hasLoadConfigModule: !!loadConfigModule
    }
  );
  let userNativeConfig = null;
  if (kitName && kitName !== "custom" && kitName !== "none" && loadConfigModule) {
    const conventionalConfigPath = `./config/wallet/${kitName}.config.ts`;
    try {
      userNativeConfig = await loadConfigModule(conventionalConfigPath);
    } catch (error) {
      logger26.warn(
        `${LOG_PREFIX3}:resolveAndInitializeKitConfig`,
        `Call to load native config for ${kitName} from ${conventionalConfigPath} failed. Error:`,
        error
      );
    }
  }
  if (userNativeConfig && programmaticKitConfig) {
    const mergedConfig = { ...userNativeConfig, ...programmaticKitConfig };
    return mergedConfig;
  } else if (userNativeConfig) {
    return userNativeConfig;
  } else if (programmaticKitConfig) {
    return programmaticKitConfig;
  }
  logger26.debug(
    `${LOG_PREFIX3}:resolveAndInitializeKitConfig`,
    `No native or programmatic kitConfig provided for ${kitName || "none"}. Returning null.`
  );
  return null;
}
async function resolveFullUiKitConfiguration(programmaticOverrides, initialAppServiceKitName, currentAppServiceConfig, options) {
  logger26.debug(`${LOG_PREFIX3}:resolveFullUiKitConfiguration`, "Starting resolution with:", {
    programmaticOverrides,
    initialAppServiceKitName,
    currentAppServiceConfig,
    hasLoadNativeCallback: !!options?.loadUiKitNativeConfig,
    hasCustomCode: !!programmaticOverrides.customCode
  });
  const effectiveKitName = programmaticOverrides.kitName || initialAppServiceKitName || currentAppServiceConfig.kitName || "custom";
  const resolvedUserNativeAndProgrammaticKitConfig = await resolveAndInitializeKitConfig(
    effectiveKitName,
    programmaticOverrides.kitConfig,
    options?.loadUiKitNativeConfig
  );
  const finalFullConfig = {
    kitName: effectiveKitName,
    kitConfig: {
      ...currentAppServiceConfig.kitConfig || {},
      ...resolvedUserNativeAndProgrammaticKitConfig || {}
      // customCode is NOT applied to runtime config
    },
    // Pass through customCode for export purposes only
    customCode: programmaticOverrides.customCode
  };
  logger26.debug(
    `${LOG_PREFIX3}:resolveFullUiKitConfiguration`,
    "Resolved finalFullConfig:",
    finalFullConfig
  );
  return finalFullConfig;
}
function filterWalletComponents(allPossibleComponents, exclusions, kitName = "custom") {
  logger27.debug(
    "filterWalletComponents",
    `Filtering components for kit: ${kitName}. Exclusions: ${exclusions.join(", ")}.`
  );
  if (!allPossibleComponents || Object.keys(allPossibleComponents).length === 0) {
    logger27.debug("filterWalletComponents", `No components provided to filter for kit: ${kitName}.`);
    return void 0;
  }
  if (exclusions.length === 0) {
    logger27.debug(
      "filterWalletComponents",
      `Providing all components for kit: ${kitName}.`,
      allPossibleComponents
    );
    return allPossibleComponents;
  }
  const filteredComponents = {};
  let componentCount = 0;
  for (const key in allPossibleComponents) {
    const componentKey = key;
    if (!exclusions.includes(componentKey)) {
      if (allPossibleComponents[componentKey]) {
        filteredComponents[componentKey] = allPossibleComponents[componentKey];
        componentCount++;
      }
    }
  }
  if (componentCount > 0) {
    logger27.debug(
      "filterWalletComponents",
      `Providing filtered components for kit: ${kitName} after exclusions (${exclusions.join(", ")}).`,
      filteredComponents
    );
    return filteredComponents;
  }
  logger27.debug("filterWalletComponents", `All components were excluded for kit: ${kitName}.`);
  return void 0;
}
function getComponentExclusionsFromConfig(kitConfig) {
  if (kitConfig && typeof kitConfig === "object" && "components" in kitConfig) {
    const componentsCfg = kitConfig.components;
    if (componentsCfg && typeof componentsCfg === "object" && "exclude" in componentsCfg && Array.isArray(componentsCfg.exclude)) {
      return componentsCfg.exclude.filter(
        (key) => typeof key === "string" && ECOSYSTEM_WALLET_COMPONENT_KEYS.includes(key)
      );
    }
  }
  return [];
}
init_eoa();
async function validateRelayerConfig(config) {
  if (!config.serviceUrl) {
    return "Relayer execution selected, but no service URL was provided.";
  }
  if (!config.relayer?.relayerId) {
    return "Relayer execution selected, but no relayer was chosen from the list.";
  }
  return true;
}
init_eoa();
var SYSTEM_LOG_TAG4 = "evm-execution-config";
async function validateEvmExecutionConfig(config, walletStatus) {
  logger28.info(SYSTEM_LOG_TAG4, "Validating EVM execution config:", { config, walletStatus });
  switch (config.method) {
    case "eoa":
      return validateEoaConfig(config, walletStatus);
    case "relayer":
      return validateRelayerConfig(config);
    case "multisig":
      return "Multisig execution is not yet supported";
    default: {
      const unknownMethod = config.method;
      logger28.warn(SYSTEM_LOG_TAG4, `Unsupported execution method type: ${unknownMethod}`);
      return `Unsupported execution method: ${unknownMethod}`;
    }
  }
}
init_validation();
init_utils();

// src/adapter.ts
import { logger as logger36 } from "@openzeppelin/ui-utils";

// src/wallet/components/EvmWalletUiRoot.tsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { createConfig as createConfig2, http as http5 } from "@wagmi/core";
import { mainnet } from "viem/chains";
import { WagmiProvider } from "wagmi";
import { useEffect as useEffect5, useMemo, useState as useState5 } from "react";
import { logger as logger30 } from "@openzeppelin/ui-utils";

// src/wallet/utils/walletImplementationManager.ts
import { appConfigService as appConfigService5, logger as logger29 } from "@openzeppelin/ui-utils";

// src/networks/mainnet.ts
import {
  NetworkArbitrumOne,
  NetworkAvalanche,
  NetworkBase,
  NetworkBinanceSmartChain,
  NetworkEthereum,
  NetworkLinea,
  NetworkOptimism,
  NetworkPolygon,
  NetworkScroll,
  NetworkZksync
} from "@web3icons/react";
import {
  arbitrum as viemArbitrum,
  avalanche as viemAvalanche,
  base as viemBase,
  bsc as viemBsc,
  linea as viemLinea,
  mainnet as viemMainnet,
  optimism as viemOptimism,
  polygon as viemPolygon,
  polygonZkEvm as viemPolygonZkEvm,
  scroll as viemScroll,
  zksync as viemZkSync
} from "viem/chains";
var ethereumMainnet = {
  id: "ethereum-mainnet",
  exportConstName: "ethereumMainnet",
  name: "Ethereum",
  ecosystem: "evm",
  network: "ethereum",
  type: "mainnet",
  isTestnet: false,
  chainId: 1,
  rpcUrl: viemMainnet.rpcUrls.default.http[0],
  explorerUrl: "https://etherscan.io",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: NetworkEthereum,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: viemMainnet
};
var arbitrumMainnet = {
  id: "arbitrum-mainnet",
  exportConstName: "arbitrumMainnet",
  name: "Arbitrum One",
  ecosystem: "evm",
  network: "arbitrum",
  type: "mainnet",
  isTestnet: false,
  chainId: 42161,
  rpcUrl: viemArbitrum.rpcUrls.default.http[0],
  explorerUrl: "https://arbiscan.io",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: NetworkArbitrumOne,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: viemArbitrum
};
var polygonMainnet = {
  id: "polygon-mainnet",
  exportConstName: "polygonMainnet",
  name: "Polygon",
  ecosystem: "evm",
  network: "polygon",
  type: "mainnet",
  isTestnet: false,
  chainId: 137,
  rpcUrl: viemPolygon.rpcUrls.default.http[0],
  explorerUrl: "https://polygonscan.com",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: NetworkPolygon,
  nativeCurrency: {
    name: "MATIC",
    symbol: "MATIC",
    decimals: 18
  },
  viemChain: viemPolygon
};
var polygonZkEvmMainnet = {
  id: "polygon-zkevm-mainnet",
  exportConstName: "polygonZkEvmMainnet",
  name: "Polygon zkEVM",
  ecosystem: "evm",
  network: "polygon-zkevm",
  type: "mainnet",
  isTestnet: false,
  chainId: 1101,
  rpcUrl: viemPolygonZkEvm.rpcUrls.default.http[0],
  explorerUrl: "https://zkevm.polygonscan.com",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: NetworkPolygon,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: viemPolygonZkEvm
};
var baseMainnet = {
  id: "base-mainnet",
  exportConstName: "baseMainnet",
  name: "Base",
  ecosystem: "evm",
  network: "base",
  type: "mainnet",
  isTestnet: false,
  chainId: 8453,
  rpcUrl: viemBase.rpcUrls.default.http[0],
  explorerUrl: "https://basescan.org",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: NetworkBase,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: viemBase
};
var bscMainnet = {
  id: "bsc-mainnet",
  exportConstName: "bscMainnet",
  name: "BNB Smart Chain",
  ecosystem: "evm",
  network: "bsc",
  type: "mainnet",
  isTestnet: false,
  chainId: 56,
  rpcUrl: viemBsc.rpcUrls.default.http[0],
  explorerUrl: "https://bscscan.com",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: NetworkBinanceSmartChain,
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  viemChain: viemBsc
};
var optimismMainnet = {
  id: "optimism-mainnet",
  exportConstName: "optimismMainnet",
  name: "OP Mainnet",
  ecosystem: "evm",
  network: "optimism",
  type: "mainnet",
  isTestnet: false,
  chainId: 10,
  rpcUrl: viemOptimism.rpcUrls.default.http[0],
  explorerUrl: "https://optimistic.etherscan.io",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: NetworkOptimism,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: viemOptimism
};
var avalancheMainnet = {
  id: "avalanche-mainnet",
  exportConstName: "avalancheMainnet",
  name: "Avalanche C-Chain",
  ecosystem: "evm",
  network: "avalanche",
  type: "mainnet",
  isTestnet: false,
  chainId: 43114,
  rpcUrl: viemAvalanche.rpcUrls.default.http[0],
  explorerUrl: "https://snowscan.xyz",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: NetworkAvalanche,
  nativeCurrency: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18
  },
  viemChain: viemAvalanche
};
var zkSyncEraMainnet = {
  id: "zksync-era-mainnet",
  exportConstName: "zkSyncEraMainnet",
  name: "ZkSync Era",
  ecosystem: "evm",
  network: "zksync-era",
  type: "mainnet",
  isTestnet: false,
  chainId: 324,
  rpcUrl: viemZkSync.rpcUrls.default.http[0],
  explorerUrl: "https://explorer.zksync.io",
  apiUrl: "https://block-explorer-api.mainnet.zksync.io/api",
  primaryExplorerApiIdentifier: "zksync-era-mainnet",
  supportsEtherscanV2: false,
  iconComponent: NetworkZksync,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: viemZkSync
};
var scrollMainnet = {
  id: "scroll-mainnet",
  exportConstName: "scrollMainnet",
  name: "Scroll",
  ecosystem: "evm",
  network: "scroll",
  type: "mainnet",
  isTestnet: false,
  chainId: 534352,
  rpcUrl: viemScroll.rpcUrls.default.http[0],
  explorerUrl: "https://scrollscan.com",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: NetworkScroll,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: viemScroll
};
var lineaMainnet = {
  id: "linea-mainnet",
  exportConstName: "lineaMainnet",
  name: "Linea",
  ecosystem: "evm",
  network: "linea",
  type: "mainnet",
  isTestnet: false,
  chainId: 59144,
  rpcUrl: viemLinea.rpcUrls.default.http[0],
  explorerUrl: "https://lineascan.build",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: NetworkLinea,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: viemLinea
};

// src/networks/testnet.ts
import {
  NetworkArbitrumOne as NetworkArbitrumOne2,
  NetworkAvalanche as NetworkAvalanche2,
  NetworkBase as NetworkBase2,
  NetworkBinanceSmartChain as NetworkBinanceSmartChain2,
  NetworkEthereum as NetworkEthereum2,
  NetworkLinea as NetworkLinea2,
  NetworkMonad,
  NetworkOptimism as NetworkOptimism2,
  NetworkPolygon as NetworkPolygon2,
  NetworkScroll as NetworkScroll2,
  NetworkZksync as NetworkZksync2
} from "@web3icons/react";
import {
  arbitrumSepolia as viemArbitrumSepolia,
  avalancheFuji as viemAvalancheFuji,
  baseSepolia as viemBaseSepolia,
  bscTestnet as viemBscTestnet,
  lineaSepolia as viemLineaSepolia,
  monadTestnet as viemMonadTestnet,
  optimismSepolia as viemOptimismSepolia,
  polygonAmoy as viemPolygonAmoy,
  polygonZkEvmCardona as viemPolygonZkEvmCardona,
  scrollSepolia as viemScrollSepolia,
  sepolia as viemSepolia,
  zksyncSepoliaTestnet as viemZkSyncSepoliaTestnet
} from "viem/chains";
var ethereumSepolia = {
  id: "ethereum-sepolia",
  exportConstName: "ethereumSepolia",
  name: "Sepolia",
  ecosystem: "evm",
  network: "ethereum",
  type: "testnet",
  isTestnet: true,
  chainId: 11155111,
  rpcUrl: viemSepolia.rpcUrls.default.http[0],
  explorerUrl: "https://sepolia.etherscan.io",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: NetworkEthereum2,
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: viemSepolia
};
var arbitrumSepolia = {
  id: "arbitrum-sepolia",
  exportConstName: "arbitrumSepolia",
  name: "Arbitrum Sepolia",
  ecosystem: "evm",
  network: "arbitrum",
  type: "testnet",
  isTestnet: true,
  chainId: 421614,
  rpcUrl: viemArbitrumSepolia.rpcUrls.default.http[0],
  explorerUrl: "https://sepolia.arbiscan.io",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: NetworkArbitrumOne2,
  nativeCurrency: {
    name: "Arbitrum Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: viemArbitrumSepolia
};
var polygonAmoy = {
  id: "polygon-amoy",
  exportConstName: "polygonAmoy",
  name: "Polygon Amoy",
  ecosystem: "evm",
  network: "polygon",
  type: "testnet",
  isTestnet: true,
  chainId: 80002,
  rpcUrl: viemPolygonAmoy.rpcUrls.default.http[0],
  explorerUrl: "https://amoy.polygonscan.com",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: NetworkPolygon2,
  nativeCurrency: {
    name: "MATIC",
    symbol: "MATIC",
    decimals: 18
  },
  viemChain: viemPolygonAmoy
};
var polygonZkEvmCardona = {
  id: "polygon-zkevm-cardona",
  exportConstName: "polygonZkEvmCardona",
  name: "Polygon zkEVM Cardona",
  ecosystem: "evm",
  network: "polygon-zkevm",
  type: "testnet",
  isTestnet: true,
  chainId: 2442,
  rpcUrl: viemPolygonZkEvmCardona.rpcUrls.default.http[0],
  explorerUrl: "https://cardona-zkevm.polygonscan.com",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: NetworkPolygon2,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: viemPolygonZkEvmCardona
};
var baseSepolia = {
  id: "base-sepolia",
  exportConstName: "baseSepolia",
  name: "Base Sepolia",
  ecosystem: "evm",
  network: "base",
  type: "testnet",
  isTestnet: true,
  chainId: 84532,
  rpcUrl: viemBaseSepolia.rpcUrls.default.http[0],
  explorerUrl: "https://sepolia.basescan.org",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: NetworkBase2,
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: viemBaseSepolia
};
var bscTestnet = {
  id: "bsc-testnet",
  exportConstName: "bscTestnet",
  name: "BSC Testnet",
  ecosystem: "evm",
  network: "bsc",
  type: "testnet",
  isTestnet: true,
  chainId: 97,
  rpcUrl: viemBscTestnet.rpcUrls.default.http[0],
  explorerUrl: "https://testnet.bscscan.com",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: NetworkBinanceSmartChain2,
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  viemChain: viemBscTestnet
};
var optimismSepolia = {
  id: "optimism-sepolia",
  exportConstName: "optimismSepolia",
  name: "OP Sepolia",
  ecosystem: "evm",
  network: "optimism",
  type: "testnet",
  isTestnet: true,
  chainId: 11155420,
  rpcUrl: viemOptimismSepolia.rpcUrls.default.http[0],
  explorerUrl: "https://sepolia-optimism.etherscan.io",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: NetworkOptimism2,
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: viemOptimismSepolia
};
var avalancheFuji = {
  id: "avalanche-fuji",
  exportConstName: "avalancheFuji",
  name: "Avalanche Fuji C-Chain",
  ecosystem: "evm",
  network: "avalanche",
  type: "testnet",
  isTestnet: true,
  chainId: 43113,
  rpcUrl: viemAvalancheFuji.rpcUrls.default.http[0],
  explorerUrl: "https://testnet.snowscan.xyz",
  apiUrl: "https://api.etherscan.io/v2/api",
  // Using Etherscan V2 unified API
  primaryExplorerApiIdentifier: "etherscan-v2",
  // Unified identifier for V2 API
  supportsEtherscanV2: true,
  requiresExplorerApiKey: true,
  iconComponent: NetworkAvalanche2,
  nativeCurrency: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18
  },
  viemChain: viemAvalancheFuji
};
var zksyncSepoliaTestnet = {
  id: "zksync-era-sepolia",
  exportConstName: "zksyncSepoliaTestnet",
  name: "ZkSync Era Sepolia",
  ecosystem: "evm",
  network: "zksync-era",
  type: "testnet",
  isTestnet: true,
  chainId: 300,
  rpcUrl: viemZkSyncSepoliaTestnet.rpcUrls.default.http[0],
  explorerUrl: "https://sepolia.explorer.zksync.io",
  apiUrl: "https://block-explorer-api.sepolia.zksync.dev/api",
  primaryExplorerApiIdentifier: "zksync-era-sepolia",
  supportsEtherscanV2: false,
  iconComponent: NetworkZksync2,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: viemZkSyncSepoliaTestnet
};
var scrollSepolia = {
  id: "scroll-sepolia",
  exportConstName: "scrollSepolia",
  name: "Scroll Sepolia",
  ecosystem: "evm",
  network: "scroll",
  type: "testnet",
  isTestnet: true,
  chainId: 534351,
  rpcUrl: viemScrollSepolia.rpcUrls.default.http[0],
  explorerUrl: "https://sepolia.scrollscan.dev",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: NetworkScroll2,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: viemScrollSepolia
};
var lineaSepolia = {
  id: "linea-sepolia",
  exportConstName: "lineaSepolia",
  name: "Linea Sepolia",
  ecosystem: "evm",
  network: "linea",
  type: "testnet",
  isTestnet: true,
  chainId: 59141,
  rpcUrl: viemLineaSepolia.rpcUrls.default.http[0],
  explorerUrl: "https://sepolia.lineascan.build",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: NetworkLinea2,
  nativeCurrency: {
    name: "Linea Ether",
    symbol: "ETH",
    decimals: 18
  },
  viemChain: viemLineaSepolia
};
var monadTestnet = {
  id: "monad-testnet",
  exportConstName: "monadTestnet",
  name: "Monad Testnet",
  ecosystem: "evm",
  network: "monad",
  type: "testnet",
  isTestnet: true,
  chainId: 10143,
  rpcUrl: viemMonadTestnet.rpcUrls.default.http[0],
  explorerUrl: "https://testnet.monadexplorer.com",
  apiUrl: "https://api.etherscan.io/v2/api",
  primaryExplorerApiIdentifier: "etherscan-v2",
  supportsEtherscanV2: true,
  iconComponent: NetworkMonad,
  nativeCurrency: {
    name: "Monad",
    symbol: "MON",
    decimals: 18
  },
  viemChain: viemMonadTestnet
};

// src/networks/index.ts
var evmMainnetNetworks = [
  ethereumMainnet,
  arbitrumMainnet,
  baseMainnet,
  polygonMainnet,
  polygonZkEvmMainnet,
  bscMainnet,
  optimismMainnet,
  avalancheMainnet,
  lineaMainnet,
  scrollMainnet,
  zkSyncEraMainnet
  // Other mainnet networks...
];
var evmTestnetNetworks = [
  ethereumSepolia,
  arbitrumSepolia,
  baseSepolia,
  polygonAmoy,
  polygonZkEvmCardona,
  bscTestnet,
  optimismSepolia,
  avalancheFuji,
  lineaSepolia,
  scrollSepolia,
  zksyncSepoliaTestnet,
  monadTestnet
  // Other testnet networks...
];
var evmNetworks = [...evmMainnetNetworks, ...evmTestnetNetworks];

// src/wallet/implementation/wagmi-implementation.ts
var getSupportedChainsFromNetworks2 = () => {
  return evmNetworks.filter((network) => network.viemChain).map((network) => network.viemChain).filter((chain, index, self) => self.findIndex((c) => c.id === chain.id) === index);
};
var defaultSupportedChains = getSupportedChainsFromNetworks2();
function createEvmWalletImplementation(walletConnectProjectId, initialUiKitConfig) {
  const config = {
    chains: defaultSupportedChains,
    networkConfigs: evmNetworks,
    walletConnectProjectId,
    initialUiKitConfig,
    logSystem: "WagmiWalletImplementation"
  };
  const instance = new WagmiWalletImplementation(config);
  instance.setRainbowKitConfigFn(
    async (uiKitConfiguration, chains, chainIdToNetworkIdMap, getRpcOverride) => {
      return getWagmiConfigForRainbowKit(
        uiKitConfiguration,
        chains,
        chainIdToNetworkIdMap,
        getRpcOverride
      );
    }
  );
  return instance;
}

// src/wallet/utils/walletImplementationManager.ts
var walletImplementationInstance;
var walletImplementationPromise;
var LOG_SYSTEM = "EvmWalletImplementationManager";
async function getEvmWalletImplementation() {
  if (walletImplementationInstance) {
    return walletImplementationInstance;
  }
  if (walletImplementationPromise) {
    return walletImplementationPromise;
  }
  walletImplementationPromise = (async () => {
    try {
      logger29.info(LOG_SYSTEM, "Initializing WagmiWalletImplementation singleton (async)... ");
      const initialUiKitConfig = appConfigService5.getTypedNestedConfig(
        "walletui",
        "config"
      );
      const wcProjectId = appConfigService5.getGlobalServiceParam("walletconnect", "projectId");
      const instance = createEvmWalletImplementation(wcProjectId, initialUiKitConfig);
      logger29.info(LOG_SYSTEM, "WagmiWalletImplementation singleton created (async).");
      walletImplementationInstance = instance;
      return instance;
    } catch (error) {
      logger29.error(LOG_SYSTEM, "Failed to initialize WagmiWalletImplementation (async):", error);
      const fallbackInstance = createEvmWalletImplementation();
      walletImplementationInstance = fallbackInstance;
      return fallbackInstance;
    }
  })();
  return walletImplementationPromise;
}
function getInitializedEvmWalletImplementation() {
  if (!walletImplementationInstance) {
    logger29.warn(
      LOG_SYSTEM,
      "getInitializedEvmWalletImplementation called before instance was ready."
    );
  }
  return walletImplementationInstance;
}

// src/wallet/evmUiKitManager.ts
var evmUiKitManager = createUiKitManager({
  getWalletImplementation: getEvmWalletImplementation,
  loadRainbowKitAssets: ensureRainbowKitAssetsLoaded,
  logPrefix: "EvmUiKitManager"
});

// src/wallet/components/EvmWalletUiRoot.tsx
import { jsx as jsx7, jsxs as jsxs6 } from "react/jsx-runtime";
var stableQueryClient = new QueryClient();
var minimalDefaultWagmiConfig = createConfig2({
  chains: [mainnet],
  // At least one chain is required in wagmi v2.20+
  connectors: [],
  // Empty connectors array
  transports: {
    [mainnet.id]: http5()
    // Basic HTTP transport for the default chain
  }
});
var EvmWalletUiRoot = ({ children }) => {
  const [managerState, setManagerState] = useState5(
    evmUiKitManager.getState()
  );
  useEffect5(() => {
    const handleStateChange = () => {
      setManagerState(evmUiKitManager.getState());
    };
    const unsubscribe = evmUiKitManager.subscribe(handleStateChange);
    handleStateChange();
    return unsubscribe;
  }, []);
  const queryClient = useMemo(() => stableQueryClient, []);
  const {
    wagmiConfig,
    kitProviderComponent,
    isKitAssetsLoaded,
    currentFullUiKitConfig,
    isInitializing,
    error
  } = managerState;
  const configForWagmiProvider = wagmiConfig || minimalDefaultWagmiConfig;
  const isWagmiContextEffectivelyReady = !!wagmiConfig && !error;
  let finalChildren = children;
  if (isWagmiContextEffectivelyReady && currentFullUiKitConfig?.kitName === "rainbowkit" && kitProviderComponent && isKitAssetsLoaded) {
    const DynKitProvider = kitProviderComponent;
    const kitConfig = currentFullUiKitConfig.kitConfig || {};
    const providerProps = kitConfig.providerProps || {};
    logger30.info(
      "EvmWalletUiRoot",
      "Wrapping children with dynamically loaded KitProvider (RainbowKit)."
    );
    finalChildren = /* @__PURE__ */ jsx7(DynKitProvider, { ...providerProps, children });
  } else if (currentFullUiKitConfig?.kitName === "rainbowkit" && !isWagmiContextEffectivelyReady) {
    logger30.info(
      "EvmWalletUiRoot",
      "RainbowKit configured, but context or assets not ready. Button may show its loading/error state."
    );
  }
  return /* @__PURE__ */ jsx7(WagmiProvider, { config: configForWagmiProvider, children: /* @__PURE__ */ jsx7(QueryClientProvider, { client: queryClient, children: /* @__PURE__ */ jsxs6(WagmiProviderInitializedContext.Provider, { value: isWagmiContextEffectivelyReady, children: [
    finalChildren,
    isInitializing && /* @__PURE__ */ jsx7(
      "div",
      {
        style: {
          position: "fixed",
          top: "10px",
          right: "10px",
          background: "rgba(0,0,0,0.1)",
          padding: "5px",
          borderRadius: "3px",
          fontSize: "0.8em"
        },
        children: "Updating network..."
      }
    ),
    error && !wagmiConfig && /* @__PURE__ */ jsxs6(
      "div",
      {
        style: {
          position: "fixed",
          bottom: "10px",
          left: "10px",
          background: "red",
          color: "white",
          padding: "10px"
        },
        children: [
          "Error initializing wallet provider: ",
          error.message
        ]
      }
    )
  ] }) }) });
};

// src/wallet/hooks/facade-hooks.ts
import {
  useAccount,
  useBalance,
  useChainId,
  useChains,
  useConnect,
  useDisconnect,
  useSendTransaction,
  useSignMessage,
  useSignTypedData,
  useSwitchChain,
  useWaitForTransactionReceipt
} from "wagmi";
var evmFacadeHooks = {
  useAccount,
  useConnect,
  useDisconnect,
  useSwitchChain,
  useChainId,
  useChains,
  useBalance,
  useSendTransaction,
  useWaitForTransactionReceipt,
  useSignMessage,
  useSignTypedData
};

// src/wallet/hooks/useUiKitConfig.ts
import { appConfigService as appConfigService6, logger as logger31 } from "@openzeppelin/ui-utils";
var defaultConfig = {
  kitName: "custom",
  // Default to using our custom implementation for EVM
  kitConfig: {
    showInjectedConnector: false
    // Default to hiding the injected connector
  }
};
var uiKitConfig = { ...defaultConfig };
function loadInitialConfigFromAppService() {
  logger31.debug("useUiKitConfig", "Attempting to load initial config from AppConfigService...");
  const configObj = appConfigService6.getWalletUIConfig("evm");
  if (configObj && configObj.kitName) {
    logger31.info(
      "useUiKitConfig",
      `Loaded initial config from AppConfigService: kitName=${configObj.kitName}`,
      configObj.kitConfig
    );
    return {
      kitName: configObj.kitName,
      kitConfig: { ...defaultConfig.kitConfig, ...configObj.kitConfig || {} }
    };
  }
  logger31.debug(
    "useUiKitConfig",
    "No initial config found in AppConfigService, using module default."
  );
  return { ...defaultConfig };
}

// src/configuration/execution.ts
import { logger as logger32 } from "@openzeppelin/ui-utils";
async function getEvmSupportedExecutionMethods() {
  logger32.warn(
    "adapter-evm-execution-config",
    "getEvmSupportedExecutionMethods is using placeholder implementation."
  );
  return Promise.resolve([
    {
      type: "eoa",
      name: "EOA (External Account)",
      description: "Execute using a standard wallet address."
    },
    {
      type: "relayer",
      name: "OpenZeppelin Relayer",
      description: "Execute via a OpenZeppelin open source transaction relayer service.",
      disabled: false
    },
    {
      type: "multisig",
      name: "Safe Multisig",
      // Example for future
      description: "Execute via a Safe multisignature wallet.",
      disabled: true
    }
  ]);
}

// src/configuration/network-services.ts
import { appConfigService as appConfigService7, userNetworkServiceConfigService as userNetworkServiceConfigService4 } from "@openzeppelin/ui-utils";
function getEvmDefaultServiceConfig(networkConfig, serviceId) {
  switch (serviceId) {
    case "rpc":
      if (networkConfig.rpcUrl) {
        return { rpcUrl: networkConfig.rpcUrl };
      }
      break;
    case "explorer": {
      const typedConfig = networkConfig;
      const apiKey = resolveExplorerApiKeyFromAppConfig(typedConfig);
      if (networkConfig.explorerUrl || apiKey) {
        return {
          explorerUrl: networkConfig.explorerUrl,
          apiUrl: networkConfig.apiUrl,
          ...apiKey ? { apiKey } : {}
        };
      }
      break;
    }
    case "contract-definitions":
      return null;
  }
  return null;
}
function getEvmNetworkServiceForms(networkConfig) {
  const globalV2ApiKey = appConfigService7.getGlobalServiceConfig("etherscanv2")?.apiKey;
  const v2DefaultEnabled = Boolean(globalV2ApiKey);
  const savedContractDefCfg = userNetworkServiceConfigService4.get(
    networkConfig.id,
    "contract-definitions"
  );
  const savedDefaultProvider = savedContractDefCfg && typeof savedContractDefCfg.defaultProvider === "string" ? savedContractDefCfg.defaultProvider : void 0;
  return [
    {
      id: "rpc",
      label: "RPC Provider",
      description: "Setting your own RPC endpoint ensures better reliability, faster response times, and higher rate limits. Public endpoints may be rate-limited or experience congestion during high traffic periods.",
      fields: [
        {
          id: "evm-rpc-url",
          name: "rpcUrl",
          type: "text",
          label: "RPC URL",
          placeholder: "https://mainnet.infura.io/v3/your-key",
          validation: { required: true, pattern: "^https?://.+" },
          width: "full"
        }
      ]
    },
    {
      id: "explorer",
      label: "Block Explorer",
      description: "Public API keys are rate-limited and may be exhausted quickly. Using your own key ensures reliable access to explorer services.",
      fields: [
        // Adapter-led informational notes (rendered generically by the panel)
        {
          id: "evm-explorer-note-etherscan",
          name: "_note_etherscan",
          type: "hidden",
          label: "",
          validation: {},
          isHidden: true,
          metadata: {
            note: {
              variant: "warning",
              title: "Etherscan API Support",
              html: true,
              lines: [
                "<strong>V2 API (Recommended):</strong> Supports all Etherscan-compatible explorers across multiple chains with a single API key.",
                "<strong>V1 API (Legacy):</strong> Requires chain-specific API endpoints. Some explorers may not be supported.",
                "<strong>Note:</strong> Non-Etherscan explorers (Blockscout, Routescan, etc.) are not supported."
              ]
            }
          }
        },
        {
          id: "evm-explorer-api-key",
          name: "apiKey",
          type: "password",
          label: "API Key",
          placeholder: "Your explorer API key",
          helperText: "Required for fetching contract ABIs and other API operations",
          validation: {},
          width: "full"
        },
        {
          id: "evm-explorer-use-v2",
          name: "useV2Api",
          type: "checkbox",
          label: "Use Etherscan V2 API",
          helperText: "Enable the new V2 API for all Etherscan-compatible networks. V2 provides unified access across all chains.",
          validation: {},
          defaultValue: v2DefaultEnabled,
          metadata: {
            section: "api-config",
            sectionLabel: "API Configuration",
            sectionHelp: "Configure API version and network application settings."
          }
        },
        {
          id: "evm-explorer-apply-all",
          name: "applyToAllNetworks",
          type: "checkbox",
          label: "Apply to all compatible networks",
          helperText: "Apply these settings to all Etherscan-compatible networks in your project.",
          validation: {},
          defaultValue: v2DefaultEnabled,
          // UI hinting for generic renderer to indent under and disable when V2 is off
          metadata: {
            section: "api-config",
            nestUnder: "useV2Api",
            disabledWhen: { field: "useV2Api", equals: false }
          }
        },
        {
          id: "evm-explorer-url",
          name: "explorerUrl",
          type: "text",
          label: "Explorer Base URL (optional)",
          placeholder: "https://etherscan.io",
          validation: {},
          helperText: "Base URL for viewing transactions and addresses. If not provided, defaults from the network will be used.",
          width: "full",
          metadata: {
            section: "custom-endpoints",
            sectionLabel: "Custom Endpoints",
            sectionHelp: "Override default URLs for explorer and API endpoints."
          }
        },
        {
          id: "evm-explorer-api-url",
          name: "apiUrl",
          type: "text",
          label: "Explorer API URL (legacy / V1)",
          placeholder: "https://api.etherscan.io/api",
          validation: {},
          helperText: "API endpoint for fetching contract data. If not provided, defaults from the network will be used.",
          width: "full",
          metadata: { section: "custom-endpoints" }
        }
      ]
    },
    {
      id: "contract-definitions",
      label: "Contract Definitions",
      description: void 0,
      supportsConnectionTest: false,
      fields: [
        // Informational note
        {
          id: "evm-contract-def-note",
          name: "_note_contract_def",
          type: "hidden",
          label: "",
          validation: {},
          isHidden: true,
          metadata: {
            hideTestConnection: true,
            note: {
              variant: "info",
              title: "Contract Definition Provider",
              lines: [
                "Select which provider the builder should try first when loading verified contract definitions. Deep links can override this preference temporarily."
              ]
            }
          }
        },
        // Default provider select
        {
          id: "evm-contract-def-provider",
          name: "defaultProvider",
          type: "select",
          label: "Default Contract Definition Provider",
          placeholder: "Select a provider",
          helperText: "Used as the first provider to query for contract definitions.",
          validation: {},
          options: [
            { label: "Etherscan", value: EvmProviderKeys.Etherscan },
            { label: "Sourcify", value: EvmProviderKeys.Sourcify }
          ],
          // Seed from saved user config or app-config default if present; otherwise empty
          defaultValue: savedDefaultProvider || appConfigService7.getGlobalServiceParam("contractdefinition", "defaultProvider") || "",
          width: "full"
        },
        // Apply to all networks
        {
          id: "evm-contract-def-apply-all",
          name: "applyToAllNetworks",
          type: "checkbox",
          label: "Apply to all compatible networks",
          helperText: "Apply this default provider setting to all compatible networks in your project.",
          validation: {},
          defaultValue: false,
          metadata: {
            nestUnder: "defaultProvider",
            disabledWhen: { field: "defaultProvider", equals: "" }
          }
        }
      ]
    }
  ];
}

// src/query/adapter-query.ts
import { logger as logger33 } from "@openzeppelin/ui-utils";
async function queryEvmViewFunction2(contractAddress, functionId, networkConfig, params = [], contractSchema, _walletImplementation, loadContractCallback) {
  let schema = contractSchema;
  if (!schema) {
    if (loadContractCallback) {
      logger33.debug("adapter-query", `Loading contract schema for ${contractAddress} via callback`);
      schema = await loadContractCallback(contractAddress);
    } else {
      throw new Error(
        "Contract schema is required for view function query. Provide either a contractSchema or a loadContractCallback."
      );
    }
  }
  const rpcUrl = resolveRpcUrl(networkConfig);
  logger33.debug("adapter-query", `Using RPC URL for query: ${rpcUrl}`);
  return queryEvmViewFunction(
    contractAddress,
    functionId,
    params,
    schema,
    rpcUrl,
    networkConfig
  );
}

// src/transaction/components/EvmRelayerOptions.tsx
import React2 from "react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@openzeppelin/ui-components";

// src/transaction/components/AdvancedInfo.tsx
import { Info } from "lucide-react";
import { Button as Button5 } from "@openzeppelin/ui-components";
import { jsx as jsx8, jsxs as jsxs7 } from "react/jsx-runtime";
var AdvancedInfo = ({ showAdvancedInfo, onToggle }) => {
  return /* @__PURE__ */ jsxs7("div", { className: "space-y-2", children: [
    /* @__PURE__ */ jsxs7("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsx8("label", { className: "text-base font-medium", children: "Gas Pricing Strategy" }),
      /* @__PURE__ */ jsxs7(Button5, { variant: "ghost", size: "sm", onClick: onToggle, className: "text-xs", type: "button", children: [
        /* @__PURE__ */ jsx8(Info, { className: "h-3 w-3 mr-1" }),
        "API Requirements"
      ] })
    ] }),
    showAdvancedInfo && /* @__PURE__ */ jsx8("div", { className: "mt-3 rounded-lg bg-muted/30 p-4", children: /* @__PURE__ */ jsxs7("p", { className: "text-sm text-muted-foreground leading-relaxed", children: [
      "The OpenZeppelin Relayer API requires exactly one pricing strategy: either a",
      " ",
      /* @__PURE__ */ jsx8("strong", { children: "Speed" }),
      " enum value (FASTEST, FAST, AVERAGE, SAFE_LOW) or",
      " ",
      /* @__PURE__ */ jsx8("strong", { children: "custom gas parameters" }),
      " (gasPrice for legacy, or maxFeePerGas + maxPriorityFeePerGas for EIP-1559)."
    ] }) })
  ] });
};

// src/transaction/components/CustomGasParameters.tsx
import { Circle } from "lucide-react";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
  BooleanField,
  NumberField
} from "@openzeppelin/ui-components";
import { cn as cn5 } from "@openzeppelin/ui-utils";
import { jsx as jsx9, jsxs as jsxs8 } from "react/jsx-runtime";
var CustomGasParameters = ({
  control,
  configMode,
  gasType,
  showGasLimit,
  onGasTypeSwitch
}) => {
  return /* @__PURE__ */ jsxs8("div", { className: "space-y-4", children: [
    /* @__PURE__ */ jsx9("div", { className: "rounded-lg bg-muted/50 p-4", children: /* @__PURE__ */ jsxs8("p", { className: "text-sm text-muted-foreground leading-relaxed", children: [
      "Manually configure gas parameters. You must provide either ",
      /* @__PURE__ */ jsx9("strong", { children: "Legacy" }),
      " ",
      "(gasPrice) or ",
      /* @__PURE__ */ jsx9("strong", { children: "EIP-1559" }),
      " (maxFeePerGas + maxPriorityFeePerGas) values."
    ] }) }),
    /* @__PURE__ */ jsxs8("div", { className: "space-y-3", children: [
      /* @__PURE__ */ jsx9("p", { className: "text-xs text-muted-foreground font-medium uppercase tracking-wider", children: "Select Gas Pricing Method" }),
      /* @__PURE__ */ jsxs8(
        Accordion,
        {
          type: "single",
          collapsible: true,
          value: gasType,
          onValueChange: (value) => value && onGasTypeSwitch(value),
          className: "w-full space-y-3",
          children: [
            /* @__PURE__ */ jsxs8(
              AccordionItem,
              {
                value: "eip1559",
                className: cn5(
                  "rounded-lg border shadow-sm overflow-hidden transition-all",
                  gasType === "eip1559" ? "border-primary bg-primary/5" : "border-border bg-card hover:border-muted-foreground/50"
                ),
                children: [
                  /* @__PURE__ */ jsx9(AccordionTrigger, { className: "px-4 py-3 text-sm font-medium hover:no-underline", children: /* @__PURE__ */ jsxs8("div", { className: "flex items-center justify-between w-full", children: [
                    /* @__PURE__ */ jsxs8("div", { className: "flex items-center gap-3", children: [
                      /* @__PURE__ */ jsxs8("div", { className: "relative", children: [
                        /* @__PURE__ */ jsx9(
                          Circle,
                          {
                            className: `h-4 w-4 ${gasType === "eip1559" ? "text-primary" : "text-muted-foreground"}`
                          }
                        ),
                        gasType === "eip1559" && /* @__PURE__ */ jsx9(Circle, { className: "h-4 w-4 absolute inset-0 text-primary fill-primary scale-50" })
                      ] }),
                      /* @__PURE__ */ jsx9("span", { children: "EIP-1559" })
                    ] }),
                    gasType === "eip1559" && /* @__PURE__ */ jsx9("span", { className: "text-xs text-primary font-medium mr-2", children: "Selected" })
                  ] }) }),
                  /* @__PURE__ */ jsx9(AccordionContent, { children: /* @__PURE__ */ jsxs8("div", { className: "px-4 pb-4 pt-4 grid gap-4 border-t bg-background/50", children: [
                    /* @__PURE__ */ jsx9(
                      NumberField,
                      {
                        id: "maxFeePerGas",
                        label: "Max Fee Per Gas",
                        name: "transactionOptions.maxFeePerGas",
                        control,
                        placeholder: "30",
                        helperText: "Maximum total fee per gas unit you're willing to pay (in gwei)",
                        step: 0.1,
                        min: 0,
                        validation: { required: configMode === "custom" && gasType === "eip1559" }
                      }
                    ),
                    /* @__PURE__ */ jsx9(
                      NumberField,
                      {
                        id: "maxPriorityFeePerGas",
                        label: "Max Priority Fee Per Gas",
                        name: "transactionOptions.maxPriorityFeePerGas",
                        control,
                        placeholder: "2",
                        helperText: "Priority fee (tip) to incentivize miners (in gwei)",
                        step: 0.1,
                        min: 0,
                        validation: { required: configMode === "custom" && gasType === "eip1559" }
                      }
                    )
                  ] }) })
                ]
              }
            ),
            /* @__PURE__ */ jsxs8(
              AccordionItem,
              {
                value: "legacy",
                className: cn5(
                  "rounded-lg border shadow-sm overflow-hidden transition-all",
                  gasType === "legacy" ? "border-primary bg-primary/5" : "border-border bg-card hover:border-muted-foreground/50"
                ),
                children: [
                  /* @__PURE__ */ jsx9(AccordionTrigger, { className: "px-4 py-3 text-sm font-medium hover:no-underline", children: /* @__PURE__ */ jsxs8("div", { className: "flex items-center justify-between w-full", children: [
                    /* @__PURE__ */ jsxs8("div", { className: "flex items-center gap-3", children: [
                      /* @__PURE__ */ jsxs8("div", { className: "relative", children: [
                        /* @__PURE__ */ jsx9(
                          Circle,
                          {
                            className: `h-4 w-4 ${gasType === "legacy" ? "text-primary" : "text-muted-foreground"}`
                          }
                        ),
                        gasType === "legacy" && /* @__PURE__ */ jsx9(Circle, { className: "h-4 w-4 absolute inset-0 text-primary fill-primary scale-50" })
                      ] }),
                      /* @__PURE__ */ jsx9("span", { children: "Legacy Gas Price" })
                    ] }),
                    gasType === "legacy" && /* @__PURE__ */ jsx9("span", { className: "text-xs text-primary font-medium mr-2", children: "Selected" })
                  ] }) }),
                  /* @__PURE__ */ jsx9(AccordionContent, { children: /* @__PURE__ */ jsx9("div", { className: "px-4 pb-4 pt-4 border-t bg-background/50", children: /* @__PURE__ */ jsx9(
                    NumberField,
                    {
                      id: "gasPrice",
                      label: "Gas Price",
                      name: "transactionOptions.gasPrice",
                      control,
                      placeholder: "20",
                      helperText: "Fixed gas price for legacy transactions (in gwei)",
                      step: 0.1,
                      min: 0,
                      validation: { required: configMode === "custom" && gasType === "legacy" }
                    }
                  ) }) })
                ]
              }
            )
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxs8("div", { className: "space-y-2", children: [
      /* @__PURE__ */ jsx9(
        BooleanField,
        {
          id: "showGasLimit",
          label: "Override gas limit",
          name: "transactionOptions.showGasLimit",
          control,
          helperText: "Enable manual gas limit configuration"
        }
      ),
      showGasLimit && /* @__PURE__ */ jsx9("div", { className: "pl-6", children: /* @__PURE__ */ jsx9(
        NumberField,
        {
          id: "gasLimit",
          label: "Gas Limit",
          name: "transactionOptions.gasLimit",
          control,
          placeholder: "Auto-detected by relayer",
          helperText: "Leave empty to let the relayer estimate. Only override if you need a specific limit.",
          step: 1e3,
          min: 21e3
        }
      ) })
    ] })
  ] });
};

// src/transaction/components/SpeedSelection.tsx
import { Speed } from "@openzeppelin/relayer-sdk";
import { RadioGroup, RadioGroupItem } from "@openzeppelin/ui-components";
import { jsx as jsx10, jsxs as jsxs9 } from "react/jsx-runtime";
var speedOptions = [
  {
    value: Speed.FASTEST,
    label: "Fastest",
    description: "Maximum priority, highest gas prices"
  },
  {
    value: Speed.FAST,
    label: "Fast",
    description: "High priority, recommended for most transactions",
    recommended: true
  },
  {
    value: Speed.AVERAGE,
    label: "Average",
    description: "Standard priority, balanced cost"
  },
  {
    value: Speed.SAFE_LOW,
    label: "Safe Low",
    description: "Lower priority, minimal gas cost"
  }
];
var SpeedSelection = ({ selectedSpeed, onSpeedChange }) => {
  return /* @__PURE__ */ jsx10(
    RadioGroup,
    {
      value: selectedSpeed || Speed.FAST,
      onValueChange: (value) => onSpeedChange(value),
      children: /* @__PURE__ */ jsx10("div", { className: "space-y-3", children: speedOptions.map((option) => /* @__PURE__ */ jsxs9(
        "label",
        {
          htmlFor: `speed-${option.value}`,
          className: `relative block rounded-lg border p-4 cursor-pointer transition-colors ${selectedSpeed === option.value ? "border-primary bg-primary/5" : "border-border hover:border-muted-foreground/50"}`,
          children: [
            option.recommended && /* @__PURE__ */ jsx10("span", { className: "absolute -top-2 right-4 bg-primary text-primary-foreground text-xs px-2 py-0.5 rounded", children: "Recommended" }),
            /* @__PURE__ */ jsxs9("div", { className: "flex items-start space-x-3", children: [
              /* @__PURE__ */ jsx10(
                RadioGroupItem,
                {
                  value: option.value,
                  id: `speed-${option.value}`,
                  className: "mt-0.5"
                }
              ),
              /* @__PURE__ */ jsxs9("div", { className: "flex-1", children: [
                /* @__PURE__ */ jsx10("div", { className: "font-medium", children: option.label }),
                /* @__PURE__ */ jsx10("p", { className: "text-sm text-muted-foreground mt-0.5", children: option.description })
              ] })
            ] })
          ]
        },
        option.value
      )) })
    }
  );
};

// src/transaction/components/useEvmRelayerOptions.ts
import { useEffect as useEffect6, useRef as useRef2 } from "react";
import { useForm } from "react-hook-form";
import { Speed as Speed2 } from "@openzeppelin/relayer-sdk";
var useEvmRelayerOptions = ({ options, onChange }) => {
  const onChangeRef = useRef2(onChange);
  onChangeRef.current = onChange;
  const initialOptions = {
    speed: (() => {
      const hasCustomSettings2 = Boolean(
        options.gasPrice || options.maxFeePerGas || options.maxPriorityFeePerGas
      );
      return options.speed || (!hasCustomSettings2 ? Speed2.FAST : void 0);
    })(),
    gasPrice: weiToGwei(options.gasPrice),
    maxFeePerGas: weiToGwei(options.maxFeePerGas),
    maxPriorityFeePerGas: weiToGwei(options.maxPriorityFeePerGas),
    gasLimit: options.gasLimit,
    showGasLimit: Boolean(options.gasLimit)
  };
  const { control, setValue, watch } = useForm({
    defaultValues: {
      transactionOptions: initialOptions
    }
  });
  const formValues = watch("transactionOptions");
  const isInitialMount = useRef2(true);
  const hasCustomSettings = Boolean(
    formValues.gasPrice || formValues.maxFeePerGas || formValues.maxPriorityFeePerGas
  );
  const configMode = hasCustomSettings ? "custom" : "speed";
  const isEip1559 = Boolean(formValues.maxFeePerGas || formValues.maxPriorityFeePerGas);
  const gasType = isEip1559 ? "eip1559" : "legacy";
  useEffect6(() => {
    if (isInitialMount.current) {
      isInitialMount.current = false;
      if (initialOptions.speed && !options.speed) {
        const newOptions = {};
        if (initialOptions.speed) newOptions.speed = initialOptions.speed;
        if (initialOptions.gasLimit) newOptions.gasLimit = initialOptions.gasLimit;
        onChange(newOptions);
      }
      return;
    }
  }, []);
  useEffect6(() => {
    if (isInitialMount.current) {
      return;
    }
    const timeoutId = setTimeout(() => {
      const newOptions = {};
      if (formValues.speed) newOptions.speed = formValues.speed;
      if (formValues.gasPrice) newOptions.gasPrice = gweiToWei(formValues.gasPrice);
      if (formValues.maxFeePerGas) newOptions.maxFeePerGas = gweiToWei(formValues.maxFeePerGas);
      if (formValues.maxPriorityFeePerGas) {
        newOptions.maxPriorityFeePerGas = gweiToWei(formValues.maxPriorityFeePerGas);
      }
      if (formValues.gasLimit) newOptions.gasLimit = formValues.gasLimit;
      onChangeRef.current(newOptions);
    }, 100);
    return () => clearTimeout(timeoutId);
  }, [
    formValues.speed,
    formValues.gasPrice,
    formValues.maxFeePerGas,
    formValues.maxPriorityFeePerGas,
    formValues.gasLimit
  ]);
  const handleSpeedChange = (speed) => {
    setValue("transactionOptions", {
      ...formValues,
      speed,
      gasPrice: void 0,
      maxFeePerGas: void 0,
      maxPriorityFeePerGas: void 0
    });
  };
  const handleModeChange = (mode) => {
    if (mode === "speed") {
      setValue("transactionOptions", {
        ...formValues,
        speed: Speed2.FAST,
        gasPrice: void 0,
        maxFeePerGas: void 0,
        maxPriorityFeePerGas: void 0
      });
    } else {
      setValue("transactionOptions", {
        ...formValues,
        speed: void 0,
        maxFeePerGas: 30,
        maxPriorityFeePerGas: 2
      });
    }
  };
  const handleGasTypeSwitch = (type) => {
    if (type === "eip1559") {
      setValue("transactionOptions", {
        ...formValues,
        gasPrice: void 0,
        maxFeePerGas: 30,
        maxPriorityFeePerGas: 2
      });
    } else {
      setValue("transactionOptions", {
        ...formValues,
        maxFeePerGas: void 0,
        maxPriorityFeePerGas: void 0,
        gasPrice: 20
      });
    }
  };
  return {
    control,
    formValues,
    configMode,
    gasType,
    handleSpeedChange,
    handleModeChange,
    handleGasTypeSwitch
  };
};

// src/transaction/components/EvmRelayerOptions.tsx
import { jsx as jsx11, jsxs as jsxs10 } from "react/jsx-runtime";
var EvmRelayerOptions = ({ options, onChange }) => {
  const [showAdvancedInfo, setShowAdvancedInfo] = React2.useState(false);
  const {
    control,
    formValues,
    configMode,
    gasType,
    handleSpeedChange,
    handleModeChange,
    handleGasTypeSwitch
  } = useEvmRelayerOptions({ options, onChange });
  return /* @__PURE__ */ jsxs10("div", { className: "space-y-4", children: [
    /* @__PURE__ */ jsx11(
      AdvancedInfo,
      {
        showAdvancedInfo,
        onToggle: () => setShowAdvancedInfo(!showAdvancedInfo)
      }
    ),
    /* @__PURE__ */ jsxs10(Tabs, { value: configMode, onValueChange: handleModeChange, children: [
      /* @__PURE__ */ jsxs10(TabsList, { className: "grid w-full grid-cols-2", children: [
        /* @__PURE__ */ jsx11(TabsTrigger, { value: "speed", children: "Speed" }),
        /* @__PURE__ */ jsx11(TabsTrigger, { value: "custom", children: "Custom" })
      ] }),
      /* @__PURE__ */ jsx11(TabsContent, { value: "speed", className: "space-y-4", children: /* @__PURE__ */ jsx11(SpeedSelection, { selectedSpeed: formValues.speed, onSpeedChange: handleSpeedChange }) }),
      /* @__PURE__ */ jsx11(TabsContent, { value: "custom", className: "space-y-4", children: /* @__PURE__ */ jsx11(
        CustomGasParameters,
        {
          control,
          configMode,
          gasType,
          showGasLimit: formValues.showGasLimit || false,
          onGasTypeSwitch: handleGasTypeSwitch
        }
      ) })
    ] })
  ] });
};

// src/wallet/utils/connection.ts
import { logger as logger34 } from "@openzeppelin/ui-utils";
var LOG_SYSTEM2 = "adapter-evm-connection";
function evmSupportsWalletConnection() {
  return true;
}
async function getEvmAvailableConnectors() {
  const impl = await getEvmWalletImplementation();
  if (!impl) {
    logger34.warn(LOG_SYSTEM2, "getEvmAvailableConnectors: Wallet implementation not ready.");
    return [];
  }
  return impl.getAvailableConnectors();
}
async function connectAndEnsureCorrectNetwork(connectorId, targetChainId) {
  const impl = await getEvmWalletImplementation();
  if (!impl) {
    logger34.error(LOG_SYSTEM2, "connectAndEnsureCorrectNetwork: Wallet implementation not ready.");
    return { connected: false, error: "Wallet system not initialized." };
  }
  return connectAndEnsureCorrectNetworkCore(impl, connectorId, targetChainId, LOG_SYSTEM2);
}
async function disconnectEvmWallet() {
  const impl = await getEvmWalletImplementation();
  if (!impl) {
    logger34.warn(LOG_SYSTEM2, "disconnectEvmWallet: Wallet implementation not ready.");
    return { disconnected: false, error: "Wallet system not initialized." };
  }
  return impl.disconnect();
}
function getEvmWalletConnectionStatus() {
  const impl = getInitializedEvmWalletImplementation();
  if (!impl) {
    logger34.warn(
      LOG_SYSTEM2,
      "getEvmWalletConnectionStatus: Wallet implementation not ready. Returning default disconnected state."
    );
    return DEFAULT_DISCONNECTED_STATUS;
  }
  return impl.getWalletConnectionStatus();
}

// src/wallet/utils/uiKitService.ts
import { logger as logger35 } from "@openzeppelin/ui-utils";

// src/wallet/rainbowkit/components.tsx
var RainbowKitConnectButton = createRainbowKitConnectButton(evmUiKitManager);

// src/wallet/rainbowkit/componentFactory.ts
function createRainbowKitComponents2() {
  return createRainbowKitComponents(RainbowKitConnectButton);
}

// src/wallet/utils/uiKitService.ts
function getResolvedWalletComponents(uiKitConfiguration) {
  logger35.debug(
    "uiKitService:getResolvedWalletComponents",
    "Received uiKitConfiguration:",
    JSON.stringify(uiKitConfiguration)
  );
  const currentKitName = uiKitConfiguration.kitName || "custom";
  if (currentKitName === "none") {
    logger35.info(
      "uiKitService",
      'UI Kit set to "none" for getResolvedWalletComponents, not providing wallet components.'
    );
    return void 0;
  }
  const exclusions = getComponentExclusionsFromConfig(uiKitConfiguration.kitConfig);
  logger35.debug(
    "uiKitService",
    `Extracted component exclusions for ${currentKitName}: ${exclusions.join(", ") || "none"}.`
  );
  if (currentKitName === "custom") {
    const allCustomComponents = {
      ConnectButton: CustomConnectButton,
      AccountDisplay: CustomAccountDisplay,
      NetworkSwitcher: CustomNetworkSwitcher
    };
    return filterWalletComponents(allCustomComponents, exclusions, currentKitName);
  }
  if (currentKitName === "rainbowkit") {
    const validation = validateRainbowKitConfig(uiKitConfiguration.kitConfig);
    if (!validation.isValid) {
      logger35.warn(
        "uiKitService",
        `Invalid RainbowKit configuration for components: ${validation.error}. No components provided.`
      );
      return void 0;
    }
    const rainbowKitComponents = createRainbowKitComponents2();
    logger35.info("uiKitService", "Providing RainbowKit components.");
    return filterWalletComponents(rainbowKitComponents, exclusions, currentKitName);
  }
  logger35.warn(
    "uiKitService",
    `UI Kit "${currentKitName}" for getResolvedWalletComponents not explicitly supported. No components provided.`
  );
  return void 0;
}

// src/wallet/utils/wallet-status.ts
function convertWagmiToEvmStatus(wagmiStatus) {
  return {
    isConnected: wagmiStatus.isConnected,
    isConnecting: wagmiStatus.isConnecting,
    isDisconnected: wagmiStatus.isDisconnected,
    isReconnecting: wagmiStatus.isReconnecting,
    status: wagmiStatus.status,
    address: wagmiStatus.address,
    chainId: wagmiStatus.chainId?.toString(),
    addresses: wagmiStatus.addresses,
    connector: wagmiStatus.connector ? {
      id: wagmiStatus.connector.id,
      name: wagmiStatus.connector.name,
      type: wagmiStatus.connector.type
    } : void 0,
    chain: wagmiStatus.chain ? { ...wagmiStatus.chain } : void 0
  };
}

// src/wallet/utils.ts
function getResolvedWalletComponents2(uiKitConfig2) {
  return getResolvedWalletComponents(uiKitConfig2);
}

// src/adapter.ts
var isTypedEvmNetworkConfig = (config) => config.ecosystem === "evm";
var EvmAdapter = class {
  constructor(networkConfig) {
    __publicField(this, "networkConfig");
    __publicField(this, "initialAppServiceKitName");
    if (!isTypedEvmNetworkConfig(networkConfig)) {
      throw new Error("EvmAdapter requires a valid EVM network configuration.");
    }
    this.networkConfig = networkConfig;
    logger36.info(
      "EvmAdapter",
      `Adapter initialized for network: ${networkConfig.name} (ID: ${networkConfig.id})`
    );
    const initialGlobalConfig = loadInitialConfigFromAppService();
    this.initialAppServiceKitName = initialGlobalConfig.kitName || "custom";
    logger36.info(
      "EvmAdapter:constructor",
      "Initial kitName from AppConfigService noted:",
      this.initialAppServiceKitName
    );
  }
  /**
   * @inheritdoc
   */
  getNetworkServiceForms() {
    return getEvmNetworkServiceForms(this.networkConfig);
  }
  /**
   * @inheritdoc
   */
  async validateNetworkServiceConfig(serviceId, values) {
    return validateEvmNetworkServiceConfig(serviceId, values);
  }
  /**
   * @inheritdoc
   */
  async testNetworkServiceConnection(serviceId, values) {
    return testEvmNetworkServiceConnection(serviceId, values, this.networkConfig);
  }
  /**
   * @inheritdoc
   */
  getDefaultServiceConfig(serviceId) {
    return getEvmDefaultServiceConfig(this.networkConfig, serviceId);
  }
  /**
   * @inheritdoc
   */
  async loadContract(source) {
    return loadContractSchema(source, this.networkConfig);
  }
  /**
   * @inheritdoc
   */
  async loadContractWithMetadata(source) {
    return loadContractWithFullMetadata(source, this.networkConfig);
  }
  /**
   * @inheritdoc
   */
  mapParameterTypeToFieldType(parameterType) {
    return mapEvmParamTypeToFieldType(parameterType);
  }
  /**
   * @inheritdoc
   */
  getCompatibleFieldTypes(parameterType) {
    return getEvmCompatibleFieldTypes(parameterType);
  }
  /**
   * @inheritdoc
   */
  generateDefaultField(parameter) {
    return generateEvmDefaultField(parameter);
  }
  /**
   * @inheritdoc
   */
  formatTransactionData(contractSchema, functionId, submittedInputs, fields) {
    return formatEvmTransactionData(contractSchema, functionId, submittedInputs, fields);
  }
  /**
   * @inheritdoc
   */
  async signAndBroadcast(transactionData, executionConfig, onStatusChange, runtimeApiKey) {
    const walletImplementation = await getEvmWalletImplementation();
    return executeEvmTransaction(
      transactionData,
      executionConfig,
      walletImplementation,
      onStatusChange,
      runtimeApiKey
    );
  }
  /**
   * @inheritdoc
   */
  async getRelayers(serviceUrl, accessToken) {
    const relayerStrategy = new RelayerExecutionStrategy();
    return relayerStrategy.getEvmRelayers(serviceUrl, accessToken, this.networkConfig);
  }
  /**
   * @inheritdoc
   */
  async getRelayer(serviceUrl, accessToken, relayerId) {
    const relayerStrategy = new RelayerExecutionStrategy();
    return relayerStrategy.getEvmRelayer(serviceUrl, accessToken, relayerId, this.networkConfig);
  }
  /**
   * Returns a React component for configuring EVM-specific relayer transaction options.
   * @returns The EVM relayer options component
   */
  getRelayerOptionsComponent() {
    return EvmRelayerOptions;
  }
  /**
   * @inheritdoc
   */
  getWritableFunctions(contractSchema) {
    return contractSchema.functions.filter((fn) => fn.modifiesState);
  }
  /**
   * @inheritdoc
   */
  isValidAddress(address, _addressType) {
    return isValidEvmAddress(address);
  }
  /**
   * @inheritdoc
   */
  async getSupportedExecutionMethods() {
    return getEvmSupportedExecutionMethods();
  }
  /**
   * @inheritdoc
   */
  async validateExecutionConfig(config) {
    const walletStatus = this.getWalletConnectionStatus();
    return validateEvmExecutionConfig(config, walletStatus);
  }
  /**
   * @inheritdoc
   */
  isViewFunction(functionDetails) {
    return isEvmViewFunction(functionDetails);
  }
  /**
   * @inheritdoc
   */
  filterAutoQueryableFunctions(functions) {
    const skipNames = /* @__PURE__ */ new Set([
      "admin",
      "implementation",
      "getImplementation",
      "_implementation",
      "proxyAdmin",
      "changeAdmin",
      "upgradeTo",
      "upgradeToAndCall"
    ]);
    return functions.filter((f) => !skipNames.has(f.name));
  }
  /**
   * @inheritdoc
   */
  async queryViewFunction(contractAddress, functionId, params = [], contractSchema) {
    const walletImplementation = await getEvmWalletImplementation();
    return queryEvmViewFunction2(
      contractAddress,
      functionId,
      this.networkConfig,
      params,
      contractSchema,
      walletImplementation,
      (src) => this.loadContract({ contractAddress: src })
    );
  }
  /**
   * @inheritdoc
   */
  formatFunctionResult(decodedValue, functionDetails) {
    return formatEvmFunctionResult(decodedValue, functionDetails);
  }
  /**
   * @inheritdoc
   */
  supportsWalletConnection() {
    return evmSupportsWalletConnection();
  }
  /**
   * @inheritdoc
   */
  async getAvailableConnectors() {
    return getEvmAvailableConnectors();
  }
  /**
   * @inheritdoc
   */
  async connectWallet(connectorId) {
    const result = await connectAndEnsureCorrectNetwork(connectorId, this.networkConfig.chainId);
    if (result.connected && result.address) {
      return { connected: true, address: result.address };
    } else {
      return {
        connected: false,
        error: result.error || "Connection failed for an unknown reason."
      };
    }
  }
  /**
   * @inheritdoc
   */
  async disconnectWallet() {
    return disconnectEvmWallet();
  }
  /**
   * @inheritdoc
   */
  getWalletConnectionStatus() {
    const status = getEvmWalletConnectionStatus();
    return convertWagmiToEvmStatus(status);
  }
  /**
   * @inheritdoc
   */
  onWalletConnectionChange(callback) {
    const walletImplementation = getInitializedEvmWalletImplementation();
    if (!walletImplementation) {
      logger36.warn(
        "EvmAdapter:onWalletConnectionChange",
        "Wallet implementation not ready. Subscription may not work."
      );
      return () => {
      };
    }
    return walletImplementation.onWalletConnectionChange(
      (currentWagmiStatus, previousWagmiStatus) => {
        const current = convertWagmiToEvmStatus(currentWagmiStatus);
        const previous = convertWagmiToEvmStatus(previousWagmiStatus);
        callback(current, previous);
      }
    );
  }
  /**
   * @inheritdoc
   */
  getExplorerUrl(address) {
    return getEvmExplorerAddressUrl(address, this.networkConfig);
  }
  /**
   * @inheritdoc
   */
  getExplorerTxUrl(txHash) {
    if (getEvmExplorerTxUrl) {
      return getEvmExplorerTxUrl(txHash, this.networkConfig);
    }
    return null;
  }
  /**
   * @inheritdoc
   */
  async getCurrentBlock() {
    return getEvmCurrentBlock(this.networkConfig);
  }
  /**
   * @inheritdoc
   */
  async waitForTransactionConfirmation(txHash) {
    const walletImplementation = await getEvmWalletImplementation();
    return waitForEvmTransactionConfirmation(txHash, walletImplementation);
  }
  /**
   * @inheritdoc
   */
  async configureUiKit(programmaticOverrides = {}, options) {
    const currentAppServiceConfig = loadInitialConfigFromAppService();
    const finalFullConfig = await resolveFullUiKitConfiguration(
      programmaticOverrides,
      this.initialAppServiceKitName,
      currentAppServiceConfig,
      options
    );
    await evmUiKitManager.configure(finalFullConfig);
    logger36.info(
      "EvmAdapter:configureUiKit",
      "EvmUiKitManager configuration requested with final config:",
      finalFullConfig
    );
  }
  /**
   * @inheritdoc
   */
  getEcosystemReactUiContextProvider() {
    logger36.info("EvmAdapter:getEcosystemReactUiContextProvider", "Returning EvmWalletUiRoot.");
    return EvmWalletUiRoot;
  }
  /**
   * @inheritdoc
   */
  getEcosystemReactHooks() {
    return evmFacadeHooks;
  }
  /**
   * @inheritdoc
   */
  getSupportedContractDefinitionProviders() {
    return [
      { key: EvmProviderKeys.Etherscan, label: "Etherscan" },
      { key: EvmProviderKeys.Sourcify, label: "Sourcify" }
    ];
  }
  /**
   * @inheritdoc
   */
  getEcosystemWalletComponents() {
    const currentManagerState = evmUiKitManager.getState();
    if (!currentManagerState.currentFullUiKitConfig) {
      logger36.debug(
        // Changed from warn to debug, as this can be normal during init sequence
        "EvmAdapter:getEcosystemWalletComponents",
        "No UI kit configuration available in manager yet. Returning undefined components."
      );
      return void 0;
    }
    return getResolvedWalletComponents2(currentManagerState.currentFullUiKitConfig);
  }
  async getAvailableUiKits() {
    const rainbowkitDefaultCode = generateRainbowKitConfigFile({});
    return [
      {
        id: "custom",
        name: "Wagmi Custom",
        configFields: []
      },
      {
        id: "rainbowkit",
        name: "RainbowKit",
        linkToDocs: "https://www.rainbowkit.com/docs/installation#configure",
        description: `Configure RainbowKit for your exported application. This code will be saved as <code class="bg-muted px-1 py-0.5 rounded text-xs">rainbowkit.config.ts</code>.<br/><br/>
<strong>Export Only:</strong> This configuration is <em>only used in exported apps</em>. The preview always uses the default RainbowKit configuration.<br/><br/>
<strong>Available options:</strong><br/>
\u2022 <code>wagmiParams</code>: Configure app name, projectId, wallets, etc.<br/>
\u2022 <code>providerProps</code>: Set theme, modal size, and other UI options<br/><br/>
Get your WalletConnect projectId from <a href="https://cloud.walletconnect.com" target="_blank" rel="noopener" class="text-primary underline">cloud.walletconnect.com</a>`,
        hasCodeEditor: true,
        defaultCode: rainbowkitDefaultCode,
        configFields: []
      }
    ];
  }
  async getExportableWalletConfigFiles(uiKitConfig2) {
    if (uiKitConfig2?.kitName === "rainbowkit") {
      return generateRainbowKitExportables(uiKitConfig2);
    }
    return {};
  }
  /**
   * @inheritdoc
   */
  getUiLabels() {
    return {
      relayerConfigTitle: "Gas Configuration",
      relayerConfigActiveDesc: "Customize gas pricing strategy for transaction submission",
      relayerConfigInactiveDesc: "Using recommended gas configuration for reliable transactions",
      relayerConfigPresetTitle: "Fast Speed Preset Active",
      relayerConfigPresetDesc: "Transactions will use high priority gas pricing for quick inclusion",
      relayerConfigCustomizeBtn: "Customize Gas Settings",
      detailsTitle: "Relayer Details",
      network: "Network",
      relayerId: "Relayer ID",
      active: "Active",
      paused: "Paused",
      systemDisabled: "System Disabled",
      balance: "Balance",
      nonce: "Nonce",
      pending: "Pending Transactions",
      lastTransaction: "Last Transaction"
    };
  }
  /**
   * @inheritdoc
   */
  getContractDefinitionInputs() {
    return [
      {
        id: "contractAddress",
        name: "contractAddress",
        label: "Contract Address",
        type: "blockchain-address",
        validation: { required: true },
        placeholder: "0x1234...abcd",
        helperText: "Enter the deployed contract address. For verified contracts, the ABI will be fetched automatically from the block explorer."
      },
      {
        id: "contractDefinition",
        name: "contractDefinition",
        label: "Contract ABI (Optional)",
        type: "code-editor",
        validation: { required: false },
        placeholder: '[{"inputs":[],"name":"myFunction","outputs":[],"stateMutability":"nonpayable","type":"function"}]',
        helperText: "If the contract is not verified on the block explorer, paste the contract's ABI JSON here. You can find this in your contract's compilation artifacts or deployment files.",
        codeEditorProps: {
          language: "json",
          placeholder: "Paste your contract ABI JSON here...",
          maxHeight: "500px",
          performanceThreshold: 3e3
          // Disable syntax highlighting for large ABIs
        }
      }
    ];
  }
  /**
   * @inheritdoc
   */
  async validateRpcEndpoint(rpcConfig) {
    return validateEvmRpcEndpoint(rpcConfig);
  }
  /**
   * @inheritdoc
   */
  async testRpcConnection(rpcConfig) {
    return testEvmRpcConnection(rpcConfig);
  }
  /**
   * @inheritdoc
   */
  async validateExplorerConfig(explorerConfig) {
    return validateEvmExplorerConfig(explorerConfig);
  }
  /**
   * @inheritdoc
   */
  async testExplorerConnection(explorerConfig) {
    return testEvmExplorerConnection(explorerConfig, this.networkConfig);
  }
  /**
   * @inheritdoc
   */
  async compareContractDefinitions(storedSchema, freshSchema) {
    return compareContractDefinitions(storedSchema, freshSchema);
  }
  /**
   * @inheritdoc
   */
  validateContractDefinition(definition) {
    return validateContractDefinition(definition);
  }
  /**
   * @inheritdoc
   */
  hashContractDefinition(definition) {
    return hashContractDefinition(definition);
  }
  /**
   * @inheritdoc
   */
  getTypeMappingInfo() {
    return getEvmTypeMappingInfo();
  }
};

// src/config.ts
var evmAdapterConfig = {
  /**
   * Dependencies required by the EVM adapter
   * These will be included in exported projects that use this adapter
   */
  dependencies: {
    // Runtime dependencies
    runtime: {
      // Core EVM libraries
      // Wallet connection libraries
      wagmi: "^2.15.0",
      "@wagmi/core": "^2.20.3",
      viem: "^2.28.0",
      "@tanstack/react-query": "^5.0.0"
      // Utility library
      // lodash: '^4.17.21',
    },
    // Development dependencies
    dev: {
      // '@types/lodash': '^4.17.16',
      "@types/lodash": "^4.17.5"
    }
  },
  overrides: {
    "use-sync-external-store": "^1.2.0",
    valtio: "^1.13.2"
  },
  uiKits: {
    rainbowkit: {
      dependencies: {
        runtime: {
          "@rainbow-me/rainbowkit": "^2.2.8"
        }
      },
      overrides: {
        "@paulmillr/qr": "npm:qr@^0.5.0",
        "@walletconnect/modal": "^2.7.1"
      }
    }
  }
};
export {
  EvmAdapter,
  abiComparisonService,
  arbitrumMainnet,
  arbitrumSepolia,
  avalancheFuji,
  avalancheMainnet,
  baseMainnet,
  baseSepolia,
  bscMainnet,
  bscTestnet,
  ethereumMainnet,
  ethereumSepolia,
  evmAdapterConfig,
  evmMainnetNetworks,
  evmNetworks,
  evmTestnetNetworks,
  extractRainbowKitCustomizations,
  isEvmContractArtifacts,
  isRainbowKitCustomizations,
  lineaMainnet,
  lineaSepolia,
  optimismMainnet,
  optimismSepolia,
  polygonAmoy,
  polygonMainnet,
  polygonZkEvmCardona,
  polygonZkEvmMainnet,
  scrollMainnet,
  scrollSepolia,
  zkSyncEraMainnet,
  zksyncSepoliaTestnet
};
//# sourceMappingURL=index.js.map