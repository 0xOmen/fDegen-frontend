import { TransactionReceipt } from 'viem';
import React from 'react';
import { TypedEvmNetworkConfig, WriteContractParameters, EvmContractDefinitionProviderKey } from '@openzeppelin/ui-builder-adapter-evm-core';
export { AppInfo, EvmContractArtifacts, EvmRelayerTransactionOptions, RainbowKitConnectButtonProps, RainbowKitCustomizations, RainbowKitKitConfig, RainbowKitProviderProps, TypedEvmNetworkConfig, WriteContractParameters, abiComparisonService, extractRainbowKitCustomizations, isEvmContractArtifacts, isRainbowKitCustomizations } from '@openzeppelin/ui-builder-adapter-evm-core';
import { WalletConnectionStatus, ContractAdapter, UiKitConfiguration, NetworkServiceForm, ContractSchema, ProxyInfo, FieldType, FunctionParameter, FormFieldType, ExecutionConfig, TxStatus, TransactionStatusUpdate, RelayerDetails, RelayerDetailsRich, ExecutionMethodDetail, ContractFunction, Connector, NativeConfigLoader, EcosystemReactUiProviderProps, EcosystemSpecificReactHooks, EcosystemWalletComponents, AvailableUiKit, UserRpcProviderConfig, UserExplorerConfig, TypeMappingInfo, AdapterConfig } from '@openzeppelin/ui-types';

/**
 * EVM-specific wallet connection status extending the base interface.
 * Includes EVM-specific fields like multiple addresses and chain information.
 */
interface EvmWalletConnectionStatus extends WalletConnectionStatus {
    /** Additional addresses (EVM multi-address support from wagmi) */
    addresses?: readonly string[];
    /** Chain information (EVM chain details from viem) */
    chain?: {
        id: number;
        name: string;
        [key: string]: unknown;
    };
}

/**
 * EVM-specific adapter implementation
 */
declare class EvmAdapter implements ContractAdapter {
    readonly networkConfig: TypedEvmNetworkConfig;
    readonly initialAppServiceKitName: UiKitConfiguration['kitName'];
    constructor(networkConfig: TypedEvmNetworkConfig);
    /**
     * @inheritdoc
     */
    getNetworkServiceForms(): NetworkServiceForm[];
    /**
     * @inheritdoc
     */
    validateNetworkServiceConfig(serviceId: string, values: Record<string, unknown>): Promise<boolean>;
    /**
     * @inheritdoc
     */
    testNetworkServiceConnection(serviceId: string, values: Record<string, unknown>): Promise<{
        success: boolean;
        latency?: number;
        error?: string;
    }>;
    /**
     * @inheritdoc
     */
    getDefaultServiceConfig(serviceId: string): Record<string, unknown> | null;
    /**
     * @inheritdoc
     */
    loadContract(source: string | Record<string, unknown>): Promise<ContractSchema>;
    /**
     * @inheritdoc
     */
    loadContractWithMetadata(source: string | Record<string, unknown>): Promise<{
        schema: ContractSchema;
        source: 'fetched' | 'manual';
        contractDefinitionOriginal?: string;
        metadata?: {
            fetchedFrom?: string;
            contractName?: string;
            verificationStatus?: 'verified' | 'unverified' | 'unknown';
            fetchTimestamp?: Date;
            definitionHash?: string;
        };
        proxyInfo?: ProxyInfo;
    }>;
    /**
     * @inheritdoc
     */
    mapParameterTypeToFieldType(parameterType: string): FieldType;
    /**
     * @inheritdoc
     */
    getCompatibleFieldTypes(parameterType: string): FieldType[];
    /**
     * @inheritdoc
     */
    generateDefaultField<T extends FieldType = FieldType>(parameter: FunctionParameter): FormFieldType<T>;
    /**
     * @inheritdoc
     */
    formatTransactionData(contractSchema: ContractSchema, functionId: string, submittedInputs: Record<string, unknown>, fields: FormFieldType[]): WriteContractParameters;
    /**
     * @inheritdoc
     */
    signAndBroadcast(transactionData: unknown, executionConfig: ExecutionConfig, onStatusChange: (status: TxStatus, details: TransactionStatusUpdate) => void, runtimeApiKey?: string): Promise<{
        txHash: string;
    }>;
    /**
     * @inheritdoc
     */
    getRelayers(serviceUrl: string, accessToken: string): Promise<RelayerDetails[]>;
    /**
     * @inheritdoc
     */
    getRelayer(serviceUrl: string, accessToken: string, relayerId: string): Promise<RelayerDetailsRich>;
    /**
     * Returns a React component for configuring EVM-specific relayer transaction options.
     * @returns The EVM relayer options component
     */
    getRelayerOptionsComponent(): React.ComponentType<{
        options: Record<string, unknown>;
        onChange: (options: Record<string, unknown>) => void;
    }> | undefined;
    /**
     * @inheritdoc
     */
    getWritableFunctions(contractSchema: ContractSchema): ContractSchema['functions'];
    /**
     * @inheritdoc
     */
    isValidAddress(address: string, _addressType?: string): boolean;
    /**
     * @inheritdoc
     */
    getSupportedExecutionMethods(): Promise<ExecutionMethodDetail[]>;
    /**
     * @inheritdoc
     */
    validateExecutionConfig(config: ExecutionConfig): Promise<true | string>;
    /**
     * @inheritdoc
     */
    isViewFunction(functionDetails: ContractFunction): boolean;
    /**
     * @inheritdoc
     */
    filterAutoQueryableFunctions(functions: ContractFunction[]): ContractFunction[];
    /**
     * @inheritdoc
     */
    queryViewFunction(contractAddress: string, functionId: string, params?: unknown[], contractSchema?: ContractSchema): Promise<unknown>;
    /**
     * @inheritdoc
     */
    formatFunctionResult(decodedValue: unknown, functionDetails: ContractFunction): string;
    /**
     * @inheritdoc
     */
    supportsWalletConnection(): boolean;
    /**
     * @inheritdoc
     */
    getAvailableConnectors(): Promise<Connector[]>;
    /**
     * @inheritdoc
     */
    connectWallet(connectorId: string): Promise<{
        connected: boolean;
        address?: string;
        error?: string;
    }>;
    /**
     * @inheritdoc
     */
    disconnectWallet(): Promise<{
        disconnected: boolean;
        error?: string;
    }>;
    /**
     * @inheritdoc
     */
    getWalletConnectionStatus(): EvmWalletConnectionStatus;
    /**
     * @inheritdoc
     */
    onWalletConnectionChange(callback: (currentStatus: WalletConnectionStatus, previousStatus: WalletConnectionStatus) => void): () => void;
    /**
     * @inheritdoc
     */
    getExplorerUrl(address: string): string | null;
    /**
     * @inheritdoc
     */
    getExplorerTxUrl?(txHash: string): string | null;
    /**
     * @inheritdoc
     */
    getCurrentBlock(): Promise<number>;
    /**
     * @inheritdoc
     */
    waitForTransactionConfirmation(txHash: string): Promise<{
        status: 'success' | 'error';
        receipt?: TransactionReceipt;
        error?: Error;
    }>;
    /**
     * @inheritdoc
     */
    configureUiKit(programmaticOverrides?: Partial<UiKitConfiguration>, options?: {
        loadUiKitNativeConfig?: NativeConfigLoader;
    }): Promise<void>;
    /**
     * @inheritdoc
     */
    getEcosystemReactUiContextProvider(): React.ComponentType<EcosystemReactUiProviderProps> | undefined;
    /**
     * @inheritdoc
     */
    getEcosystemReactHooks(): EcosystemSpecificReactHooks | undefined;
    /**
     * @inheritdoc
     */
    getSupportedContractDefinitionProviders(): Array<{
        key: EvmContractDefinitionProviderKey;
        label?: string;
    }>;
    /**
     * @inheritdoc
     */
    getEcosystemWalletComponents(): EcosystemWalletComponents | undefined;
    getAvailableUiKits(): Promise<AvailableUiKit[]>;
    getExportableWalletConfigFiles(uiKitConfig?: UiKitConfiguration): Promise<Record<string, string>>;
    /**
     * @inheritdoc
     */
    getUiLabels(): Record<string, string> | undefined;
    /**
     * @inheritdoc
     */
    getContractDefinitionInputs(): FormFieldType[];
    /**
     * @inheritdoc
     */
    validateRpcEndpoint(rpcConfig: UserRpcProviderConfig): Promise<boolean>;
    /**
     * @inheritdoc
     */
    testRpcConnection(rpcConfig: UserRpcProviderConfig): Promise<{
        success: boolean;
        latency?: number;
        error?: string;
    }>;
    /**
     * @inheritdoc
     */
    validateExplorerConfig(explorerConfig: UserExplorerConfig): Promise<boolean>;
    /**
     * @inheritdoc
     */
    testExplorerConnection(explorerConfig: UserExplorerConfig): Promise<{
        success: boolean;
        latency?: number;
        error?: string;
    }>;
    /**
     * @inheritdoc
     */
    compareContractDefinitions(storedSchema: string, freshSchema: string): Promise<{
        identical: boolean;
        differences: Array<{
            type: 'added' | 'removed' | 'modified';
            section: string;
            name: string;
            details: string;
            impact: 'low' | 'medium' | 'high';
            oldSignature?: string;
            newSignature?: string;
        }>;
        severity: 'none' | 'minor' | 'major' | 'breaking';
        summary: string;
    }>;
    /**
     * @inheritdoc
     */
    validateContractDefinition(definition: string): {
        valid: boolean;
        errors: string[];
        warnings: string[];
    };
    /**
     * @inheritdoc
     */
    hashContractDefinition(definition: string): string;
    /**
     * @inheritdoc
     */
    getTypeMappingInfo(): TypeMappingInfo;
}

declare const ethereumMainnet: TypedEvmNetworkConfig;
declare const arbitrumMainnet: TypedEvmNetworkConfig;
declare const polygonMainnet: TypedEvmNetworkConfig;
declare const polygonZkEvmMainnet: TypedEvmNetworkConfig;
declare const baseMainnet: TypedEvmNetworkConfig;
declare const bscMainnet: TypedEvmNetworkConfig;
declare const optimismMainnet: TypedEvmNetworkConfig;
declare const avalancheMainnet: TypedEvmNetworkConfig;
declare const zkSyncEraMainnet: TypedEvmNetworkConfig;
declare const scrollMainnet: TypedEvmNetworkConfig;
declare const lineaMainnet: TypedEvmNetworkConfig;

declare const ethereumSepolia: TypedEvmNetworkConfig;
declare const arbitrumSepolia: TypedEvmNetworkConfig;
declare const polygonAmoy: TypedEvmNetworkConfig;
declare const polygonZkEvmCardona: TypedEvmNetworkConfig;
declare const baseSepolia: TypedEvmNetworkConfig;
declare const bscTestnet: TypedEvmNetworkConfig;
declare const optimismSepolia: TypedEvmNetworkConfig;
declare const avalancheFuji: TypedEvmNetworkConfig;
declare const zksyncSepoliaTestnet: TypedEvmNetworkConfig;
declare const scrollSepolia: TypedEvmNetworkConfig;
declare const lineaSepolia: TypedEvmNetworkConfig;

declare const evmMainnetNetworks: TypedEvmNetworkConfig[];
declare const evmTestnetNetworks: TypedEvmNetworkConfig[];
declare const evmNetworks: TypedEvmNetworkConfig[];

/**
 * Configuration for the EVM adapter
 *
 * This file defines the dependencies required by the EVM adapter
 * when generating exported projects. It follows the AdapterConfig
 * interface to provide a structured approach to dependency management.
 */

declare const evmAdapterConfig: AdapterConfig;

export { EvmAdapter, arbitrumMainnet, arbitrumSepolia, avalancheFuji, avalancheMainnet, baseMainnet, baseSepolia, bscMainnet, bscTestnet, ethereumMainnet, ethereumSepolia, evmAdapterConfig, evmMainnetNetworks, evmNetworks, evmTestnetNetworks, lineaMainnet, lineaSepolia, optimismMainnet, optimismSepolia, polygonAmoy, polygonMainnet, polygonZkEvmCardona, polygonZkEvmMainnet, scrollMainnet, scrollSepolia, zkSyncEraMainnet, zksyncSepoliaTestnet };
