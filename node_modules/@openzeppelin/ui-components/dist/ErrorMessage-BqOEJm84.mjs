import React from "react";
import { jsx } from "react/jsx-runtime";

//#region src/components/fields/utils/integerValidation.ts
/**
* Shared integer validation patterns for BigInt fields and validation utilities.
*
* These patterns ensure consistent validation across the application.
*/
/**
* Integer validation pattern - requires at least one digit
* Used for validation to ensure complete integers are entered
* Matches: -123, 0, 456
* Does not match: -, abc, 12.3
*/
const INTEGER_PATTERN = /^-?\d+$/;
/**
* Integer input pattern - allows partial input during typing
* Used during input to allow users to type minus sign first
* Matches: -, -1, 123, (empty string)
* Does not match: abc, 12.3
*/
const INTEGER_INPUT_PATTERN = /^-?\d*$/;
/**
* HTML pattern attribute for integer inputs
* Must use [0-9] instead of \d for HTML5 pattern attribute
*/
const INTEGER_HTML_PATTERN = "-?[0-9]*";

//#endregion
//#region src/components/fields/utils/validation.ts
/**
* Determines if a field has an error
*/
function hasFieldError(error) {
	return !!error;
}
/**
* Gets appropriate error message from field error
*/
function getErrorMessage(error) {
	if (!error) return void 0;
	return error.message || "This field is invalid";
}
/**
* Formats validation error messages for display
*/
function formatValidationError(error, fieldName) {
	if (!error) return void 0;
	const defaultMessage = fieldName ? `${fieldName} is invalid` : "This field is invalid";
	return error.message || defaultMessage;
}
/**
* Generates common CSS classes for field validation states
*/
function getValidationStateClasses(error, touched) {
	if (error) return "border-destructive focus:border-destructive focus:ring-destructive/30";
	if (touched) return "border-success focus:border-success focus:ring-success/30";
	return "";
}
/**
* Helper for handling form validation errors with React Hook Form
*/
function handleValidationError(error, id) {
	const hasError = hasFieldError(error);
	const errorMessage = getErrorMessage(error);
	return {
		errorId: `${id}-error`,
		errorMessage,
		hasError,
		validationClasses: getValidationStateClasses(error)
	};
}
/**
* Creates a validation result object for field components
*/
function createValidationResult(id, error, touched) {
	const hasError = hasFieldError(error);
	const errorMessage = getErrorMessage(error);
	const errorId = `${id}-error`;
	return {
		hasError,
		errorMessage,
		errorId,
		validationClasses: getValidationStateClasses(error, touched),
		"aria-invalid": hasError,
		"aria-errormessage": hasError ? errorId : void 0
	};
}
/**
* Generic field validation function that can be used to validate any field type
* based on common validation criteria
*/
function validateField(value, validation) {
	if (!validation) return true;
	if (validation.required && (value === void 0 || value === null || value === "")) return typeof validation.required === "boolean" ? "This field is required" : "This field is required";
	if (value === void 0 || value === null || value === "") return true;
	if (typeof value === "string") {
		if (validation.minLength && value.length < validation.minLength) return `Minimum length is ${validation.minLength} characters`;
		if (validation.maxLength && value.length > validation.maxLength) return `Maximum length is ${validation.maxLength} characters`;
		if (validation.pattern) {
			if (!(typeof validation.pattern === "string" ? new RegExp(validation.pattern) : validation.pattern).test(value)) {
				if (!INTEGER_PATTERN.test(value) && /\d/.test(value)) return "Value must be a valid integer (no decimals)";
				return "Value does not match the required pattern";
			}
		}
	}
	if (typeof value === "number" || typeof value === "string" && !isNaN(Number(value))) {
		const numValue = typeof value === "number" ? value : Number(value);
		if (validation.min !== void 0 && numValue < validation.min) return `Minimum value is ${validation.min}`;
		if (validation.max !== void 0 && numValue > validation.max) return `Maximum value is ${validation.max}`;
	}
	if (validation.conditions && validation.conditions.length > 0) {}
	return true;
}
/**
* Map validation utilities
*/
/**
* Checks if a map entry at the given index has a duplicate key
* @param entries - Array of map entries
* @param currentIndex - Index of the entry to check
* @returns true if the key at currentIndex is duplicated elsewhere in the array
*/
function isDuplicateMapKey(entries, currentIndex) {
	if (!Array.isArray(entries) || entries.length <= 1) return false;
	const currentKeyValue = entries[currentIndex]?.key;
	if (!currentKeyValue || currentKeyValue === "") return false;
	return entries.some((entry, i) => {
		if (i === currentIndex) return false;
		const key = entry?.key;
		if (key === "") return false;
		if (typeof key === "string" && typeof currentKeyValue === "string") return key === currentKeyValue;
		if (typeof key === "number" && typeof currentKeyValue === "number") return Number.isNaN(key) ? Number.isNaN(currentKeyValue) : key === currentKeyValue;
		if (typeof key === "boolean" && typeof currentKeyValue === "boolean") return key === currentKeyValue;
		if (typeof key === "object" && key !== null && typeof currentKeyValue === "object" && currentKeyValue !== null) return key === currentKeyValue;
		return false;
	});
}
/**
* Validates an array of map entries for duplicate keys
* @param entries - Array of map entries to validate
* @returns Validation error message if duplicates found, otherwise undefined
*/
function validateMapEntries(entries) {
	if (!Array.isArray(entries) || entries.length <= 1) return;
	const keyStrings = entries.map((entry) => entry?.key).filter((key) => key !== void 0 && key !== null && key !== "").map((key) => String(key));
	const uniqueKeyStrings = new Set(keyStrings);
	if (keyStrings.length !== uniqueKeyStrings.size) return "Duplicate keys are not allowed";
}

//#endregion
//#region src/components/fields/utils/ErrorMessage.tsx
/**
* Displays validation error messages for form fields
*/
function ErrorMessage({ error, id, message, className = "" }) {
	const errorMessage = message || getErrorMessage(error);
	if (!errorMessage) return null;
	return /* @__PURE__ */ jsx("div", {
		id,
		className: `text-destructive mt-1 text-sm ${className}`,
		role: "alert",
		children: errorMessage
	});
}

//#endregion
export { getValidationStateClasses as a, isDuplicateMapKey as c, INTEGER_HTML_PATTERN as d, INTEGER_INPUT_PATTERN as f, getErrorMessage as i, validateField as l, createValidationResult as n, handleValidationError as o, INTEGER_PATTERN as p, formatValidationError as r, hasFieldError as s, ErrorMessage as t, validateMapEntries as u };
//# sourceMappingURL=ErrorMessage-BqOEJm84.mjs.map