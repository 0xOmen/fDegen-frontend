import * as AccordionPrimitive from "@radix-ui/react-accordion";
import { VariantProps } from "class-variance-authority";
import * as React$2 from "react";
import React$1, { ForwardedRef, JSX, ReactElement, ReactNode } from "react";
import { DateRange, DayPicker } from "react-day-picker";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import * as PopoverPrimitive from "@radix-ui/react-popover";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Control, FieldError, FieldPath, FieldValues, FormProvider, UseFormReturn } from "react-hook-form";
import * as _radix_ui_react_label0 from "@radix-ui/react-label";
import * as ProgressPrimitive from "@radix-ui/react-progress";
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group";
import * as SelectPrimitive from "@radix-ui/react-select";
import * as TabsPrimitive from "@radix-ui/react-tabs";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import { ContractAdapter, ContractSchema, EnumValue, FieldValidation, FormFieldType, FunctionParameter, MapEntry, NetworkConfig, NetworkType, RelayerDetails, RelayerDetailsRich } from "@openzeppelin/ui-types";
import { ToasterProps } from "sonner";
import * as class_variance_authority_types1 from "class-variance-authority/types";

//#region src/components/ui/accordion.d.ts
declare const accordionItemVariants: (props?: ({
  variant?: "default" | "card" | null | undefined;
} & class_variance_authority_types1.ClassProp) | undefined) => string;
declare const accordionTriggerVariants: (props?: ({
  variant?: "default" | "card" | null | undefined;
} & class_variance_authority_types1.ClassProp) | undefined) => string;
declare const accordionContentVariants: (props?: ({
  variant?: "default" | "card" | null | undefined;
} & class_variance_authority_types1.ClassProp) | undefined) => string;
type AccordionVariant = 'default' | 'card';
type AccordionProps = (AccordionPrimitive.AccordionSingleProps | AccordionPrimitive.AccordionMultipleProps) & {
  variant?: AccordionVariant;
};
declare const Accordion: React$2.ForwardRefExoticComponent<AccordionProps & React$2.RefAttributes<HTMLDivElement>>;
interface AccordionItemProps extends React$2.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>, VariantProps<typeof accordionItemVariants> {}
declare const AccordionItem: React$2.ForwardRefExoticComponent<AccordionItemProps & React$2.RefAttributes<HTMLDivElement>>;
interface AccordionTriggerProps extends React$2.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>, VariantProps<typeof accordionTriggerVariants> {}
declare const AccordionTrigger: React$2.ForwardRefExoticComponent<AccordionTriggerProps & React$2.RefAttributes<HTMLButtonElement>>;
interface AccordionContentProps extends React$2.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>, VariantProps<typeof accordionContentVariants> {}
declare const AccordionContent: React$2.ForwardRefExoticComponent<AccordionContentProps & React$2.RefAttributes<HTMLDivElement>>;
//#endregion
//#region src/components/ui/address-display.d.ts
interface AddressDisplayProps extends React$2.HTMLAttributes<HTMLDivElement> {
  /**
   * The blockchain address to display
   */
  address: string;
  /**
   * Whether to truncate the address in the middle
   * @default true
   */
  truncate?: boolean;
  /**
   * Number of characters to show at the beginning when truncating
   * @default 6
   */
  startChars?: number;
  /**
   * Number of characters to show at the end when truncating
   * @default 4
   */
  endChars?: number;
  /**
   * Whether to show a copy button
   * @default false
   */
  showCopyButton?: boolean;
  /**
   * Whether to show the copy button only on hover
   * @default false
   */
  showCopyButtonOnHover?: boolean;
  /**
   * Optional explorer URL to make the address clickable
   */
  explorerUrl?: string;
  /**
   * Additional CSS classes
   */
  className?: string;
}
/** Displays a blockchain address with optional truncation, copy button, and explorer link. */
declare function AddressDisplay({
  address,
  truncate,
  startChars,
  endChars,
  showCopyButton,
  showCopyButtonOnHover,
  explorerUrl,
  className,
  ...props
}: AddressDisplayProps): React$2.ReactElement;
//#endregion
//#region src/components/ui/alert.d.ts
declare const Alert: React$2.ForwardRefExoticComponent<React$2.HTMLAttributes<HTMLDivElement> & VariantProps<(props?: ({
  variant?: "default" | "destructive" | "success" | null | undefined;
} & class_variance_authority_types1.ClassProp) | undefined) => string> & React$2.RefAttributes<HTMLDivElement>>;
declare const AlertTitle: React$2.ForwardRefExoticComponent<React$2.HTMLAttributes<HTMLHeadingElement> & React$2.RefAttributes<HTMLParagraphElement>>;
declare const AlertDescription: React$2.ForwardRefExoticComponent<React$2.HTMLAttributes<HTMLParagraphElement> & React$2.RefAttributes<HTMLParagraphElement>>;
//#endregion
//#region src/components/ui/banner.d.ts
interface BannerProps {
  /**
   * The variant/style of the banner
   * @default 'info'
   */
  variant?: 'info' | 'success' | 'warning' | 'error';
  /**
   * Title text displayed at the top of the banner
   */
  title?: React$2.ReactNode;
  /**
   * Body text/content of the banner
   */
  children: React$2.ReactNode;
  /**
   * Whether the banner can be dismissed
   * @default true
   */
  dismissible?: boolean;
  /**
   * Callback when the banner is dismissed
   */
  onDismiss?: () => void;
  /**
   * Icon to display on the left (replaces default based on variant)
   */
  icon?: React$2.ReactNode;
  /**
   * Additional CSS classes
   */
  className?: string;
}
/**
 * Dismissible banner component for notifications and alerts
 * Can be used with various variants (info, success, warning, error)
 */
declare const Banner: React$2.ForwardRefExoticComponent<BannerProps & React$2.RefAttributes<HTMLDivElement>>;
//#endregion
//#region src/utils/button-variants.d.ts
declare const buttonVariants: (props?: ({
  variant?: "default" | "destructive" | "outline" | "secondary" | "ghost" | "link" | null | undefined;
  size?: "default" | "sm" | "lg" | "icon" | null | undefined;
} & class_variance_authority_types1.ClassProp) | undefined) => string;
//#endregion
//#region src/components/ui/button.d.ts
interface ButtonProps extends React$2.ButtonHTMLAttributes<HTMLButtonElement>, VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}
declare const Button: React$2.ForwardRefExoticComponent<ButtonProps & React$2.RefAttributes<HTMLButtonElement>>;
//#endregion
//#region src/components/ui/calendar.d.ts
type CalendarProps = React$2.ComponentProps<typeof DayPicker>;
/**
 * Calendar component built on react-day-picker with shadcn/ui styling.
 * Supports single date, multiple dates, and date range selection modes.
 */
declare function Calendar({
  className,
  classNames,
  showOutsideDays,
  ...props
}: CalendarProps): React$2.ReactElement;
declare namespace Calendar {
  var displayName: string;
}
//#endregion
//#region src/components/ui/card.d.ts
/** Card container component with rounded borders. */
declare function Card({
  className,
  ...props
}: React.ComponentProps<'div'>): JSX.Element;
/** Card header section for title and description. Provides top padding for the card. */
declare function CardHeader({
  className,
  ...props
}: React.ComponentProps<'div'>): JSX.Element;
/** Card title with semibold styling. */
declare function CardTitle({
  className,
  ...props
}: React.ComponentProps<'div'>): JSX.Element;
/** Card description with muted text styling. */
declare function CardDescription({
  className,
  ...props
}: React.ComponentProps<'div'>): JSX.Element;
/** Card content area with horizontal padding, top spacing, and bottom padding. */
declare function CardContent({
  className,
  ...props
}: React.ComponentProps<'div'>): JSX.Element;
/** Card footer with flex alignment for actions, top spacing, and bottom padding. */
declare function CardFooter({
  className,
  ...props
}: React.ComponentProps<'div'>): JSX.Element;
//#endregion
//#region src/components/ui/checkbox.d.ts
/** Checkbox component wrapping Radix UI Checkbox primitive. */
declare function Checkbox({
  className,
  ...props
}: React$2.ComponentProps<typeof CheckboxPrimitive.Root>): React$2.ReactElement;
//#endregion
//#region src/components/ui/date-range-picker.d.ts
/**
 * Props for the DateRangePicker component.
 */
interface DateRangePickerProps {
  /** The selected date range */
  value?: DateRange;
  /** Callback when the date range changes */
  onChange?: (range: DateRange | undefined) => void;
  /** Placeholder text when no date is selected */
  placeholder?: string;
  /** Additional CSS classes */
  className?: string;
  /** Whether the picker is disabled */
  disabled?: boolean;
  /** Number of months to display (default: 2) */
  numberOfMonths?: number;
  /** Alignment of the popover */
  align?: 'start' | 'center' | 'end';
}
/**
 * DateRangePicker component for selecting a date range.
 * Uses react-day-picker with Radix Popover for a shadcn-styled date range selection.
 *
 * @example
 * ```tsx
 * const [dateRange, setDateRange] = useState<DateRange | undefined>();
 *
 * <DateRangePicker
 *   value={dateRange}
 *   onChange={setDateRange}
 *   placeholder="Select date range"
 * />
 * ```
 */
declare function DateRangePicker({
  value,
  onChange,
  placeholder,
  className,
  disabled,
  numberOfMonths,
  align
}: DateRangePickerProps): React.ReactElement;
declare namespace DateRangePicker {
  var displayName: string;
}
//#endregion
//#region src/components/ui/dialog.d.ts
declare const Dialog: React$2.FC<DialogPrimitive.DialogProps>;
declare const DialogTrigger: React$2.ForwardRefExoticComponent<DialogPrimitive.DialogTriggerProps & React$2.RefAttributes<HTMLButtonElement>>;
declare const DialogPortal: React$2.FC<DialogPrimitive.DialogPortalProps>;
declare const DialogClose: React$2.ForwardRefExoticComponent<DialogPrimitive.DialogCloseProps & React$2.RefAttributes<HTMLButtonElement>>;
declare const DialogOverlay: React$2.ForwardRefExoticComponent<Omit<DialogPrimitive.DialogOverlayProps & React$2.RefAttributes<HTMLDivElement>, "ref"> & React$2.RefAttributes<HTMLDivElement>>;
declare const DialogContent: React$2.ForwardRefExoticComponent<Omit<DialogPrimitive.DialogContentProps & React$2.RefAttributes<HTMLDivElement>, "ref"> & React$2.RefAttributes<HTMLDivElement>>;
declare const DialogHeader: {
  ({
    className,
    ...props
  }: React$2.HTMLAttributes<HTMLDivElement>): React$2.JSX.Element;
  displayName: string;
};
declare const DialogFooter: {
  ({
    className,
    ...props
  }: React$2.HTMLAttributes<HTMLDivElement>): React$2.JSX.Element;
  displayName: string;
};
declare const DialogTitle: React$2.ForwardRefExoticComponent<Omit<DialogPrimitive.DialogTitleProps & React$2.RefAttributes<HTMLHeadingElement>, "ref"> & React$2.RefAttributes<HTMLHeadingElement>>;
declare const DialogDescription: React$2.ForwardRefExoticComponent<Omit<DialogPrimitive.DialogDescriptionProps & React$2.RefAttributes<HTMLParagraphElement>, "ref"> & React$2.RefAttributes<HTMLParagraphElement>>;
//#endregion
//#region src/components/ui/dropdown-menu.d.ts
declare const DropdownMenu: React$2.FC<DropdownMenuPrimitive.DropdownMenuProps>;
declare const DropdownMenuTrigger: React$2.ForwardRefExoticComponent<DropdownMenuPrimitive.DropdownMenuTriggerProps & React$2.RefAttributes<HTMLButtonElement>>;
declare const DropdownMenuGroup: React$2.ForwardRefExoticComponent<DropdownMenuPrimitive.DropdownMenuGroupProps & React$2.RefAttributes<HTMLDivElement>>;
declare const DropdownMenuPortal: React$2.FC<DropdownMenuPrimitive.DropdownMenuPortalProps>;
declare const DropdownMenuSub: React$2.FC<DropdownMenuPrimitive.DropdownMenuSubProps>;
declare const DropdownMenuRadioGroup: React$2.ForwardRefExoticComponent<DropdownMenuPrimitive.DropdownMenuRadioGroupProps & React$2.RefAttributes<HTMLDivElement>>;
declare const DropdownMenuSubTrigger: React$2.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuSubTriggerProps & React$2.RefAttributes<HTMLDivElement>, "ref"> & {
  inset?: boolean;
} & React$2.RefAttributes<HTMLDivElement>>;
declare const DropdownMenuSubContent: React$2.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuSubContentProps & React$2.RefAttributes<HTMLDivElement>, "ref"> & React$2.RefAttributes<HTMLDivElement>>;
declare const DropdownMenuContent: React$2.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuContentProps & React$2.RefAttributes<HTMLDivElement>, "ref"> & React$2.RefAttributes<HTMLDivElement>>;
declare const DropdownMenuItem: React$2.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuItemProps & React$2.RefAttributes<HTMLDivElement>, "ref"> & {
  inset?: boolean;
} & React$2.RefAttributes<HTMLDivElement>>;
declare const DropdownMenuCheckboxItem: React$2.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuCheckboxItemProps & React$2.RefAttributes<HTMLDivElement>, "ref"> & React$2.RefAttributes<HTMLDivElement>>;
declare const DropdownMenuRadioItem: React$2.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuRadioItemProps & React$2.RefAttributes<HTMLDivElement>, "ref"> & React$2.RefAttributes<HTMLDivElement>>;
declare const DropdownMenuLabel: React$2.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuLabelProps & React$2.RefAttributes<HTMLDivElement>, "ref"> & {
  inset?: boolean;
} & React$2.RefAttributes<HTMLDivElement>>;
declare const DropdownMenuSeparator: React$2.ForwardRefExoticComponent<Omit<DropdownMenuPrimitive.DropdownMenuSeparatorProps & React$2.RefAttributes<HTMLDivElement>, "ref"> & React$2.RefAttributes<HTMLDivElement>>;
declare const DropdownMenuShortcut: {
  ({
    className,
    ...props
  }: React$2.HTMLAttributes<HTMLSpanElement>): React$2.ReactNode;
  displayName: string;
};
//#endregion
//#region src/components/ui/empty-state.d.ts
interface EmptyStateProps {
  /**
   * The icon to display - can be a React component or SVG path
   */
  icon?: React$1.ReactNode;
  /**
   * Main heading text
   */
  title: string;
  /**
   * Descriptive text explaining the empty state
   */
  description: string;
  /**
   * Additional CSS classes for the container
   */
  className?: string;
  /**
   * Size variant for the empty state
   * @default 'default'
   */
  size?: 'small' | 'default' | 'large';
}
/**
 * Reusable empty state component for showing helpful messages when content is not available
 */
declare function EmptyState({
  icon,
  title,
  description,
  className,
  size
}: EmptyStateProps): React$1.ReactElement;
//#endregion
//#region src/components/ui/external-link.d.ts
declare const ExternalLink: React$1.ForwardRefExoticComponent<React$1.AnchorHTMLAttributes<HTMLAnchorElement> & React$1.RefAttributes<HTMLAnchorElement>>;
//#endregion
//#region src/components/ui/footer.d.ts
/**
 * Props for the Footer component
 */
interface FooterProps {
  /**
   * Company or organization name for the copyright notice
   * @default 'OpenZeppelin'
   */
  companyName?: string;
  /**
   * Copyright year to display
   * @default Current year
   */
  copyrightYear?: number;
  /**
   * URL for the privacy policy link
   * @default 'https://www.openzeppelin.com/privacy'
   */
  privacyPolicyUrl?: string;
  /**
   * Text for the privacy policy link
   * @default 'Privacy Policy'
   */
  privacyPolicyText?: string;
  /**
   * URL for the terms of service link
   * @default 'https://www.openzeppelin.com/tos'
   */
  termsOfServiceUrl?: string;
  /**
   * Text for the terms of service link
   * @default 'Terms of Service'
   */
  termsOfServiceText?: string;
  /**
   * Whether to show the privacy policy link
   * @default true
   */
  showPrivacyPolicy?: boolean;
  /**
   * Whether to show the terms of service link
   * @default true
   */
  showTermsOfService?: boolean;
  /**
   * Additional CSS classes for the footer container
   */
  className?: string;
}
/**
 * Application footer component with customizable legal links and branding.
 *
 * This component provides a consistent footer layout with customizable:
 * - Company name and copyright year
 * - Privacy policy and terms of service links and text
 * - Optional visibility controls for legal links
 * - Custom styling support
 */
declare const Footer: ({
  companyName,
  copyrightYear,
  privacyPolicyUrl,
  privacyPolicyText,
  termsOfServiceUrl,
  termsOfServiceText,
  showPrivacyPolicy,
  showTermsOfService,
  className
}?: FooterProps) => JSX.Element;
//#endregion
//#region src/components/ui/form.d.ts
/**
 * Context provider for the form
 */
declare const Form: <TFieldValues extends FieldValues = FieldValues, TContext = unknown>({
  ...props
}: React$2.ComponentProps<typeof FormProvider<TFieldValues, TContext>>) => React$2.ReactElement;
/**
 * Form field component
 */
declare const FormField: <TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>({
  ...props
}: ControllerProps<TFieldValues, TName>) => React$2.ReactElement;
/**
 * Form item component
 */
declare const FormItem: React$2.ForwardRefExoticComponent<React$2.HTMLAttributes<HTMLDivElement> & React$2.RefAttributes<HTMLDivElement>>;
/**
 * Form label component
 */
declare const FormLabel: React$2.ForwardRefExoticComponent<Omit<Omit<_radix_ui_react_label0.LabelProps & React$2.RefAttributes<HTMLLabelElement>, "ref"> & React$2.RefAttributes<HTMLLabelElement>, "ref"> & React$2.RefAttributes<HTMLLabelElement>>;
/**
 * Form control component
 */
declare const FormControl: React$2.ForwardRefExoticComponent<React$2.HTMLAttributes<HTMLDivElement> & React$2.RefAttributes<HTMLDivElement>>;
/**
 * Form description component
 */
declare const FormDescription: React$2.ForwardRefExoticComponent<React$2.HTMLAttributes<HTMLParagraphElement> & React$2.RefAttributes<HTMLParagraphElement>>;
/**
 * Form error message component
 */
declare const FormMessage: React$2.ForwardRefExoticComponent<React$2.HTMLAttributes<HTMLParagraphElement> & React$2.RefAttributes<HTMLParagraphElement>>;
/**
 * Types for form controller props
 */
type ControllerProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>> = {
  name: TName;
  control?: UseFormReturn<TFieldValues>['control'];
  render: (props: {
    field: {
      value: unknown;
      onChange: (...event: unknown[]) => void;
      onBlur: () => void;
      name: TName;
      ref: React$2.RefCallback<HTMLInputElement>;
    };
    fieldState: {
      invalid: boolean;
      isTouched: boolean;
      isDirty: boolean;
      error?: unknown;
    };
    formState: UseFormReturn<TFieldValues>['formState'];
  }) => React$2.ReactElement;
};
//#endregion
//#region src/components/ui/header.d.ts
interface HeaderProps {
  title?: string;
  /** Open the mobile sidebar */
  onOpenSidebar?: () => void;
  /** Content to display on the right side of the header */
  rightContent?: React$1.ReactNode;
}
declare const Header: ({
  title,
  onOpenSidebar,
  rightContent
}: HeaderProps) => React$1.ReactElement;
//#endregion
//#region src/components/ui/input.d.ts
/**
 * Input component that follows shadcn/ui styling and accessibility patterns
 */
type InputProps = React$2.InputHTMLAttributes<HTMLInputElement>;
declare const Input: React$2.ForwardRefExoticComponent<InputProps & React$2.RefAttributes<HTMLInputElement>>;
//#endregion
//#region src/components/ui/label.d.ts
/**
 * Label component for form fields, following shadcn/ui styling
 */
declare const Label: React$2.ForwardRefExoticComponent<Omit<_radix_ui_react_label0.LabelProps & React$2.RefAttributes<HTMLLabelElement>, "ref"> & React$2.RefAttributes<HTMLLabelElement>>;
//#endregion
//#region src/components/ui/loading-button.d.ts
interface LoadingButtonProps extends React$2.ButtonHTMLAttributes<HTMLButtonElement>, VariantProps<typeof buttonVariants> {
  asChild?: boolean;
  loading?: boolean;
}
declare const LoadingButton: React$2.ForwardRefExoticComponent<LoadingButtonProps & React$2.RefAttributes<HTMLButtonElement>>;
//#endregion
//#region src/components/ui/network-icon.d.ts
interface NetworkIconProps {
  network: Pick<NetworkConfig, 'ecosystem' | 'iconComponent'>;
  className?: string;
  size?: number;
  variant?: 'mono' | 'branded';
}
/** Displays the appropriate icon for a blockchain network. */
declare function NetworkIcon({
  network,
  className,
  size,
  variant
}: NetworkIconProps): React$1.ReactElement;
//#endregion
//#region src/components/ui/network-selector.d.ts
interface NetworkSelectorProps<T> {
  networks: T[];
  selectedNetwork: T | null;
  onSelectNetwork: (network: T) => void;
  getNetworkLabel: (network: T) => string;
  getNetworkIcon?: (network: T) => React$2.ReactNode;
  getNetworkType?: (network: T) => NetworkType | undefined;
  getNetworkId: (network: T) => string;
  groupByEcosystem?: boolean;
  getEcosystem?: (network: T) => string;
  filterNetwork?: (network: T, query: string) => boolean;
  className?: string;
  placeholder?: string;
}
/** Searchable dropdown selector for blockchain networks with optional grouping. */
declare function NetworkSelector<T>({
  networks,
  selectedNetwork,
  onSelectNetwork,
  getNetworkLabel,
  getNetworkIcon,
  getNetworkType,
  getNetworkId,
  groupByEcosystem,
  getEcosystem,
  filterNetwork,
  className,
  placeholder
}: NetworkSelectorProps<T>): React$2.ReactElement;
//#endregion
//#region src/components/ui/network-status-badge.d.ts
interface NetworkStatusBadgeProps {
  network: NetworkConfig | null;
  className?: string;
}
/**
 * NetworkStatusBadge - Displays network information in a compact badge format
 * Shows the network icon, ecosystem, and name with dashed borders for testnet/devnet
 */
declare function NetworkStatusBadge({
  network,
  className
}: NetworkStatusBadgeProps): React$1.ReactElement | null;
//#endregion
//#region src/components/ui/popover.d.ts
declare const Popover: React$2.FC<PopoverPrimitive.PopoverProps>;
declare const PopoverTrigger: React$2.ForwardRefExoticComponent<PopoverPrimitive.PopoverTriggerProps & React$2.RefAttributes<HTMLButtonElement>>;
declare const PopoverAnchor: React$2.ForwardRefExoticComponent<PopoverPrimitive.PopoverAnchorProps & React$2.RefAttributes<HTMLDivElement>>;
declare const PopoverContent: React$2.ForwardRefExoticComponent<Omit<PopoverPrimitive.PopoverContentProps & React$2.RefAttributes<HTMLDivElement>, "ref"> & React$2.RefAttributes<HTMLDivElement>>;
//#endregion
//#region src/components/ui/progress.d.ts
declare const Progress: React$2.ForwardRefExoticComponent<Omit<ProgressPrimitive.ProgressProps & React$2.RefAttributes<HTMLDivElement>, "ref"> & React$2.RefAttributes<HTMLDivElement>>;
//#endregion
//#region src/components/ui/radio-group.d.ts
declare const RadioGroup: React$2.ForwardRefExoticComponent<Omit<RadioGroupPrimitive.RadioGroupProps & React$2.RefAttributes<HTMLDivElement>, "ref"> & React$2.RefAttributes<HTMLDivElement>>;
declare const RadioGroupItem: React$2.ForwardRefExoticComponent<Omit<RadioGroupPrimitive.RadioGroupItemProps & React$2.RefAttributes<HTMLButtonElement>, "ref"> & React$2.RefAttributes<HTMLButtonElement>>;
//#endregion
//#region src/components/ui/select.d.ts
declare const Select: React$2.FC<SelectPrimitive.SelectProps>;
declare const SelectGroup: React$2.ForwardRefExoticComponent<SelectPrimitive.SelectGroupProps & React$2.RefAttributes<HTMLDivElement>>;
declare const SelectValue: React$2.ForwardRefExoticComponent<SelectPrimitive.SelectValueProps & React$2.RefAttributes<HTMLSpanElement>>;
declare const SelectTrigger: React$2.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectTriggerProps & React$2.RefAttributes<HTMLButtonElement>, "ref"> & React$2.RefAttributes<HTMLButtonElement>>;
declare const SelectScrollUpButton: React$2.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectScrollUpButtonProps & React$2.RefAttributes<HTMLDivElement>, "ref"> & React$2.RefAttributes<HTMLDivElement>>;
declare const SelectScrollDownButton: React$2.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectScrollDownButtonProps & React$2.RefAttributes<HTMLDivElement>, "ref"> & React$2.RefAttributes<HTMLDivElement>>;
declare const SelectContent: React$2.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectContentProps & React$2.RefAttributes<HTMLDivElement>, "ref"> & React$2.RefAttributes<HTMLDivElement>>;
declare const SelectLabel: React$2.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectLabelProps & React$2.RefAttributes<HTMLDivElement>, "ref"> & React$2.RefAttributes<HTMLDivElement>>;
declare const SelectItem: React$2.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectItemProps & React$2.RefAttributes<HTMLDivElement>, "ref"> & React$2.RefAttributes<HTMLDivElement>>;
declare const SelectSeparator: React$2.ForwardRefExoticComponent<Omit<SelectPrimitive.SelectSeparatorProps & React$2.RefAttributes<HTMLDivElement>, "ref"> & React$2.RefAttributes<HTMLDivElement>>;
//#endregion
//#region src/components/ui/sidebar/SidebarButton.d.ts
interface SidebarButtonProps {
  icon?: ReactNode;
  children: ReactNode;
  onClick?: () => void;
  size?: 'default' | 'small';
  badge?: string;
  disabled?: boolean;
  isSelected?: boolean;
  /** When provided, renders as an anchor element instead of a button */
  href?: string;
  target?: React$1.HTMLAttributeAnchorTarget;
  rel?: string;
  className?: string;
}
/**
 * A styled button component for sidebar actions with consistent styling.
 * Can render as a button or anchor element depending on whether href is provided.
 */
declare function SidebarButton({
  icon,
  children,
  onClick,
  size,
  badge,
  disabled,
  isSelected,
  href,
  target,
  rel,
  className
}: SidebarButtonProps): React$1.ReactElement;
//#endregion
//#region src/components/ui/sidebar/SidebarGroup.d.ts
interface SidebarGroupProps {
  /** Title displayed in the collapsible trigger */
  title: string;
  /** Optional icon displayed before the title */
  icon?: ReactNode;
  /** Content to render when expanded */
  children: ReactNode;
  /** Whether the group is open by default */
  defaultOpen?: boolean;
  /** Controlled open state */
  open?: boolean;
  /** Callback when open state changes */
  onOpenChange?: (open: boolean) => void;
  /** Additional CSS classes for the container */
  className?: string;
  /** Additional CSS classes for the trigger */
  triggerClassName?: string;
  /** Additional CSS classes for the content wrapper */
  contentClassName?: string;
}
/**
 * A collapsible group component for organizing sidebar navigation items.
 * Supports both controlled and uncontrolled modes.
 */
declare function SidebarGroup({
  title,
  icon,
  children,
  defaultOpen,
  open: controlledOpen,
  onOpenChange,
  className,
  triggerClassName,
  contentClassName
}: SidebarGroupProps): React$1.ReactElement;
//#endregion
//#region src/components/ui/sidebar/SidebarLayout.d.ts
interface SidebarLayoutProps {
  /** Content for the sidebar header (e.g., logo) */
  header?: ReactNode;
  /** Content to be displayed below the header but above the scrollable area */
  subHeader?: ReactNode;
  /** Main scrollable content area */
  children: ReactNode;
  /** Content for the fixed footer (e.g., nav icons) */
  footer?: ReactNode;
  /** Additional CSS classes for the sidebar container */
  className?: string;
  /** Width of the sidebar (default: 289px) */
  width?: number | string;
  /** Background color/class for the sidebar */
  background?: string;
  /** Controls visibility in mobile slide-over */
  mobileOpen?: boolean;
  /** Close handler for mobile slide-over */
  onMobileOpenChange?: (open: boolean) => void;
  /** Aria label for mobile dialog */
  mobileAriaLabel?: string;
}
/**
 * A flexible sidebar layout component with desktop sidebar and mobile slide-over.
 * Provides slots for header, scrollable content, and footer.
 */
declare function SidebarLayout({
  header,
  subHeader,
  children,
  footer,
  className,
  width,
  background,
  mobileOpen,
  onMobileOpenChange,
  mobileAriaLabel
}: SidebarLayoutProps): React$1.ReactElement;
//#endregion
//#region src/components/ui/sidebar/SidebarSection.d.ts
interface SidebarSectionProps {
  /** Optional section title displayed above the content */
  title?: string;
  /** Content to render within the section */
  children: ReactNode;
  /** Additional CSS classes */
  className?: string;
  /** CSS classes for the title element */
  titleClassName?: string;
  /** Whether this section should grow to fill available space */
  grow?: boolean;
}
/**
 * A generic sidebar section wrapper with optional title.
 * Used to group related sidebar items together.
 */
declare function SidebarSection({
  title,
  children,
  className,
  titleClassName,
  grow
}: SidebarSectionProps): React$1.ReactElement;
//#endregion
//#region src/components/ui/tabs.d.ts
/** Tabs container component wrapping Radix UI Tabs Root. */
declare function Tabs({
  className,
  ...props
}: React$2.ComponentProps<typeof TabsPrimitive.Root>): React$2.ReactElement;
/** Tabs list component containing tab triggers. */
declare function TabsList({
  className,
  ...props
}: React$2.ComponentProps<typeof TabsPrimitive.List>): React$2.ReactElement;
/** Individual tab trigger button. */
declare function TabsTrigger({
  className,
  ...props
}: React$2.ComponentProps<typeof TabsPrimitive.Trigger>): React$2.ReactElement;
/** Tab content panel displayed when its trigger is active. */
declare function TabsContent({
  className,
  ...props
}: React$2.ComponentProps<typeof TabsPrimitive.Content>): React$2.ReactElement;
//#endregion
//#region src/components/ui/textarea.d.ts
type TextareaProps = React$2.TextareaHTMLAttributes<HTMLTextAreaElement>;
declare const Textarea: React$2.ForwardRefExoticComponent<TextareaProps & React$2.RefAttributes<HTMLTextAreaElement>>;
//#endregion
//#region src/components/ui/tooltip.d.ts
declare const TooltipProvider: React$2.FC<TooltipPrimitive.TooltipProviderProps>;
declare const Tooltip: React$2.FC<TooltipPrimitive.TooltipProps>;
declare const TooltipTrigger: React$2.ForwardRefExoticComponent<TooltipPrimitive.TooltipTriggerProps & React$2.RefAttributes<HTMLButtonElement>>;
declare const TooltipContent: React$2.ForwardRefExoticComponent<Omit<TooltipPrimitive.TooltipContentProps & React$2.RefAttributes<HTMLDivElement>, "ref"> & React$2.RefAttributes<HTMLDivElement>>;
//#endregion
//#region src/components/ui/view-contract-state-button.d.ts
interface ViewContractStateButtonProps {
  contractAddress: string | null;
  onToggle: () => void;
}
/**
 * ViewContractStateButton - A button to toggle the contract state widget
 * Shows the contract address in a truncated format
 */
declare function ViewContractStateButton({
  contractAddress,
  onToggle
}: ViewContractStateButtonProps): React$1.ReactElement | null;
//#endregion
//#region src/components/fields/BaseField.d.ts
/**
 * Base props shared by all field components
 *
 * @template TFieldValues The field values type from React Hook Form
 */
interface BaseFieldProps<TFieldValues extends FieldValues = FieldValues> {
  /**
   * Unique identifier for the field
   */
  id: string;
  /**
   * Label text to display
   */
  label: string;
  /**
   * Placeholder text when empty
   */
  placeholder?: string;
  /**
   * Helper text to display below the field
   */
  helperText?: string;
  /**
   * Field width for layout
   */
  width?: 'full' | 'half' | 'third';
  /**
   * Validation rules for the field
   */
  validation?: FieldValidation;
  /**
   * Form control from React Hook Form
   */
  control: Control<TFieldValues>;
  /**
   * Field name in the form
   */
  name: FieldPath<TFieldValues>;
  /**
   * Whether the field should be displayed as read-only/disabled.
   * @default false
   */
  readOnly?: boolean;
}
/**
 * BaseField component to provide a consistent layout for form fields
 *
 * @important This component is the foundation of the app rendering architecture and should
 * ONLY be used by field-specific components within the system, not as a standalone component.
 *
 * Architecture role:
 * 1. Provides a consistent layout structure for all field types
 * 2. Handles integration with React Hook Form through the FormField component
 * 3. Manages common rendering aspects like labels, error messages, and help text
 * 4. Delegates actual input rendering to field-specific components via renderInput
 *
 * Field component hierarchy:
 * - TransactionForm (top-level renderer)
 *   - DynamicFormField (field type selector)
 *     - Specific field components (TextField, NumberField, etc.)
 *       - BaseField (common field structure - this component)
 *         - Actual input element rendered by renderInput
 *
 * This component should only be extended by field-specific components like
 * TextField, NumberField, and AddressField - it is not meant for direct use in forms.
 */
declare function BaseField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  helperText,
  control,
  name,
  width,
  renderInput
}: BaseFieldProps<TFieldValues> & {
  renderInput: (field: Record<string, unknown>, props: {
    id: string;
    ref?: ForwardedRef<HTMLElement>;
  }) => ReactNode;
  ref?: ForwardedRef<HTMLElement>;
}): ReactElement;
declare namespace BaseField {
  var displayName: string;
}
//#endregion
//#region src/components/fields/AddressField.d.ts
interface AddressFieldProps<TFieldValues extends FieldValues = FieldValues> extends BaseFieldProps<TFieldValues> {
  adapter?: ContractAdapter;
}
/**
 * Address input field component specifically designed for blockchain addresses via React Hook Form integration.
 *
 * Architecture flow:
 * 1. Form schemas are generated from contract functions using adapters
 * 2. TransactionForm renders the overall form structure with React Hook Form
 * 3. DynamicFormField selects the appropriate field component (like AddressField) based on field type
 * 4. BaseField provides consistent layout and hook form integration
 * 5. This component handles blockchain address-specific rendering and validation using the passed adapter
 *
 * The component includes:
 * - Integration with React Hook Form
 * - Blockchain address validation through adapter-provided custom validation
 * - Automatic error handling and reporting
 * - Chain-agnostic design (validation handled by adapters)
 * - Full accessibility support with ARIA attributes
 * - Keyboard navigation
 */
declare function AddressField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  placeholder,
  helperText,
  control,
  name,
  width,
  validation,
  adapter,
  readOnly
}: AddressFieldProps<TFieldValues>): React$1.ReactElement;
declare namespace AddressField {
  var displayName: string;
}
//#endregion
//#region src/components/fields/AmountField.d.ts
/**
 * AmountField component properties
 */
interface AmountFieldProps<TFieldValues extends FieldValues = FieldValues> extends BaseFieldProps<TFieldValues> {
  /**
   * Minimum value validation
   */
  min?: number;
  /**
   * Maximum value validation
   */
  max?: number;
  /**
   * Step value for increment/decrement
   */
  step?: number;
  /**
   * Number of decimal places to allow
   */
  decimals?: number;
  /**
   * Currency/token symbol to display
   */
  symbol?: string;
  /**
   * Position of the symbol (before or after the amount)
   */
  symbolPosition?: 'prefix' | 'suffix';
  /**
   * Custom validation function for amount values
   */
  validateAmount?: (value: number) => boolean | string;
}
/**
 * Amount input field component specifically designed for currency/token amounts with React Hook Form integration.
 *
 * Architecture flow:
 * 1. Form schemas are generated from contract functions using adapters
 * 2. TransactionForm renders the overall form structure with React Hook Form
 * 3. DynamicFormField selects the appropriate field component based on field type
 * 4. BaseField provides consistent layout and hook form integration
 * 5. This component handles amount-specific rendering and validation
 *
 * The component includes:
 * - Integration with React Hook Form
 * - Support for currency/token symbols
 * - Numeric-specific validations (min, max, decimals)
 * - Customizable validation through adapter integration
 * - Automatic error handling and reporting
 * - Full accessibility support with ARIA attributes
 * - Keyboard navigation with arrow keys for numeric increment/decrement
 */
declare function AmountField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  placeholder,
  helperText,
  control,
  name,
  width,
  validation,
  min,
  max,
  step,
  decimals,
  symbol,
  symbolPosition,
  validateAmount
}: AmountFieldProps<TFieldValues>): React$1.ReactElement;
declare namespace AmountField {
  var displayName: string;
}
//#endregion
//#region src/components/fields/ArrayField.d.ts
/**
 * ArrayField component properties
 */
interface ArrayFieldProps<TFieldValues extends FieldValues = FieldValues> extends BaseFieldProps<TFieldValues> {
  /**
   * The type of elements in the array (e.g., 'text', 'number', 'blockchain-address')
   */
  elementType?: FormFieldType['type'];
  /**
   * Minimum number of array elements
   */
  minItems?: number;
  /**
   * Maximum number of array elements
   */
  maxItems?: number;
  /**
   * Base configuration for array element fields.
   * This allows specifying common properties like placeholder, helperText, or specific validation
   * for each element in the array.
   */
  elementFieldConfig?: Partial<FormFieldType>;
  /**
   * Render function for array elements.
   * This is crucial for rendering complex elements or integrating custom field components.
   */
  renderElement?: (field: FormFieldType, index: number) => React$1.ReactNode;
}
/**
 * Array input field component specifically designed for React Hook Form integration.
 *
 * This component provides a dynamic interface for managing array inputs with:
 * - Add/remove functionality for array items
 * - Validation for array length constraints
 * - Integration with existing field components for array elements
 * - Full accessibility support
 *
 * The component reuses existing field components (TextField, NumberField, etc.)
 * for individual array elements, maintaining consistency across the form system.
 *
 * Why the extra guards and synchronization exist (post-mortem/rationale):
 * - In certain runtime states (StrictMode double-invocation, preview remounts, state rehydration
 *   from storage), React Hook Form's useFieldArray may not synchronously reflect an `append()`
 *   or `remove()` call in the immediately subsequent read (e.g., reading `fields.length` or
 *   `getValues(name)` right after the call). This resulted in newly added items (especially
 *   falsy defaults like 0/false) appearing briefly and then disappearing, or remove operations
 *   not updating the UI.
 * - To make array operations deterministic and resilient across flows (preview form with
 *   FormProvider and the wizard's "Use Hardcoded Value" without a provider), we:
 *   1) Read a stable snapshot of the array value BEFORE `append()` and, if the immediate
 *      post-append read doesn't reflect the addition, we coerce the state to
 *      "previousSnapshot + newValue" via `setValue` (when context exists) or `replace`.
 *   2) Avoid `remove()` race conditions by always computing the new array via filter and
 *      applying it with `replace`, which proved to be the most consistent across contexts.
 *   3) Keep `fields` in sync with the watched array value using a guarded `replace` in an effect.
 *      A ref flag (`isReplacingRef`) prevents infinite loops when we ourselves are driving
 *      the `replace`.
 *   4) Use optional chaining for form context (`formContext?.control`, `formContext?.getValues`,
 *      `formContext?.setValue`) so the component works with either an inherited FormProvider or
 *      an explicit `control` prop.
 *   5) Use `queueMicrotask` to reset the guard flag after our `replace` has been scheduled,
 *      avoiding an extra timer tick while ensuring the effect observes the final state.
 *
 * Guarantees:
 * - Operations are idempotent: the fallback only runs when the immediate read does not reflect
 *   the intended state, so we don't double-append/remove.
 * - Works both with and without FormProvider (preview vs wizard) due to context-agnostic state
 *   reads and `replace` fallback.
 */
declare function ArrayField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  helperText,
  control,
  name,
  width,
  validation,
  elementType,
  minItems,
  maxItems,
  elementFieldConfig,
  renderElement,
  readOnly
}: ArrayFieldProps<TFieldValues>): React$1.ReactElement;
declare namespace ArrayField {
  var displayName: string;
}
//#endregion
//#region src/components/fields/ArrayObjectField.d.ts
/**
 * ArrayObjectField component properties
 */
interface ArrayObjectFieldProps<TFieldValues extends FieldValues = FieldValues> extends BaseFieldProps<TFieldValues> {
  /**
   * The components/properties of each object in the array.
   * Defines the schema for the nested fields within each object item.
   */
  components?: FunctionParameter[];
  /**
   * Minimum number of array elements
   */
  minItems?: number;
  /**
   * Maximum number of array elements
   */
  maxItems?: number;
  /**
   * Render function for object properties.
   * This function is responsible for rendering each individual property
   * of an object within an array item.
   */
  renderProperty?: (field: FormFieldType, itemIndex: number, propertyName: string) => React$1.ReactNode;
  /**
   * Whether items should be collapsible.
   * Useful for managing UI complexity when objects have many properties.
   */
  collapsible?: boolean;
  /**
   * Whether items should start collapsed.
   */
  defaultCollapsed?: boolean;
  /**
   * The adapter for chain-specific type mapping.
   * Essential for correctly determining field types for object properties.
   */
  adapter?: ContractAdapter;
  /**
   * Optional contract schema to enrich nested field generation.
   */
  contractSchema?: ContractSchema;
}
/**
 * Array of objects input field component specifically designed for React Hook Form integration.
 *
 * This component provides a dynamic interface for managing arrays of composite objects with:
 * - Add/remove functionality for array items
 * - Structured rendering of object properties within each array item
 * - Collapsible items for better UX with complex objects
 * - Validation for array constraints and object properties (though individual property validation is largely via rendered component)
 * - Full accessibility support
 *
 * The component combines the functionality of ArrayField and ObjectField to handle
 * complex nested data structures commonly found in blockchain contracts.
 */
declare function ArrayObjectField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  helperText,
  control,
  name,
  width,
  validation,
  components,
  minItems,
  maxItems,
  renderProperty,
  collapsible,
  defaultCollapsed,
  readOnly,
  adapter,
  contractSchema
}: ArrayObjectFieldProps<TFieldValues>): React$1.ReactElement;
declare namespace ArrayObjectField {
  var displayName: string;
}
//#endregion
//#region src/components/fields/BigIntField.d.ts
/**
 * BigIntField component properties
 */
interface BigIntFieldProps<TFieldValues extends FieldValues = FieldValues> extends BaseFieldProps<TFieldValues> {
  /**
   * Custom validation function for big integer string values
   */
  validateBigInt?: (value: string) => boolean | string;
}
/**
 * Big integer input field component for large numbers beyond JavaScript's Number precision.
 *
 * This component is designed for blockchain integer types like uint128, uint256, int128, int256
 * that can hold values larger than JavaScript's Number.MAX_SAFE_INTEGER (2^53 - 1).
 *
 * Architecture flow:
 * 1. Form schemas are generated from contract functions using adapters
 * 2. TransactionForm renders the overall form structure with React Hook Form
 * 3. DynamicFormField selects BigIntField for large integer types
 * 4. This component handles string-based integer input with validation
 * 5. Adapters convert the string to BigInt when submitting transactions
 *
 * The component includes:
 * - Integer-only validation (no decimals allowed)
 * - String-based storage to avoid JavaScript Number precision issues
 * - Integration with React Hook Form
 * - Automatic error handling and reporting
 * - Full accessibility support with ARIA attributes
 * - Keyboard navigation
 */
declare function BigIntField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  placeholder,
  helperText,
  control,
  name,
  width,
  validation,
  validateBigInt,
  readOnly
}: BigIntFieldProps<TFieldValues>): React$1.ReactElement;
declare namespace BigIntField {
  var displayName: string;
}
//#endregion
//#region src/components/fields/BooleanField.d.ts
/**
 * BooleanField component properties
 */
interface BooleanFieldProps<TFieldValues extends FieldValues = FieldValues> extends BaseFieldProps<TFieldValues> {
  /**
   * Custom validation function for boolean values
   */
  validateBoolean?: (value: boolean) => boolean | string;
}
/**
 * Boolean input field component (checkbox) specifically designed for React Hook Form integration.
 *
 * Architecture flow:
 * 1. Form schemas are generated from contract functions using adapters
 * 2. TransactionForm renders the overall form structure with React Hook Form
 * 3. DynamicFormField selects the appropriate field component (like BooleanField) based on field type
 * 4. BaseField provides consistent layout and hook form integration
 * 5. This component handles boolean-specific rendering and validation
 *
 * The component includes:
 * - Integration with React Hook Form
 * - Checkbox-specific behavior
 * - Customizable validation through adapter integration
 * - Automatic error handling and reporting
 * - Full accessibility support with ARIA attributes
 * - Keyboard navigation with Space/Enter for toggling
 */
declare function BooleanField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  helperText,
  control,
  name,
  width,
  validation,
  validateBoolean,
  readOnly
}: BooleanFieldProps<TFieldValues>): React$1.ReactElement;
declare namespace BooleanField {
  var displayName: string;
}
//#endregion
//#region src/components/fields/BytesField.d.ts
/**
 * BytesField component properties
 */
interface BytesFieldProps<TFieldValues extends FieldValues = FieldValues> extends BaseFieldProps<TFieldValues> {
  /**
   * Number of rows for the textarea
   */
  rows?: number;
  /**
   * Maximum length in bytes (not characters)
   */
  maxBytes?: number;
  /**
   * Exact length in bytes required (for fixed-size types like bytes32)
   * When set, the value must be exactly this many bytes.
   * Takes precedence over maxBytes.
   */
  exactBytes?: number;
  /**
   * Whether to accept hex, base64, or both formats
   */
  acceptedFormats?: 'hex' | 'base64' | 'both';
  /**
   * Whether to automatically add/remove 0x prefix for hex values
   */
  autoPrefix?: boolean;
  /**
   * Whether to allow 0x prefix in hex input (defaults to true)
   */
  allowHexPrefix?: boolean;
}
/**
 * Specialized input field for bytes data with built-in hex/base64 validation.
 *
 * This component provides proper validation for blockchain bytes data including:
 * - Hex encoding validation (with optional 0x prefix support)
 * - Base64 encoding validation
 * - Byte length validation
 * - Format detection and conversion
 *
 * Key props for EVM compatibility:
 * - `allowHexPrefix`: Whether to accept 0x prefixed input (defaults to true)
 * - `autoPrefix`: Whether to automatically add 0x prefixes (defaults to false)
 *
 * These are separate concerns - you can accept 0x input without auto-adding prefixes.
 *
 * Architecture flow:
 * 1. Form schemas are generated from contract functions using adapters
 * 2. TransactionForm renders the overall form structure with React Hook Form
 * 3. DynamicFormField selects BytesField for 'bytes' field types
 * 4. BaseField provides consistent layout and hook form integration
 * 5. This component handles bytes-specific validation and formatting
 */
declare function BytesField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  helperText,
  control,
  name,
  width,
  validation,
  placeholder,
  rows,
  maxBytes,
  exactBytes,
  acceptedFormats,
  autoPrefix,
  allowHexPrefix,
  readOnly
}: BytesFieldProps<TFieldValues>): React$1.ReactElement;
declare namespace BytesField {
  var displayName: string;
}
//#endregion
//#region src/components/fields/DateTimeField.d.ts
/**
 * DateTimeField component properties
 */
interface DateTimeFieldProps<TFieldValues extends FieldValues = FieldValues> extends BaseFieldProps<TFieldValues> {
  /**
   * Placeholder text displayed when the field is empty
   */
  placeholder?: string;
  /**
   * If true, clears the field when user clicks Escape; otherwise just blurs
   */
  clearOnEscape?: boolean;
}
/**
 * Datetime-local input field component specifically designed for React Hook Form integration.
 *
 * Architecture flow:
 * 1. Form schemas are generated from contract functions using adapters
 * 2. TransactionForm renders the overall form structure with React Hook Form
 * 3. DynamicFormField selects the appropriate field component (like DateTimeField) based on field type
 * 4. BaseField provides consistent layout and hook form integration
 * 5. This component handles date-time specific rendering, conversion, and validation
 *
 * The component includes:
 * - Integration with React Hook Form
 * - Conversion between input value (YYYY-MM-DDTHH:mm) and ISO 8601 strings (toISOString)
 * - Customizable validation through adapter integration
 * - Automatic error handling and reporting
 * - Full accessibility support with ARIA attributes
 * - Keyboard navigation with Escape-to-clear behavior
 */
declare function DateTimeField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  placeholder,
  helperText,
  control,
  name,
  width,
  validation,
  readOnly,
  clearOnEscape
}: DateTimeFieldProps<TFieldValues>): React$1.ReactElement;
declare namespace DateTimeField {
  var displayName: string;
}
//#endregion
//#region src/components/fields/EnumField.d.ts
/**
 * Enum variant definition
 */
interface EnumVariant {
  /** Name of the variant (e.g., 'One', 'Two', 'Three') */
  name: string;
  /** Type of variant: 'void' for unit variants, 'tuple' for variants with payload, 'integer' for numeric enums */
  type: 'void' | 'tuple' | 'integer';
  /** For tuple variants: array of payload type names (e.g., ['U32', 'ScString']) */
  payloadTypes?: string[];
  /** Optional nested component definitions for tuple payload entries */
  payloadComponents?: (FunctionParameter[] | undefined)[];
  /** For integer variants: the numeric value */
  value?: number;
  /** Flag indicating if this variant has a single Tuple payload (for serialization) */
  isSingleTuplePayload?: boolean;
}
/**
 * Enum metadata extracted from contract spec
 */
interface EnumMetadata {
  /** Name of the enum type */
  name: string;
  /** Array of variants in the enum */
  variants: EnumVariant[];
  /** True if all variants are unit variants (no payloads), suitable for simple select/radio */
  isUnitOnly: boolean;
}
/**
 * Enum field value structure for blockchain enum types
 */
type EnumFieldValue = EnumValue;
/**
 * EnumField component properties
 */
interface EnumFieldProps<TFieldValues extends FieldValues = FieldValues> extends BaseFieldProps<TFieldValues> {
  /**
   * Enum metadata containing variant information
   */
  enumMetadata?: EnumMetadata;
  /**
   * Custom validation function for enum values
   */
  validateEnum?: (value: EnumFieldValue) => boolean | string;
  /**
   * Render function for payload input fields.
   * This allows the parent component to provide appropriate field components
   * based on the payload type, maintaining separation of concerns.
   */
  renderPayloadField?: (field: FormFieldType, payloadIndex: number) => React$1.ReactNode;
}
/**
 * Composite enum field component for blockchain enum types.
 *
 * This component handles both unit enums (simple variants) and tagged enums (variants with payloads).
 * For unit enums, it renders as a simple select dropdown.
 * For tagged enums, it renders a variant picker plus conditional input fields for payload data.
 *
 * The value format is designed to be chain-agnostic:
 * - Unit variants: { tag: "VariantName" }
 * - Tuple variants: { tag: "VariantName", values: [...] }
 */
declare function EnumField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  placeholder,
  helperText,
  control,
  name,
  width,
  validation,
  enumMetadata,
  validateEnum,
  renderPayloadField,
  readOnly
}: EnumFieldProps<TFieldValues>): React$1.ReactElement;
declare namespace EnumField {
  var displayName: string;
}
//#endregion
//#region src/components/fields/FileUploadField.d.ts
/**
 * FileUploadField component properties
 */
interface FileUploadFieldProps<TFieldValues extends FieldValues = FieldValues> extends BaseFieldProps<TFieldValues> {
  /**
   * Accepted file types (e.g., ".zip,.tar.gz")
   */
  accept?: string;
  /**
   * Maximum file size in bytes
   */
  maxSize?: number;
  /**
   * Whether to convert the file to base64 string
   */
  convertToBase64?: boolean;
}
/** File upload field component with drag-and-drop support. */
declare function FileUploadField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  placeholder,
  helperText,
  control,
  name,
  width,
  validation,
  readOnly,
  accept,
  maxSize,
  convertToBase64
}: FileUploadFieldProps<TFieldValues>): React.ReactElement;
//#endregion
//#region src/components/fields/MapField/MapField.d.ts
/**
 * MapField component properties
 */
interface MapFieldProps<TFieldValues extends FieldValues = FieldValues> extends BaseFieldProps<TFieldValues> {
  /**
   * Map metadata containing key and value type information
   */
  mapMetadata?: {
    keyType?: string;
    valueType?: string;
    keyFieldConfig?: Partial<FormFieldType>;
    valueFieldConfig?: Partial<FormFieldType>;
  };
  /**
   * Minimum number of map entries
   */
  minItems?: number;
  /**
   * Render function for map keys.
   * This allows the parent component to provide appropriate field components
   * based on the key type, maintaining separation of concerns.
   */
  renderKeyField?: (field: FormFieldType, entryIndex: number) => React$1.ReactNode;
  /**
   * Render function for map values.
   * This allows the parent component to provide appropriate field components
   * based on the value type, maintaining separation of concerns.
   */
  renderValueField?: (field: FormFieldType, entryIndex: number) => React$1.ReactNode;
}
/**
 * Map (key-value dictionary) input field component specifically designed for React Hook Form integration.
 *
 * This component provides a dynamic interface for managing map/dictionary inputs with:
 * - Add/remove functionality for key-value pairs
 * - Validation for map size constraints
 * - Integration with existing field components for keys and values
 * - Chain-agnostic data format (array of {key, value} objects)
 * - Full accessibility support
 *
 * Architecture flow:
 * 1. Form schemas are generated from contract functions using adapters
 * 2. TransactionForm renders the overall form structure with React Hook Form
 * 3. DynamicFormField selects the appropriate field component (like MapField) based on field type
 * 4. BaseField provides consistent layout and hook form integration
 * 5. This component handles map-specific rendering and validation
 *
 * The component stores data in a chain-agnostic format as an array of {key, value} objects.
 * The adapter is responsible for converting this to the chain-specific format (e.g., SorobanMapEntry[])
 * when submitting to the blockchain.
 */
declare function MapField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  helperText,
  control,
  name,
  width,
  validation,
  mapMetadata,
  minItems,
  renderKeyField,
  renderValueField,
  readOnly
}: MapFieldProps<TFieldValues>): React$1.ReactElement;
declare namespace MapField {
  var displayName: string;
}
//#endregion
//#region src/components/fields/MapField/MapEntryRow.d.ts
interface Props {
  keyField: FormFieldType;
  valueField: FormFieldType;
  isDuplicateKey: boolean;
  renderKeyField?: (field: FormFieldType, entryIndex: number) => React$1.ReactNode;
  renderValueField?: (field: FormFieldType, entryIndex: number) => React$1.ReactNode;
  index: number;
}
/** Renders a single key-value entry row in a map field. */
declare function MapEntryRow({
  keyField,
  valueField,
  isDuplicateKey,
  renderKeyField,
  renderValueField,
  index
}: Props): React$1.ReactElement;
//#endregion
//#region src/components/fields/MapField/hooks/useChildTouched.d.ts
/** Computes whether any child field in a map has been touched. */
declare function computeChildTouched(formContext: UseFormReturn | undefined, name: string, watchedValue: unknown): boolean;
//#endregion
//#region src/components/fields/MapField/hooks/useDuplicateKeyIndexes.d.ts
/** Hook that returns indexes of map entries with duplicate keys. */
declare function useDuplicateKeyIndexes(watchedValue: unknown): Set<number>;
//#endregion
//#region src/components/fields/MapField/hooks/useMapFieldSync.d.ts
/**
 * Keeps a field array synchronized with a watched value's length using replace,
 * while preventing infinite loops via a guard ref.
 */
declare function useMapFieldSync<TReplaceValue>(watchedValue: unknown, fieldsLength: number, replace: (value: TReplaceValue) => void): ReturnType<typeof React$1.useRef<boolean>>;
//#endregion
//#region src/components/fields/MapField/validation/validateMapStructure.d.ts
interface ValidateArgs {
  value: unknown;
  required: boolean;
  minItems?: number;
}
/** Validates a map field's structure including duplicates and required entries. */
declare function validateMapStructure({
  value,
  required,
  minItems
}: ValidateArgs): string | true;
//#endregion
//#region src/components/fields/NumberField.d.ts
/**
 * NumberField component properties
 */
interface NumberFieldProps<TFieldValues extends FieldValues = FieldValues> extends BaseFieldProps<TFieldValues> {
  /**
   * Minimum value validation
   */
  min?: number;
  /**
   * Maximum value validation
   */
  max?: number;
  /**
   * Step value for increment/decrement
   */
  step?: number;
  /**
   * Custom validation function for number values
   */
  validateNumber?: (value: number) => boolean | string;
}
/**
 * Number input field component specifically designed for React Hook Form integration.
 *
 * Architecture flow:
 * 1. Form schemas are generated from contract functions using adapters
 * 2. TransactionForm renders the overall form structure with React Hook Form
 * 3. DynamicFormField selects the appropriate field component (like NumberField) based on field type
 * 4. BaseField provides consistent layout and hook form integration
 * 5. This component handles number-specific rendering and validation
 *
 * The component includes:
 * - Integration with React Hook Form
 * - Numeric-specific validations (min, max, step)
 * - Customizable validation through adapter integration
 * - Automatic error handling and reporting
 * - Full accessibility support with ARIA attributes
 * - Keyboard navigation with arrow keys for numeric increment/decrement
 */
declare function NumberField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  placeholder,
  helperText,
  control,
  name,
  width,
  validation,
  min,
  max,
  step,
  validateNumber,
  readOnly
}: NumberFieldProps<TFieldValues>): React$1.ReactElement;
declare namespace NumberField {
  var displayName: string;
}
//#endregion
//#region src/components/fields/ObjectField.d.ts
/**
 * ObjectField component properties
 */
interface ObjectFieldProps<TFieldValues extends FieldValues = FieldValues> extends BaseFieldProps<TFieldValues> {
  /**
   * The components/properties of the object.
   * These define the schema for the nested fields within the object.
   */
  components?: FunctionParameter[];
  /**
   * Render function for object properties.
   * This is crucial for rendering complex properties or integrating custom field components.
   */
  renderProperty?: (field: FormFieldType, propertyName: string) => React$1.ReactNode;
  /**
   * Whether to show the object in a card container.
   * Useful for visually grouping object properties.
   */
  showCard?: boolean;
  /**
   * The adapter for chain-specific type mapping.
   * Essential for correctly determining field types for object properties.
   */
  adapter?: ContractAdapter;
  /**
   * Optional contract schema for nested metadata (structs/enums).
   */
  contractSchema?: ContractSchema;
}
/**
 * Object (composite/nested) input field component specifically designed for React Hook Form integration.
 *
 * This component provides a structured interface for managing object inputs with:
 * - Nested field rendering based on object components
 * - Validation for required properties (currently, the object itself can be required)
 * - Integration with existing field components for object properties
 * - Full accessibility support
 *
 * The component reuses existing field components for individual properties,
 * maintaining consistency across the form system while supporting complex nested structures.
 */
declare function ObjectField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  helperText,
  control,
  name,
  width,
  validation,
  components,
  renderProperty,
  showCard,
  readOnly,
  adapter,
  contractSchema
}: ObjectFieldProps<TFieldValues>): React$1.ReactElement;
declare namespace ObjectField {
  var displayName: string;
}
//#endregion
//#region src/components/fields/PasswordField.d.ts
/**
 * PasswordField component properties
 */
interface PasswordFieldProps<TFieldValues extends FieldValues = FieldValues> extends BaseFieldProps<TFieldValues> {
  /**
   * Placeholder text displayed when the field is empty
   */
  placeholder?: string;
  /**
   * Whether to show the password visibility toggle button
   * @default true
   */
  showToggle?: boolean;
}
/**
 * Password input field component specifically designed for React Hook Form integration.
 *
 * Architecture flow:
 * 1. Form schemas are generated from contract functions using adapters
 * 2. TransactionForm renders the overall form structure with React Hook Form
 * 3. DynamicFormField selects the appropriate field component (like PasswordField) based on field type
 * 4. BaseField provides consistent layout and hook form integration
 * 5. This component handles password-specific rendering and validation
 *
 * The component includes:
 * - Integration with React Hook Form
 * - Password visibility toggle functionality
 * - Password-specific validations (minLength, maxLength, pattern)
 * - Customizable validation through adapter integration
 * - Automatic error handling and reporting
 * - Full accessibility support with ARIA attributes
 * - Keyboard navigation
 */
declare function PasswordField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  placeholder,
  helperText,
  control,
  name,
  width,
  validation,
  readOnly,
  showToggle
}: PasswordFieldProps<TFieldValues>): React$1.ReactElement;
declare namespace PasswordField {
  var displayName: string;
}
//#endregion
//#region src/components/fields/RadioField.d.ts
/**
 * Option item for radio fields
 */
interface RadioOption {
  /**
   * Value to be submitted with the form
   */
  value: string;
  /**
   * Display label for the option
   */
  label: string;
  /**
   * Whether this option is disabled
   */
  disabled?: boolean;
}
/**
 * RadioField component properties
 */
interface RadioFieldProps<TFieldValues extends FieldValues = FieldValues> extends BaseFieldProps<TFieldValues> {
  /**
   * Available options for selection
   */
  options?: RadioOption[];
  /**
   * Direction of radio options layout
   */
  layout?: 'horizontal' | 'vertical';
  /**
   * Custom validation function for radio values
   */
  validateRadio?: (value: string) => boolean | string;
}
/**
 * Radio button field component specifically designed for React Hook Form integration.
 *
 * Architecture flow:
 * 1. Form schemas are generated from contract functions using adapters
 * 2. TransactionForm renders the overall form structure with React Hook Form
 * 3. DynamicFormField selects the appropriate field component based on field type
 * 4. BaseField provides consistent layout and hook form integration
 * 5. This component handles radio-specific rendering and validation
 *
 * The component includes:
 * - Integration with React Hook Form
 * - Customizable options list
 * - Horizontal or vertical layout options
 * - Customizable validation through adapter integration
 * - Automatic error handling and reporting
 * - Full accessibility support with ARIA attributes
 */
declare function RadioField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  helperText,
  control,
  name,
  width,
  validation,
  options,
  layout,
  validateRadio
}: RadioFieldProps<TFieldValues>): React$1.ReactElement;
declare namespace RadioField {
  var displayName: string;
}
//#endregion
//#region src/components/fields/SelectField.d.ts
/**
 * Option item for select fields
 */
interface SelectOption {
  /**
   * Value to be submitted with the form
   */
  value: string;
  /**
   * Display label for the option
   */
  label: string;
  /**
   * Whether this option is disabled
   */
  disabled?: boolean;
}
/**
 * SelectField component properties
 */
interface SelectFieldProps<TFieldValues extends FieldValues = FieldValues> extends BaseFieldProps<TFieldValues> {
  /**
   * Available options for selection
   */
  options?: SelectOption[];
  /**
   * Custom validation function for select values
   */
  validateSelect?: (value: string) => boolean | string;
  /**
   * Optional default value used when the field has no value yet
   */
  defaultValue?: string;
}
/**
 * Select dropdown field component specifically designed for React Hook Form integration.
 *
 * Architecture flow:
 * 1. Form schemas are generated from contract functions using adapters
 * 2. TransactionForm renders the overall form structure with React Hook Form
 * 3. DynamicFormField selects the appropriate field component based on field type
 * 4. BaseField provides consistent layout and hook form integration
 * 5. This component handles radio-specific rendering and validation
 *
 * The component includes:
 * - Integration with React Hook Form
 * - Customizable options list
 * - Horizontal or vertical layout options
 * - Customizable validation through adapter integration
 * - Automatic error handling and reporting
 * - Full accessibility support with ARIA attributes
 */
declare function SelectField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  placeholder,
  helperText,
  control,
  name,
  width,
  validation,
  options,
  validateSelect,
  defaultValue
}: SelectFieldProps<TFieldValues>): React$1.ReactElement;
declare namespace SelectField {
  var displayName: string;
}
//#endregion
//#region src/components/fields/SelectGroupedField.d.ts
/**
 * Option item for select fields with visual indicators
 */
interface GroupedSelectOption {
  /**
   * Value to be submitted with the form
   */
  value: string;
  /**
   * Display label for the option
   */
  label: string;
  /**
   * Whether this option is disabled
   */
  disabled?: boolean;
  /**
   * Custom CSS class to apply to the option
   */
  className?: string;
}
/**
 * Option group structure
 */
interface OptionGroup {
  /**
   * Group label to display
   */
  label: string;
  /**
   * Options within this group
   */
  options: GroupedSelectOption[];
}
/**
 * SelectGroupedField component properties
 */
interface SelectGroupedFieldProps<TFieldValues extends FieldValues = FieldValues> extends BaseFieldProps<TFieldValues> {
  /**
   * Available option groups for selection
   */
  groups?: OptionGroup[];
  /**
   * Custom validation function for select values
   */
  validateSelect?: (value: string) => boolean | string;
}
/**
 * Select dropdown field component with grouped options specifically designed for React Hook Form integration.
 *
 * Architecture flow:
 * 1. Form schemas are generated from contract functions using adapters
 * 2. TransactionForm renders the overall form structure with React Hook Form
 * 3. DynamicFormField selects the appropriate field component based on field type
 * 4. BaseField provides consistent layout and hook form integration
 * 5. This component handles radio-specific rendering and validation
 *
 * The component includes:
 * - Integration with React Hook Form
 * - Customizable options list
 * - Horizontal or vertical layout options
 * - Customizable validation through adapter integration
 * - Automatic error handling and reporting
 * - Full accessibility support with ARIA attributes
 */
declare function SelectGroupedField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  placeholder,
  helperText,
  control,
  name,
  width,
  validation,
  groups,
  validateSelect
}: SelectGroupedFieldProps<TFieldValues>): React$1.ReactElement;
declare namespace SelectGroupedField {
  var displayName: string;
}
//#endregion
//#region src/components/fields/TextAreaField.d.ts
/**
 * TextAreaField component properties
 */
interface TextAreaFieldProps<TFieldValues extends FieldValues = FieldValues> extends BaseFieldProps<TFieldValues> {
  /**
   * Number of rows for the textarea
   */
  rows?: number;
  /**
   * Maximum characters allowed in textarea
   */
  maxLength?: number;
  /**
   * Custom validation function for textarea values
   */
  validateTextArea?: (value: string) => boolean | string;
}
/**
 * Multi-line text input field component specifically designed for React Hook Form integration.
 *
 * Architecture flow:
 * 1. Form schemas are generated from contract functions using adapters
 * 2. TransactionForm renders the overall form structure with React Hook Form
 * 3. DynamicFormField selects the appropriate field component based on field type
 * 4. BaseField provides consistent layout and hook form integration
 * 5. This component handles textarea-specific rendering and validation
 *
 * The component includes:
 * - Integration with React Hook Form
 * - Resizable multi-line text input
 * - Character limit support
 * - Customizable validation through adapter integration
 * - Automatic error handling and reporting
 * - Full accessibility support with ARIA attributes
 * - Keyboard navigation with Escape to clear
 */
declare function TextAreaField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  placeholder,
  helperText,
  control,
  name,
  width,
  validation,
  rows,
  maxLength,
  validateTextArea
}: TextAreaFieldProps<TFieldValues>): React$1.ReactElement;
declare namespace TextAreaField {
  var displayName: string;
}
//#endregion
//#region src/components/fields/TextField.d.ts
/**
 * TextField component properties
 */
interface TextFieldProps<TFieldValues extends FieldValues = FieldValues> extends BaseFieldProps<TFieldValues> {
  /**
   * Placeholder text displayed when the field is empty
   */
  placeholder?: string;
}
/**
 * Text input field component specifically designed for React Hook Form integration.
 *
 * Architecture flow:
 * 1. Form schemas are generated from contract functions using adapters
 * 2. TransactionForm renders the overall form structure with React Hook Form
 * 3. DynamicFormField selects the appropriate field component (like TextField) based on field type
 * 4. BaseField provides consistent layout and hook form integration
 * 5. This component handles text-specific rendering and validation
 *
 * The component includes:
 * - Integration with React Hook Form
 * - Text-specific validations (minLength, maxLength, pattern)
 * - Customizable validation through adapter integration
 * - Automatic error handling and reporting
 * - Full accessibility support with ARIA attributes
 * - Keyboard navigation
 */
declare function TextField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  placeholder,
  helperText,
  control,
  name,
  width,
  validation,
  readOnly
}: TextFieldProps<TFieldValues>): React$1.ReactElement;
declare namespace TextField {
  var displayName: string;
}
//#endregion
//#region src/components/fields/UrlField.d.ts
/**
 * URL input field component specifically designed for React Hook Form integration.
 */
declare function UrlField<TFieldValues extends FieldValues = FieldValues>({
  id,
  label,
  placeholder,
  helperText,
  control,
  name,
  width,
  validation,
  readOnly
}: BaseFieldProps<TFieldValues>): React$1.ReactElement;
declare namespace UrlField {
  var displayName: string;
}
//#endregion
//#region src/components/fields/utils/accessibility.d.ts
/**
 * Accessibility utilities for form field components
 */
/**
 * Default aria-describedby ID generator based on field ID
 */
declare function getDescribedById(id: string, type?: 'error' | 'description' | 'counter'): string;
/**
 * Interface for accessibility attributes to be applied to form fields
 */
interface AccessibilityProps {
  /**
   * ARIA attributes for accessibility
   */
  'aria-invalid'?: boolean;
  'aria-required'?: boolean;
  'aria-describedby'?: string;
  'aria-errormessage'?: string;
  'aria-labelledby'?: string;
  /**
   * Indicates if the input is required
   */
  required?: boolean;
  /**
   * Indicates if the input is disabled
   */
  disabled?: boolean;
  /**
   * Indicates if the input is readonly
   */
  readOnly?: boolean;
  /**
   * Tab index for keyboard navigation
   * Use 0 for normal tab order
   * Use -1 to remove from tab order
   */
  tabIndex?: number;
}
/**
 * Generates accessibility attributes for form fields
 */
declare function getAccessibilityProps({
  id,
  hasError,
  isRequired,
  isDisabled,
  isReadOnly,
  hasHelperText,
  hasCharacterCounter
}: {
  id: string;
  hasError?: boolean;
  isRequired?: boolean;
  isDisabled?: boolean;
  isReadOnly?: boolean;
  hasHelperText?: boolean;
  hasCharacterCounter?: boolean;
}): AccessibilityProps;
/**
 * Utility function to handle keyboard events for interactive elements
 * Helps ensure keyboard users can interact with form controls
 */
declare function handleKeyboardEvent(event: React.KeyboardEvent, handlers: {
  onEnter?: () => void;
  onSpace?: () => void;
  onEscape?: () => void;
  onArrowUp?: () => void;
  onArrowDown?: () => void;
  onArrowLeft?: () => void;
  onArrowRight?: () => void;
  onTab?: () => void;
}): void;
/**
 * Field focus management utility
 * For managing focus within a field group or complex form component
 */
declare function createFocusManager(): {
  focusFirstElement: (container: HTMLElement | null) => void;
  focusElementById: (id: string) => void;
  trapFocus: (event: KeyboardEvent, container: HTMLElement | null) => void;
};
/**
 * Provides a handler for Escape key to clear input fields
 *
 * @param onChange - Function to call when value changes
 * @param value - Current value of the input
 * @returns A function to handle the Escape key press
 */
declare function handleEscapeKey(onChange: (value: string) => void, value: unknown): (e: React.KeyboardEvent) => void;
/**
 * Provides a handler for Space/Enter keys for toggle components (checkboxes, switches)
 *
 * @param onChange - Function to call when value changes
 * @param value - Current value of the input
 * @returns A function to handle the Space/Enter key press
 */
declare function handleToggleKeys(onChange: (value: boolean) => void, value: boolean): (e: React.KeyboardEvent) => void;
/**
 * Provides a handler for arrow keys for numeric inputs
 *
 * @param onChange - Function to call when value changes
 * @param value - Current numeric value
 * @param step - Step amount for increments/decrements
 * @param min - Minimum allowed value (optional)
 * @param max - Maximum allowed value (optional)
 * @returns A function to handle arrow key presses
 */
declare function handleNumericKeys(onChange: (value: number) => void, value: number, step?: number, min?: number, max?: number): (e: React.KeyboardEvent) => void;
//#endregion
//#region src/components/fields/utils/ErrorMessage.d.ts
interface ErrorMessageProps {
  /**
   * The error object from React Hook Form
   */
  error?: FieldError;
  /**
   * The ID of the error message for aria-errormessage references
   */
  id: string;
  /**
   * Optional custom error message to display instead of the error from React Hook Form
   */
  message?: string;
  /**
   * Optional additional CSS classes
   */
  className?: string;
}
/**
 * Displays validation error messages for form fields
 */
declare function ErrorMessage({
  error,
  id,
  message,
  className
}: ErrorMessageProps): React$1.ReactElement | null;
//#endregion
//#region src/components/fields/utils/integerValidation.d.ts
/**
 * Shared integer validation patterns for BigInt fields and validation utilities.
 *
 * These patterns ensure consistent validation across the application.
 */
/**
 * Integer validation pattern - requires at least one digit
 * Used for validation to ensure complete integers are entered
 * Matches: -123, 0, 456
 * Does not match: -, abc, 12.3
 */
declare const INTEGER_PATTERN: RegExp;
/**
 * Integer input pattern - allows partial input during typing
 * Used during input to allow users to type minus sign first
 * Matches: -, -1, 123, (empty string)
 * Does not match: abc, 12.3
 */
declare const INTEGER_INPUT_PATTERN: RegExp;
/**
 * HTML pattern attribute for integer inputs
 * Must use [0-9] instead of \d for HTML5 pattern attribute
 */
declare const INTEGER_HTML_PATTERN = "-?[0-9]*";
//#endregion
//#region src/components/fields/utils/layout.d.ts
/**
 * Layout utility functions for form components
 */
/**
 * Helper function to get width classes based on the field width
 */
declare function getWidthClasses(width: 'full' | 'half' | 'third'): string;
//#endregion
//#region src/components/fields/utils/validation.d.ts
/**
 * Determines if a field has an error
 */
declare function hasFieldError(error: FieldError | undefined): boolean;
/**
 * Gets appropriate error message from field error
 */
declare function getErrorMessage(error: FieldError | undefined): string | undefined;
/**
 * Formats validation error messages for display
 */
declare function formatValidationError(error: FieldError | undefined, fieldName?: string): string | undefined;
/**
 * Generates common CSS classes for field validation states
 */
declare function getValidationStateClasses(error: FieldError | undefined, touched?: boolean): string;
/**
 * Helper for handling form validation errors with React Hook Form
 */
declare function handleValidationError(error: FieldError | undefined, id: string): {
  errorId: string;
  errorMessage: string | undefined;
  hasError: boolean;
  validationClasses: string;
};
/**
 * Creates a validation result object for field components
 */
declare function createValidationResult(id: string, error: FieldError | undefined, touched?: boolean): {
  hasError: boolean;
  errorMessage: string | undefined;
  errorId: string;
  validationClasses: string;
  'aria-invalid': boolean;
  'aria-errormessage'?: string;
};
/**
 * Generic field validation function that can be used to validate any field type
 * based on common validation criteria
 */
declare function validateField(value: unknown, validation?: FieldValidation): string | boolean;
/**
 * Map validation utilities
 */
/**
 * Checks if a map entry at the given index has a duplicate key
 * @param entries - Array of map entries
 * @param currentIndex - Index of the entry to check
 * @returns true if the key at currentIndex is duplicated elsewhere in the array
 */
declare function isDuplicateMapKey(entries: MapEntry[], currentIndex: number): boolean;
/**
 * Validates an array of map entries for duplicate keys
 * @param entries - Array of map entries to validate
 * @returns Validation error message if duplicates found, otherwise undefined
 */
declare function validateMapEntries(entries: MapEntry[]): string | undefined;
//#endregion
//#region src/components/RelayerDetailsCard/RelayerDetailsCard.d.ts
interface RelayerDetailsCardProps {
  details: RelayerDetails;
  enhancedDetails?: RelayerDetailsRich | null;
  loading?: boolean;
  className?: string;
  /** Optional UI labels to override default copy */
  labels?: Partial<{
    detailsTitle: string;
    active: string;
    paused: string;
    systemDisabled: string;
    network: string;
    relayerId: string;
    balance: string;
    nonce: string;
    pending: string;
    lastTransaction: string;
  }>;
}
declare const RelayerDetailsCard: React$1.FC<RelayerDetailsCardProps>;
//#endregion
//#region src/components/network-errors/NetworkErrorNotificationProvider.d.ts
interface NetworkErrorNotificationProviderProps {
  children: React.ReactNode;
}
/** Provider component for managing and displaying network error notifications. */
declare function NetworkErrorNotificationProvider({
  children
}: NetworkErrorNotificationProviderProps): React.ReactNode;
//#endregion
//#region src/components/network-errors/useNetworkErrors.d.ts
type NetworkErrorType = 'rpc' | 'explorer';
interface NetworkError {
  id: string;
  type: NetworkErrorType;
  networkId: string;
  networkName: string;
  message: string;
  timestamp: number;
}
interface NetworkErrorContextValue {
  errors: NetworkError[];
  reportNetworkError: (type: NetworkErrorType, networkId: string, networkName: string, message: string) => void;
  clearError: (id: string) => void;
  clearAllErrors: () => void;
  onOpenNetworkSettings?: (networkId: string) => void;
  setOpenNetworkSettingsHandler: (handler: (networkId: string) => void) => void;
}
/** Hook to access network error reporting and management functions. */
declare function useNetworkErrors(): NetworkErrorContextValue;
/**
 * Hook for reporting network errors for a specific adapter
 */
declare function useNetworkErrorReporter(adapter: ContractAdapter | null): {
  reportRpcError: (message: string) => void;
  reportExplorerError: (message: string) => void;
};
//#endregion
//#region src/components/network-errors/NetworkErrorAwareAdapter.d.ts
/**
 * Creates an adapter proxy that intercepts and reports network errors
 */
declare function useNetworkErrorAwareAdapter(adapter: ContractAdapter | null): ContractAdapter | null;
//#endregion
//#region src/components/network-errors/NetworkServiceErrorBanner.d.ts
interface NetworkServiceErrorBannerProps {
  /** The network configuration for which the service connection failed */
  networkConfig: NetworkConfig;
  /** The type of service that failed (e.g., 'rpc', 'explorer', 'indexer') */
  serviceType: string;
  /** Optional custom error message to display */
  errorMessage?: string;
  /** Optional custom title override */
  title?: string;
  /** Optional custom description to show below the error message */
  description?: string;
  /**
   * Optional callback to open network settings dialog.
   * If not provided, will try to use the context from NetworkErrorNotificationProvider.
   * If neither is available, the settings button will not be rendered.
   */
  onOpenNetworkSettings?: (networkId: string) => void;
}
/**
 * User-friendly banner displayed when a network service connection fails.
 * Works with any service type (RPC, Explorer, Indexer, etc.) and provides
 * a clear explanation of the issue with a call-to-action to open the
 * network settings dialog where users can configure an alternative endpoint.
 *
 * This component can be used with or without the NetworkErrorNotificationProvider:
 * - With provider: The settings handler is obtained from context
 * - Without provider: Pass onOpenNetworkSettings prop directly, or the button won't render
 */
declare function NetworkServiceErrorBanner({
  networkConfig,
  serviceType,
  errorMessage,
  title,
  description,
  onOpenNetworkSettings: onOpenNetworkSettingsProp
}: NetworkServiceErrorBannerProps): React.ReactNode;
//#endregion
//#region src/components/icons/MidnightIcon.d.ts
interface MidnightIconProps {
  size?: number;
  className?: string;
  variant?: 'mono' | 'branded';
}
/**
 * MidnightIcon - SVG icon for the Midnight blockchain
 * Inline SVG to ensure it renders correctly when this package is consumed as a library
 */
declare function MidnightIcon({
  size,
  className,
  variant: _variant
}: MidnightIconProps): React$1.ReactElement;
//#endregion
//#region src/components/ui/sonner.d.ts
declare const Toaster: ({
  ...props
}: ToasterProps) => JSX.Element;
//#endregion
export { AccessibilityProps, Accordion, AccordionContent, type AccordionContentProps, AccordionItem, type AccordionItemProps, type AccordionProps, AccordionTrigger, type AccordionTriggerProps, AddressDisplay, AddressField, Alert, AlertDescription, AlertTitle, AmountField, AmountFieldProps, ArrayField, ArrayFieldProps, ArrayObjectField, ArrayObjectFieldProps, Banner, BaseField, BaseFieldProps, BigIntField, BigIntFieldProps, BooleanField, BooleanFieldProps, Button, ButtonProps, BytesField, BytesFieldProps, Calendar, CalendarProps, Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle, Checkbox, type DateRange, DateRangePicker, DateRangePickerProps, DateTimeField, DateTimeFieldProps, Dialog, DialogClose, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogOverlay, DialogPortal, DialogTitle, DialogTrigger, DropdownMenu, DropdownMenuCheckboxItem, DropdownMenuContent, DropdownMenuGroup, DropdownMenuItem, DropdownMenuLabel, DropdownMenuPortal, DropdownMenuRadioGroup, DropdownMenuRadioItem, DropdownMenuSeparator, DropdownMenuShortcut, DropdownMenuSub, DropdownMenuSubContent, DropdownMenuSubTrigger, DropdownMenuTrigger, EmptyState, EmptyStateProps, EnumField, EnumFieldProps, EnumFieldValue, EnumMetadata, EnumVariant, ErrorMessage, ExternalLink, FileUploadField, FileUploadFieldProps, Footer, FooterProps, Form, FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage, GroupedSelectOption, Header, HeaderProps, INTEGER_HTML_PATTERN, INTEGER_INPUT_PATTERN, INTEGER_PATTERN, Input, InputProps, Label, LoadingButton, LoadingButtonProps, MapEntryRow, MapField, MapFieldProps, MidnightIcon, type NetworkError, NetworkErrorNotificationProvider, type NetworkErrorType, NetworkIcon, NetworkIconProps, NetworkSelector, NetworkSelectorProps, NetworkServiceErrorBanner, type NetworkServiceErrorBannerProps, NetworkStatusBadge, NumberField, NumberFieldProps, ObjectField, ObjectFieldProps, OptionGroup, PasswordField, PasswordFieldProps, Popover, PopoverAnchor, PopoverContent, PopoverTrigger, Progress, RadioField, RadioFieldProps, RadioGroup, RadioGroupItem, RadioOption, RelayerDetailsCard, type RelayerDetailsCardProps, Select, SelectContent, SelectField, SelectFieldProps, SelectGroup, SelectGroupedField, SelectGroupedFieldProps, SelectItem, SelectLabel, SelectOption, SelectScrollDownButton, SelectScrollUpButton, SelectSeparator, SelectTrigger, SelectValue, SidebarButton, type SidebarButtonProps, SidebarGroup, type SidebarGroupProps, SidebarLayout, type SidebarLayoutProps, SidebarSection, type SidebarSectionProps, Tabs, TabsContent, TabsList, TabsTrigger, TextAreaField, TextAreaFieldProps, TextField, TextFieldProps, Textarea, TextareaProps, Toaster, Tooltip, TooltipContent, TooltipProvider, TooltipTrigger, UrlField, ViewContractStateButton, buttonVariants, computeChildTouched, createFocusManager, createValidationResult, formatValidationError, getAccessibilityProps, getDescribedById, getErrorMessage, getValidationStateClasses, getWidthClasses, handleEscapeKey, handleKeyboardEvent, handleNumericKeys, handleToggleKeys, handleValidationError, hasFieldError, isDuplicateMapKey, useDuplicateKeyIndexes, useMapFieldSync, useNetworkErrorAwareAdapter, useNetworkErrorReporter, useNetworkErrors, validateField, validateMapEntries, validateMapStructure };
//# sourceMappingURL=index.d.mts.map