//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
			key = keys[i];
			if (!__hasOwnProp.call(to, key) && key !== except) {
				__defProp(to, key, {
					get: ((k) => from[k]).bind(null, key),
					enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
				});
			}
		}
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
let react = require("react");
react = __toESM(react);
let react_jsx_runtime = require("react/jsx-runtime");

//#region src/components/fields/utils/integerValidation.ts
/**
* Shared integer validation patterns for BigInt fields and validation utilities.
*
* These patterns ensure consistent validation across the application.
*/
/**
* Integer validation pattern - requires at least one digit
* Used for validation to ensure complete integers are entered
* Matches: -123, 0, 456
* Does not match: -, abc, 12.3
*/
const INTEGER_PATTERN = /^-?\d+$/;
/**
* Integer input pattern - allows partial input during typing
* Used during input to allow users to type minus sign first
* Matches: -, -1, 123, (empty string)
* Does not match: abc, 12.3
*/
const INTEGER_INPUT_PATTERN = /^-?\d*$/;
/**
* HTML pattern attribute for integer inputs
* Must use [0-9] instead of \d for HTML5 pattern attribute
*/
const INTEGER_HTML_PATTERN = "-?[0-9]*";

//#endregion
//#region src/components/fields/utils/validation.ts
/**
* Determines if a field has an error
*/
function hasFieldError(error) {
	return !!error;
}
/**
* Gets appropriate error message from field error
*/
function getErrorMessage(error) {
	if (!error) return void 0;
	return error.message || "This field is invalid";
}
/**
* Formats validation error messages for display
*/
function formatValidationError(error, fieldName) {
	if (!error) return void 0;
	const defaultMessage = fieldName ? `${fieldName} is invalid` : "This field is invalid";
	return error.message || defaultMessage;
}
/**
* Generates common CSS classes for field validation states
*/
function getValidationStateClasses(error, touched) {
	if (error) return "border-destructive focus:border-destructive focus:ring-destructive/30";
	if (touched) return "border-success focus:border-success focus:ring-success/30";
	return "";
}
/**
* Helper for handling form validation errors with React Hook Form
*/
function handleValidationError(error, id) {
	const hasError = hasFieldError(error);
	const errorMessage = getErrorMessage(error);
	return {
		errorId: `${id}-error`,
		errorMessage,
		hasError,
		validationClasses: getValidationStateClasses(error)
	};
}
/**
* Creates a validation result object for field components
*/
function createValidationResult(id, error, touched) {
	const hasError = hasFieldError(error);
	const errorMessage = getErrorMessage(error);
	const errorId = `${id}-error`;
	return {
		hasError,
		errorMessage,
		errorId,
		validationClasses: getValidationStateClasses(error, touched),
		"aria-invalid": hasError,
		"aria-errormessage": hasError ? errorId : void 0
	};
}
/**
* Generic field validation function that can be used to validate any field type
* based on common validation criteria
*/
function validateField(value, validation) {
	if (!validation) return true;
	if (validation.required && (value === void 0 || value === null || value === "")) return typeof validation.required === "boolean" ? "This field is required" : "This field is required";
	if (value === void 0 || value === null || value === "") return true;
	if (typeof value === "string") {
		if (validation.minLength && value.length < validation.minLength) return `Minimum length is ${validation.minLength} characters`;
		if (validation.maxLength && value.length > validation.maxLength) return `Maximum length is ${validation.maxLength} characters`;
		if (validation.pattern) {
			if (!(typeof validation.pattern === "string" ? new RegExp(validation.pattern) : validation.pattern).test(value)) {
				if (!INTEGER_PATTERN.test(value) && /\d/.test(value)) return "Value must be a valid integer (no decimals)";
				return "Value does not match the required pattern";
			}
		}
	}
	if (typeof value === "number" || typeof value === "string" && !isNaN(Number(value))) {
		const numValue = typeof value === "number" ? value : Number(value);
		if (validation.min !== void 0 && numValue < validation.min) return `Minimum value is ${validation.min}`;
		if (validation.max !== void 0 && numValue > validation.max) return `Maximum value is ${validation.max}`;
	}
	if (validation.conditions && validation.conditions.length > 0) {}
	return true;
}
/**
* Map validation utilities
*/
/**
* Checks if a map entry at the given index has a duplicate key
* @param entries - Array of map entries
* @param currentIndex - Index of the entry to check
* @returns true if the key at currentIndex is duplicated elsewhere in the array
*/
function isDuplicateMapKey(entries, currentIndex) {
	if (!Array.isArray(entries) || entries.length <= 1) return false;
	const currentKeyValue = entries[currentIndex]?.key;
	if (!currentKeyValue || currentKeyValue === "") return false;
	return entries.some((entry, i) => {
		if (i === currentIndex) return false;
		const key = entry?.key;
		if (key === "") return false;
		if (typeof key === "string" && typeof currentKeyValue === "string") return key === currentKeyValue;
		if (typeof key === "number" && typeof currentKeyValue === "number") return Number.isNaN(key) ? Number.isNaN(currentKeyValue) : key === currentKeyValue;
		if (typeof key === "boolean" && typeof currentKeyValue === "boolean") return key === currentKeyValue;
		if (typeof key === "object" && key !== null && typeof currentKeyValue === "object" && currentKeyValue !== null) return key === currentKeyValue;
		return false;
	});
}
/**
* Validates an array of map entries for duplicate keys
* @param entries - Array of map entries to validate
* @returns Validation error message if duplicates found, otherwise undefined
*/
function validateMapEntries(entries) {
	if (!Array.isArray(entries) || entries.length <= 1) return;
	const keyStrings = entries.map((entry) => entry?.key).filter((key) => key !== void 0 && key !== null && key !== "").map((key) => String(key));
	const uniqueKeyStrings = new Set(keyStrings);
	if (keyStrings.length !== uniqueKeyStrings.size) return "Duplicate keys are not allowed";
}

//#endregion
//#region src/components/fields/utils/ErrorMessage.tsx
/**
* Displays validation error messages for form fields
*/
function ErrorMessage({ error, id, message, className = "" }) {
	const errorMessage = message || getErrorMessage(error);
	if (!errorMessage) return null;
	return /* @__PURE__ */ (0, react_jsx_runtime.jsx)("div", {
		id,
		className: `text-destructive mt-1 text-sm ${className}`,
		role: "alert",
		children: errorMessage
	});
}

//#endregion
Object.defineProperty(exports, 'ErrorMessage', {
  enumerable: true,
  get: function () {
    return ErrorMessage;
  }
});
Object.defineProperty(exports, 'INTEGER_HTML_PATTERN', {
  enumerable: true,
  get: function () {
    return INTEGER_HTML_PATTERN;
  }
});
Object.defineProperty(exports, 'INTEGER_INPUT_PATTERN', {
  enumerable: true,
  get: function () {
    return INTEGER_INPUT_PATTERN;
  }
});
Object.defineProperty(exports, 'INTEGER_PATTERN', {
  enumerable: true,
  get: function () {
    return INTEGER_PATTERN;
  }
});
Object.defineProperty(exports, '__toESM', {
  enumerable: true,
  get: function () {
    return __toESM;
  }
});
Object.defineProperty(exports, 'createValidationResult', {
  enumerable: true,
  get: function () {
    return createValidationResult;
  }
});
Object.defineProperty(exports, 'formatValidationError', {
  enumerable: true,
  get: function () {
    return formatValidationError;
  }
});
Object.defineProperty(exports, 'getErrorMessage', {
  enumerable: true,
  get: function () {
    return getErrorMessage;
  }
});
Object.defineProperty(exports, 'getValidationStateClasses', {
  enumerable: true,
  get: function () {
    return getValidationStateClasses;
  }
});
Object.defineProperty(exports, 'handleValidationError', {
  enumerable: true,
  get: function () {
    return handleValidationError;
  }
});
Object.defineProperty(exports, 'hasFieldError', {
  enumerable: true,
  get: function () {
    return hasFieldError;
  }
});
Object.defineProperty(exports, 'isDuplicateMapKey', {
  enumerable: true,
  get: function () {
    return isDuplicateMapKey;
  }
});
Object.defineProperty(exports, 'validateField', {
  enumerable: true,
  get: function () {
    return validateField;
  }
});
Object.defineProperty(exports, 'validateMapEntries', {
  enumerable: true,
  get: function () {
    return validateMapEntries;
  }
});
//# sourceMappingURL=ErrorMessage-D4BAP8iw.cjs.map